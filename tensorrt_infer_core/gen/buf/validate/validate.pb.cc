// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: buf/validate/validate.proto
// Protobuf C++ Version: 5.27.2

#include "buf/validate/validate.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace buf {
namespace validate {

inline constexpr Violation::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        field_path_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        constraint_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        for_key_{false} {}

template <typename>
PROTOBUF_CONSTEXPR Violation::Violation(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct ViolationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ViolationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ViolationDefaultTypeInternal() {}
  union {
    Violation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ViolationDefaultTypeInternal _Violation_default_instance_;

inline constexpr UInt64Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{::uint64_t{0u}},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR UInt64Rules::UInt64Rules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct UInt64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UInt64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UInt64RulesDefaultTypeInternal() {}
  union {
    UInt64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UInt64RulesDefaultTypeInternal _UInt64Rules_default_instance_;

inline constexpr UInt32Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{0u},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR UInt32Rules::UInt32Rules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct UInt32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UInt32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UInt32RulesDefaultTypeInternal() {}
  union {
    UInt32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UInt32RulesDefaultTypeInternal _UInt32Rules_default_instance_;

inline constexpr StringRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        pattern_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        prefix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        suffix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        contains_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        not_contains_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        min_len_{::uint64_t{0u}},
        max_len_{::uint64_t{0u}},
        min_bytes_{::uint64_t{0u}},
        max_bytes_{::uint64_t{0u}},
        len_{::uint64_t{0u}},
        len_bytes_{::uint64_t{0u}},
        strict_{false},
        well_known_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR StringRules::StringRules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct StringRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StringRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StringRulesDefaultTypeInternal() {}
  union {
    StringRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringRulesDefaultTypeInternal _StringRules_default_instance_;

inline constexpr SInt64Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{::int64_t{0}},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR SInt64Rules::SInt64Rules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SInt64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SInt64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SInt64RulesDefaultTypeInternal() {}
  union {
    SInt64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SInt64RulesDefaultTypeInternal _SInt64Rules_default_instance_;

inline constexpr SInt32Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{0},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR SInt32Rules::SInt32Rules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SInt32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SInt32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SInt32RulesDefaultTypeInternal() {}
  union {
    SInt32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SInt32RulesDefaultTypeInternal _SInt32Rules_default_instance_;

inline constexpr SFixed64Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{::int64_t{0}},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR SFixed64Rules::SFixed64Rules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SFixed64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SFixed64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SFixed64RulesDefaultTypeInternal() {}
  union {
    SFixed64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SFixed64RulesDefaultTypeInternal _SFixed64Rules_default_instance_;

inline constexpr SFixed32Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{0},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR SFixed32Rules::SFixed32Rules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SFixed32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SFixed32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SFixed32RulesDefaultTypeInternal() {}
  union {
    SFixed32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SFixed32RulesDefaultTypeInternal _SFixed32Rules_default_instance_;

inline constexpr OneofConstraints::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        required_{false} {}

template <typename>
PROTOBUF_CONSTEXPR OneofConstraints::OneofConstraints(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct OneofConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OneofConstraintsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OneofConstraintsDefaultTypeInternal() {}
  union {
    OneofConstraints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OneofConstraintsDefaultTypeInternal _OneofConstraints_default_instance_;

inline constexpr Int64Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{::int64_t{0}},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR Int64Rules::Int64Rules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct Int64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Int64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Int64RulesDefaultTypeInternal() {}
  union {
    Int64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Int64RulesDefaultTypeInternal _Int64Rules_default_instance_;

inline constexpr Int32Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{0},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR Int32Rules::Int32Rules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct Int32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Int32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Int32RulesDefaultTypeInternal() {}
  union {
    Int32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Int32RulesDefaultTypeInternal _Int32Rules_default_instance_;

inline constexpr FloatRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{0},
        finite_{false},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR FloatRules::FloatRules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct FloatRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FloatRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FloatRulesDefaultTypeInternal() {}
  union {
    FloatRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FloatRulesDefaultTypeInternal _FloatRules_default_instance_;

inline constexpr Fixed64Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{::uint64_t{0u}},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR Fixed64Rules::Fixed64Rules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct Fixed64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fixed64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fixed64RulesDefaultTypeInternal() {}
  union {
    Fixed64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fixed64RulesDefaultTypeInternal _Fixed64Rules_default_instance_;

inline constexpr Fixed32Rules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{0u},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR Fixed32Rules::Fixed32Rules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct Fixed32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fixed32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fixed32RulesDefaultTypeInternal() {}
  union {
    Fixed32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fixed32RulesDefaultTypeInternal _Fixed32Rules_default_instance_;

inline constexpr EnumRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{0},
        defined_only_{false} {}

template <typename>
PROTOBUF_CONSTEXPR EnumRules::EnumRules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct EnumRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnumRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnumRulesDefaultTypeInternal() {}
  union {
    EnumRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnumRulesDefaultTypeInternal _EnumRules_default_instance_;

inline constexpr DoubleRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{0},
        finite_{false},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR DoubleRules::DoubleRules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct DoubleRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoubleRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoubleRulesDefaultTypeInternal() {}
  union {
    DoubleRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoubleRulesDefaultTypeInternal _DoubleRules_default_instance_;

inline constexpr Constraint::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        expression_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR Constraint::Constraint(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct ConstraintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConstraintDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConstraintDefaultTypeInternal() {}
  union {
    Constraint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConstraintDefaultTypeInternal _Constraint_default_instance_;

inline constexpr BytesRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        pattern_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        prefix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        suffix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        contains_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        min_len_{::uint64_t{0u}},
        max_len_{::uint64_t{0u}},
        len_{::uint64_t{0u}},
        well_known_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR BytesRules::BytesRules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct BytesRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BytesRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BytesRulesDefaultTypeInternal() {}
  union {
    BytesRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BytesRulesDefaultTypeInternal _BytesRules_default_instance_;

inline constexpr BoolRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        example_{},
        const__{false} {}

template <typename>
PROTOBUF_CONSTEXPR BoolRules::BoolRules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct BoolRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoolRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoolRulesDefaultTypeInternal() {}
  union {
    BoolRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoolRulesDefaultTypeInternal _BoolRules_default_instance_;

inline constexpr AnyRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : in_{},
        not_in_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AnyRules::AnyRules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct AnyRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnyRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnyRulesDefaultTypeInternal() {}
  union {
    AnyRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnyRulesDefaultTypeInternal _AnyRules_default_instance_;

inline constexpr Violations::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : violations_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Violations::Violations(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct ViolationsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ViolationsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ViolationsDefaultTypeInternal() {}
  union {
    Violations _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ViolationsDefaultTypeInternal _Violations_default_instance_;

inline constexpr TimestampRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        example_{},
        const__{nullptr},
        within_{nullptr},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR TimestampRules::TimestampRules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct TimestampRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimestampRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimestampRulesDefaultTypeInternal() {}
  union {
    TimestampRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimestampRulesDefaultTypeInternal _TimestampRules_default_instance_;

inline constexpr PredefinedConstraints::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : cel_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PredefinedConstraints::PredefinedConstraints(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct PredefinedConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PredefinedConstraintsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PredefinedConstraintsDefaultTypeInternal() {}
  union {
    PredefinedConstraints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PredefinedConstraintsDefaultTypeInternal _PredefinedConstraints_default_instance_;

inline constexpr MessageConstraints::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        cel_{},
        disabled_{false} {}

template <typename>
PROTOBUF_CONSTEXPR MessageConstraints::MessageConstraints(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct MessageConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageConstraintsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageConstraintsDefaultTypeInternal() {}
  union {
    MessageConstraints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageConstraintsDefaultTypeInternal _MessageConstraints_default_instance_;

inline constexpr DurationRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        in_{},
        not_in_{},
        example_{},
        const__{nullptr},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR DurationRules::DurationRules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct DurationRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DurationRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DurationRulesDefaultTypeInternal() {}
  union {
    DurationRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DurationRulesDefaultTypeInternal _DurationRules_default_instance_;

inline constexpr FieldConstraints::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        cel_{},
        required_{false},
        skipped_{false},
        ignore_empty_{false},
        ignore_{static_cast< ::buf::validate::Ignore >(0)},
        type_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR FieldConstraints::FieldConstraints(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct FieldConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FieldConstraintsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FieldConstraintsDefaultTypeInternal() {}
  union {
    FieldConstraints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FieldConstraintsDefaultTypeInternal _FieldConstraints_default_instance_;

inline constexpr MapRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        keys_{nullptr},
        values_{nullptr},
        min_pairs_{::uint64_t{0u}},
        max_pairs_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR MapRules::MapRules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct MapRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapRulesDefaultTypeInternal() {}
  union {
    MapRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapRulesDefaultTypeInternal _MapRules_default_instance_;

inline constexpr RepeatedRules::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        items_{nullptr},
        min_items_{::uint64_t{0u}},
        max_items_{::uint64_t{0u}},
        unique_{false} {}

template <typename>
PROTOBUF_CONSTEXPR RepeatedRules::RepeatedRules(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RepeatedRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepeatedRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepeatedRulesDefaultTypeInternal() {}
  union {
    RepeatedRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepeatedRulesDefaultTypeInternal _RepeatedRules_default_instance_;
}  // namespace validate
}  // namespace buf
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_buf_2fvalidate_2fvalidate_2eproto[2];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_buf_2fvalidate_2fvalidate_2eproto = nullptr;
const ::uint32_t
    TableStruct_buf_2fvalidate_2fvalidate_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::buf::validate::Constraint, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Constraint, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::Constraint, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Constraint, _impl_.message_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Constraint, _impl_.expression_),
        0,
        1,
        2,
        PROTOBUF_FIELD_OFFSET(::buf::validate::MessageConstraints, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::MessageConstraints, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::MessageConstraints, _impl_.disabled_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::MessageConstraints, _impl_.cel_),
        0,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::OneofConstraints, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::OneofConstraints, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::OneofConstraints, _impl_.required_),
        0,
        PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _internal_metadata_),
        ~0u,  // no _extensions_
        PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_.cel_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_.required_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_.ignore_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_.skipped_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_.ignore_empty_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_.type_),
        ~0u,
        0,
        3,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        1,
        2,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::buf::validate::PredefinedConstraints, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::PredefinedConstraints, _impl_.cel_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.finite_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        1,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.finite_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        1,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, _impl_._extensions_),
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, _impl_.example_),
        0,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.len_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.min_len_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.max_len_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.len_bytes_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.min_bytes_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.max_bytes_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.pattern_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.prefix_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.suffix_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.contains_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.not_contains_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.not_in_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.strict_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.well_known_),
        0,
        10,
        6,
        7,
        11,
        8,
        9,
        1,
        2,
        3,
        4,
        5,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        12,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.len_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.min_len_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.max_len_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.pattern_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.prefix_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.suffix_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.contains_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.not_in_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.well_known_),
        0,
        7,
        5,
        6,
        1,
        2,
        3,
        4,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_._extensions_),
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_.const__),
        PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_.defined_only_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_.example_),
        0,
        1,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _impl_._extensions_),
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _impl_.min_items_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _impl_.max_items_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _impl_.unique_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _impl_.items_),
        1,
        2,
        3,
        0,
        PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _impl_._extensions_),
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _impl_.min_pairs_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _impl_.max_pairs_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _impl_.keys_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _impl_.values_),
        2,
        3,
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::buf::validate::AnyRules, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::AnyRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::AnyRules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_.in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_.not_in_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _internal_metadata_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_._extensions_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_.const__),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_.within_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_.example_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_.less_than_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_.greater_than_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        1,
        ~0u,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::buf::validate::Violations, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::Violations, _impl_.violations_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, _impl_.field_path_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, _impl_.constraint_id_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, _impl_.message_),
        PROTOBUF_FIELD_OFFSET(::buf::validate::Violation, _impl_.for_key_),
        0,
        1,
        2,
        3,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 11, -1, sizeof(::buf::validate::Constraint)},
        {14, 24, -1, sizeof(::buf::validate::MessageConstraints)},
        {26, 35, -1, sizeof(::buf::validate::OneofConstraints)},
        {36, 71, -1, sizeof(::buf::validate::FieldConstraints)},
        {97, -1, -1, sizeof(::buf::validate::PredefinedConstraints)},
        {106, 125, -1, sizeof(::buf::validate::FloatRules)},
        {134, 153, -1, sizeof(::buf::validate::DoubleRules)},
        {162, 180, -1, sizeof(::buf::validate::Int32Rules)},
        {188, 206, -1, sizeof(::buf::validate::Int64Rules)},
        {214, 232, -1, sizeof(::buf::validate::UInt32Rules)},
        {240, 258, -1, sizeof(::buf::validate::UInt64Rules)},
        {266, 284, -1, sizeof(::buf::validate::SInt32Rules)},
        {292, 310, -1, sizeof(::buf::validate::SInt64Rules)},
        {318, 336, -1, sizeof(::buf::validate::Fixed32Rules)},
        {344, 362, -1, sizeof(::buf::validate::Fixed64Rules)},
        {370, 388, -1, sizeof(::buf::validate::SFixed32Rules)},
        {396, 414, -1, sizeof(::buf::validate::SFixed64Rules)},
        {422, 432, -1, sizeof(::buf::validate::BoolRules)},
        {434, 477, -1, sizeof(::buf::validate::StringRules)},
        {511, 534, -1, sizeof(::buf::validate::BytesRules)},
        {548, 561, -1, sizeof(::buf::validate::EnumRules)},
        {566, 578, -1, sizeof(::buf::validate::RepeatedRules)},
        {582, 594, -1, sizeof(::buf::validate::MapRules)},
        {598, -1, -1, sizeof(::buf::validate::AnyRules)},
        {608, 626, -1, sizeof(::buf::validate::DurationRules)},
        {634, 653, -1, sizeof(::buf::validate::TimestampRules)},
        {662, -1, -1, sizeof(::buf::validate::Violations)},
        {671, 683, -1, sizeof(::buf::validate::Violation)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::buf::validate::_Constraint_default_instance_._instance,
    &::buf::validate::_MessageConstraints_default_instance_._instance,
    &::buf::validate::_OneofConstraints_default_instance_._instance,
    &::buf::validate::_FieldConstraints_default_instance_._instance,
    &::buf::validate::_PredefinedConstraints_default_instance_._instance,
    &::buf::validate::_FloatRules_default_instance_._instance,
    &::buf::validate::_DoubleRules_default_instance_._instance,
    &::buf::validate::_Int32Rules_default_instance_._instance,
    &::buf::validate::_Int64Rules_default_instance_._instance,
    &::buf::validate::_UInt32Rules_default_instance_._instance,
    &::buf::validate::_UInt64Rules_default_instance_._instance,
    &::buf::validate::_SInt32Rules_default_instance_._instance,
    &::buf::validate::_SInt64Rules_default_instance_._instance,
    &::buf::validate::_Fixed32Rules_default_instance_._instance,
    &::buf::validate::_Fixed64Rules_default_instance_._instance,
    &::buf::validate::_SFixed32Rules_default_instance_._instance,
    &::buf::validate::_SFixed64Rules_default_instance_._instance,
    &::buf::validate::_BoolRules_default_instance_._instance,
    &::buf::validate::_StringRules_default_instance_._instance,
    &::buf::validate::_BytesRules_default_instance_._instance,
    &::buf::validate::_EnumRules_default_instance_._instance,
    &::buf::validate::_RepeatedRules_default_instance_._instance,
    &::buf::validate::_MapRules_default_instance_._instance,
    &::buf::validate::_AnyRules_default_instance_._instance,
    &::buf::validate::_DurationRules_default_instance_._instance,
    &::buf::validate::_TimestampRules_default_instance_._instance,
    &::buf::validate::_Violations_default_instance_._instance,
    &::buf::validate::_Violation_default_instance_._instance,
};
const char descriptor_table_protodef_buf_2fvalidate_2fvalidate_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\033buf/validate/validate.proto\022\014buf.valid"
    "ate\032 google/protobuf/descriptor.proto\032\036g"
    "oogle/protobuf/duration.proto\032\037google/pr"
    "otobuf/timestamp.proto\"V\n\nConstraint\022\016\n\002"
    "id\030\001 \001(\tR\002id\022\030\n\007message\030\002 \001(\tR\007message\022\036"
    "\n\nexpression\030\003 \001(\tR\nexpression\"\\\n\022Messag"
    "eConstraints\022\032\n\010disabled\030\001 \001(\010R\010disabled"
    "\022*\n\003cel\030\003 \003(\0132\030.buf.validate.ConstraintR"
    "\003cel\".\n\020OneofConstraints\022\032\n\010required\030\001 \001"
    "(\010R\010required\"\253\n\n\020FieldConstraints\022*\n\003cel"
    "\030\027 \003(\0132\030.buf.validate.ConstraintR\003cel\022\032\n"
    "\010required\030\031 \001(\010R\010required\022,\n\006ignore\030\033 \001("
    "\0162\024.buf.validate.IgnoreR\006ignore\0220\n\005float"
    "\030\001 \001(\0132\030.buf.validate.FloatRulesH\000R\005floa"
    "t\0223\n\006double\030\002 \001(\0132\031.buf.validate.DoubleR"
    "ulesH\000R\006double\0220\n\005int32\030\003 \001(\0132\030.buf.vali"
    "date.Int32RulesH\000R\005int32\0220\n\005int64\030\004 \001(\0132"
    "\030.buf.validate.Int64RulesH\000R\005int64\0223\n\006ui"
    "nt32\030\005 \001(\0132\031.buf.validate.UInt32RulesH\000R"
    "\006uint32\0223\n\006uint64\030\006 \001(\0132\031.buf.validate.U"
    "Int64RulesH\000R\006uint64\0223\n\006sint32\030\007 \001(\0132\031.b"
    "uf.validate.SInt32RulesH\000R\006sint32\0223\n\006sin"
    "t64\030\010 \001(\0132\031.buf.validate.SInt64RulesH\000R\006"
    "sint64\0226\n\007fixed32\030\t \001(\0132\032.buf.validate.F"
    "ixed32RulesH\000R\007fixed32\0226\n\007fixed64\030\n \001(\0132"
    "\032.buf.validate.Fixed64RulesH\000R\007fixed64\0229"
    "\n\010sfixed32\030\013 \001(\0132\033.buf.validate.SFixed32"
    "RulesH\000R\010sfixed32\0229\n\010sfixed64\030\014 \001(\0132\033.bu"
    "f.validate.SFixed64RulesH\000R\010sfixed64\022-\n\004"
    "bool\030\r \001(\0132\027.buf.validate.BoolRulesH\000R\004b"
    "ool\0223\n\006string\030\016 \001(\0132\031.buf.validate.Strin"
    "gRulesH\000R\006string\0220\n\005bytes\030\017 \001(\0132\030.buf.va"
    "lidate.BytesRulesH\000R\005bytes\022-\n\004enum\030\020 \001(\013"
    "2\027.buf.validate.EnumRulesH\000R\004enum\0229\n\010rep"
    "eated\030\022 \001(\0132\033.buf.validate.RepeatedRules"
    "H\000R\010repeated\022*\n\003map\030\023 \001(\0132\026.buf.validate"
    ".MapRulesH\000R\003map\022*\n\003any\030\024 \001(\0132\026.buf.vali"
    "date.AnyRulesH\000R\003any\0229\n\010duration\030\025 \001(\0132\033"
    ".buf.validate.DurationRulesH\000R\010duration\022"
    "<\n\ttimestamp\030\026 \001(\0132\034.buf.validate.Timest"
    "ampRulesH\000R\ttimestamp\022\034\n\007skipped\030\030 \001(\010B\002"
    "\030\001R\007skipped\022%\n\014ignore_empty\030\032 \001(\010B\002\030\001R\013i"
    "gnoreEmptyB\006\n\004type\"C\n\025PredefinedConstrai"
    "nts\022*\n\003cel\030\001 \003(\0132\030.buf.validate.Constrai"
    "ntR\003cel\"\352\027\n\nFloatRules\022p\n\005const\030\001 \001(\002BZ\302"
    "HW\nU\n\013float.const\032Fthis != rules.const \?"
    " \'value must equal %s\'.format([rules.con"
    "st]) : \'\'R\005const\022\243\001\n\002lt\030\002 \001(\002B\220\001\302H\214\001\n\211\001\n"
    "\010float.lt\032}!has(rules.gte) && !has(rules"
    ".gt) && (this.isNan() || this >= rules.l"
    "t)\? \'value must be less than %s\'.format("
    "[rules.lt]) : \'\'H\000R\002lt\022\264\001\n\003lte\030\003 \001(\002B\237\001\302"
    "H\233\001\n\230\001\n\tfloat.lte\032\212\001!has(rules.gte) && !"
    "has(rules.gt) && (this.isNan() || this >"
    " rules.lte)\? \'value must be less than or"
    " equal to %s\'.format([rules.lte]) : \'\'H\000"
    "R\003lte\022\363\007\n\002gt\030\004 \001(\002B\340\007\302H\334\007\n\215\001\n\010float.gt\032\200"
    "\001!has(rules.lt) && !has(rules.lte) && (t"
    "his.isNan() || this <= rules.gt)\? \'value"
    " must be greater than %s\'.format([rules."
    "gt]) : \'\'\n\303\001\n\013float.gt_lt\032\263\001has(rules.lt"
    ") && rules.lt >= rules.gt && (this.isNan"
    "() || this >= rules.lt || this <= rules."
    "gt)\? \'value must be greater than %s and "
    "less than %s\'.format([rules.gt, rules.lt"
    "]) : \'\'\n\315\001\n\025float.gt_lt_exclusive\032\263\001has("
    "rules.lt) && rules.lt < rules.gt && (thi"
    "s.isNan() || (rules.lt <= this && this <"
    "= rules.gt))\? \'value must be greater tha"
    "n %s or less than %s\'.format([rules.gt, "
    "rules.lt]) : \'\'\n\323\001\n\014float.gt_lte\032\302\001has(r"
    "ules.lte) && rules.lte >= rules.gt && (t"
    "his.isNan() || this > rules.lte || this "
    "<= rules.gt)\? \'value must be greater tha"
    "n %s and less than or equal to %s\'.forma"
    "t([rules.gt, rules.lte]) : \'\'\n\335\001\n\026float."
    "gt_lte_exclusive\032\302\001has(rules.lte) && rul"
    "es.lte < rules.gt && (this.isNan() || (r"
    "ules.lte < this && this <= rules.gt))\? \'"
    "value must be greater than %s or less th"
    "an or equal to %s\'.format([rules.gt, rul"
    "es.lte]) : \'\'H\001R\002gt\022\277\010\n\003gte\030\005 \001(\002B\252\010\302H\246\010"
    "\n\233\001\n\tfloat.gte\032\215\001!has(rules.lt) && !has("
    "rules.lte) && (this.isNan() || this < ru"
    "les.gte)\? \'value must be greater than or"
    " equal to %s\'.format([rules.gte]) : \'\'\n\322"
    "\001\n\014float.gte_lt\032\301\001has(rules.lt) && rules"
    ".lt >= rules.gte && (this.isNan() || thi"
    "s >= rules.lt || this < rules.gte)\? \'val"
    "ue must be greater than or equal to %s a"
    "nd less than %s\'.format([rules.gte, rule"
    "s.lt]) : \'\'\n\334\001\n\026float.gte_lt_exclusive\032\301"
    "\001has(rules.lt) && rules.lt < rules.gte &"
    "& (this.isNan() || (rules.lt <= this && "
    "this < rules.gte))\? \'value must be great"
    "er than or equal to %s or less than %s\'."
    "format([rules.gte, rules.lt]) : \'\'\n\342\001\n\rf"
    "loat.gte_lte\032\320\001has(rules.lte) && rules.l"
    "te >= rules.gte && (this.isNan() || this"
    " > rules.lte || this < rules.gte)\? \'valu"
    "e must be greater than or equal to %s an"
    "d less than or equal to %s\'.format([rule"
    "s.gte, rules.lte]) : \'\'\n\354\001\n\027float.gte_lt"
    "e_exclusive\032\320\001has(rules.lte) && rules.lt"
    "e < rules.gte && (this.isNan() || (rules"
    ".lte < this && this < rules.gte))\? \'valu"
    "e must be greater than or equal to %s or"
    " less than or equal to %s\'.format([rules"
    ".gte, rules.lte]) : \'\'H\001R\003gte\022y\n\002in\030\006 \003("
    "\002Bi\302Hf\nd\n\010float.in\032X!(this in dyn(rules)"
    "[\'in\']) \? \'value must be in list %s\'.for"
    "mat([dyn(rules)[\'in\']]) : \'\'R\002in\022}\n\006not_"
    "in\030\007 \003(\002Bf\302Hc\na\n\014float.not_in\032Qthis in r"
    "ules.not_in \? \'value must not be in list"
    " %s\'.format([rules.not_in]) : \'\'R\005notIn\022"
    "}\n\006finite\030\010 \001(\010Be\302Hb\n`\n\014float.finite\032Pru"
    "les.finite \? (this.isNan() || this.isInf"
    "() \? \'value must be finite\' : \'\') : \'\'R\006"
    "finite\0224\n\007example\030\t \003(\002B\032\302H\027\n\025\n\rfloat.ex"
    "ample\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_"
    "thanB\016\n\014greater_than\"\374\027\n\013DoubleRules\022q\n\005"
    "const\030\001 \001(\001B[\302HX\nV\n\014double.const\032Fthis !"
    "= rules.const \? \'value must equal %s\'.fo"
    "rmat([rules.const]) : \'\'R\005const\022\244\001\n\002lt\030\002"
    " \001(\001B\221\001\302H\215\001\n\212\001\n\tdouble.lt\032}!has(rules.gt"
    "e) && !has(rules.gt) && (this.isNan() ||"
    " this >= rules.lt)\? \'value must be less "
    "than %s\'.format([rules.lt]) : \'\'H\000R\002lt\022\265"
    "\001\n\003lte\030\003 \001(\001B\240\001\302H\234\001\n\231\001\n\ndouble.lte\032\212\001!ha"
    "s(rules.gte) && !has(rules.gt) && (this."
    "isNan() || this > rules.lte)\? \'value mus"
    "t be less than or equal to %s\'.format([r"
    "ules.lte]) : \'\'H\000R\003lte\022\370\007\n\002gt\030\004 \001(\001B\345\007\302H"
    "\341\007\n\216\001\n\tdouble.gt\032\200\001!has(rules.lt) && !ha"
    "s(rules.lte) && (this.isNan() || this <="
    " rules.gt)\? \'value must be greater than "
    "%s\'.format([rules.gt]) : \'\'\n\304\001\n\014double.g"
    "t_lt\032\263\001has(rules.lt) && rules.lt >= rule"
    "s.gt && (this.isNan() || this >= rules.l"
    "t || this <= rules.gt)\? \'value must be g"
    "reater than %s and less than %s\'.format("
    "[rules.gt, rules.lt]) : \'\'\n\316\001\n\026double.gt"
    "_lt_exclusive\032\263\001has(rules.lt) && rules.l"
    "t < rules.gt && (this.isNan() || (rules."
    "lt <= this && this <= rules.gt))\? \'value"
    " must be greater than %s or less than %s"
    "\'.format([rules.gt, rules.lt]) : \'\'\n\324\001\n\r"
    "double.gt_lte\032\302\001has(rules.lte) && rules."
    "lte >= rules.gt && (this.isNan() || this"
    " > rules.lte || this <= rules.gt)\? \'valu"
    "e must be greater than %s and less than "
    "or equal to %s\'.format([rules.gt, rules."
    "lte]) : \'\'\n\336\001\n\027double.gt_lte_exclusive\032\302"
    "\001has(rules.lte) && rules.lte < rules.gt "
    "&& (this.isNan() || (rules.lte < this &&"
    " this <= rules.gt))\? \'value must be grea"
    "ter than %s or less than or equal to %s\'"
    ".format([rules.gt, rules.lte]) : \'\'H\001R\002g"
    "t\022\304\010\n\003gte\030\005 \001(\001B\257\010\302H\253\010\n\234\001\n\ndouble.gte\032\215\001"
    "!has(rules.lt) && !has(rules.lte) && (th"
    "is.isNan() || this < rules.gte)\? \'value "
    "must be greater than or equal to %s\'.for"
    "mat([rules.gte]) : \'\'\n\323\001\n\rdouble.gte_lt\032"
    "\301\001has(rules.lt) && rules.lt >= rules.gte"
    " && (this.isNan() || this >= rules.lt ||"
    " this < rules.gte)\? \'value must be great"
    "er than or equal to %s and less than %s\'"
    ".format([rules.gte, rules.lt]) : \'\'\n\335\001\n\027"
    "double.gte_lt_exclusive\032\301\001has(rules.lt) "
    "&& rules.lt < rules.gte && (this.isNan()"
    " || (rules.lt <= this && this < rules.gt"
    "e))\? \'value must be greater than or equa"
    "l to %s or less than %s\'.format([rules.g"
    "te, rules.lt]) : \'\'\n\343\001\n\016double.gte_lte\032\320"
    "\001has(rules.lte) && rules.lte >= rules.gt"
    "e && (this.isNan() || this > rules.lte |"
    "| this < rules.gte)\? \'value must be grea"
    "ter than or equal to %s and less than or"
    " equal to %s\'.format([rules.gte, rules.l"
    "te]) : \'\'\n\355\001\n\030double.gte_lte_exclusive\032\320"
    "\001has(rules.lte) && rules.lte < rules.gte"
    " && (this.isNan() || (rules.lte < this &"
    "& this < rules.gte))\? \'value must be gre"
    "ater than or equal to %s or less than or"
    " equal to %s\'.format([rules.gte, rules.l"
    "te]) : \'\'H\001R\003gte\022z\n\002in\030\006 \003(\001Bj\302Hg\ne\n\tdou"
    "ble.in\032X!(this in dyn(rules)[\'in\']) \? \'v"
    "alue must be in list %s\'.format([dyn(rul"
    "es)[\'in\']]) : \'\'R\002in\022~\n\006not_in\030\007 \003(\001Bg\302H"
    "d\nb\n\rdouble.not_in\032Qthis in rules.not_in"
    " \? \'value must not be in list %s\'.format"
    "([rules.not_in]) : \'\'R\005notIn\022~\n\006finite\030\010"
    " \001(\010Bf\302Hc\na\n\rdouble.finite\032Prules.finite"
    " \? (this.isNan() || this.isInf() \? \'valu"
    "e must be finite\' : \'\') : \'\'R\006finite\0225\n\007"
    "example\030\t \003(\001B\033\302H\030\n\026\n\016double.example\032\004tr"
    "ueR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014g"
    "reater_than\"\224\025\n\nInt32Rules\022p\n\005const\030\001 \001("
    "\005BZ\302HW\nU\n\013int32.const\032Fthis != rules.con"
    "st \? \'value must equal %s\'.format([rules"
    ".const]) : \'\'R\005const\022\216\001\n\002lt\030\002 \001(\005B|\302Hy\nw"
    "\n\010int32.lt\032k!has(rules.gte) && !has(rule"
    "s.gt) && this >= rules.lt\? \'value must b"
    "e less than %s\'.format([rules.lt]) : \'\'H"
    "\000R\002lt\022\241\001\n\003lte\030\003 \001(\005B\214\001\302H\210\001\n\205\001\n\tint32.lte"
    "\032x!has(rules.gte) && !has(rules.gt) && t"
    "his > rules.lte\? \'value must be less tha"
    "n or equal to %s\'.format([rules.lte]) : "
    "\'\'H\000R\003lte\022\233\007\n\002gt\030\004 \001(\005B\210\007\302H\204\007\nz\n\010int32.g"
    "t\032n!has(rules.lt) && !has(rules.lte) && "
    "this <= rules.gt\? \'value must be greater"
    " than %s\'.format([rules.gt]) : \'\'\n\263\001\n\013in"
    "t32.gt_lt\032\243\001has(rules.lt) && rules.lt >="
    " rules.gt && (this >= rules.lt || this <"
    "= rules.gt)\? \'value must be greater than"
    " %s and less than %s\'.format([rules.gt, "
    "rules.lt]) : \'\'\n\273\001\n\025int32.gt_lt_exclusiv"
    "e\032\241\001has(rules.lt) && rules.lt < rules.gt"
    " && (rules.lt <= this && this <= rules.g"
    "t)\? \'value must be greater than %s or le"
    "ss than %s\'.format([rules.gt, rules.lt])"
    " : \'\'\n\303\001\n\014int32.gt_lte\032\262\001has(rules.lte) "
    "&& rules.lte >= rules.gt && (this > rule"
    "s.lte || this <= rules.gt)\? \'value must "
    "be greater than %s and less than or equa"
    "l to %s\'.format([rules.gt, rules.lte]) :"
    " \'\'\n\313\001\n\026int32.gt_lte_exclusive\032\260\001has(rul"
    "es.lte) && rules.lte < rules.gt && (rule"
    "s.lte < this && this <= rules.gt)\? \'valu"
    "e must be greater than %s or less than o"
    "r equal to %s\'.format([rules.gt, rules.l"
    "te]) : \'\'H\001R\002gt\022\350\007\n\003gte\030\005 \001(\005B\323\007\302H\317\007\n\210\001\n"
    "\tint32.gte\032{!has(rules.lt) && !has(rules"
    ".lte) && this < rules.gte\? \'value must b"
    "e greater than or equal to %s\'.format([r"
    "ules.gte]) : \'\'\n\302\001\n\014int32.gte_lt\032\261\001has(r"
    "ules.lt) && rules.lt >= rules.gte && (th"
    "is >= rules.lt || this < rules.gte)\? \'va"
    "lue must be greater than or equal to %s "
    "and less than %s\'.format([rules.gte, rul"
    "es.lt]) : \'\'\n\312\001\n\026int32.gte_lt_exclusive\032"
    "\257\001has(rules.lt) && rules.lt < rules.gte "
    "&& (rules.lt <= this && this < rules.gte"
    ")\? \'value must be greater than or equal "
    "to %s or less than %s\'.format([rules.gte"
    ", rules.lt]) : \'\'\n\322\001\n\rint32.gte_lte\032\300\001ha"
    "s(rules.lte) && rules.lte >= rules.gte &"
    "& (this > rules.lte || this < rules.gte)"
    "\? \'value must be greater than or equal t"
    "o %s and less than or equal to %s\'.forma"
    "t([rules.gte, rules.lte]) : \'\'\n\332\001\n\027int32"
    ".gte_lte_exclusive\032\276\001has(rules.lte) && r"
    "ules.lte < rules.gte && (rules.lte < thi"
    "s && this < rules.gte)\? \'value must be g"
    "reater than or equal to %s or less than "
    "or equal to %s\'.format([rules.gte, rules"
    ".lte]) : \'\'H\001R\003gte\022y\n\002in\030\006 \003(\005Bi\302Hf\nd\n\010i"
    "nt32.in\032X!(this in dyn(rules)[\'in\']) \? \'"
    "value must be in list %s\'.format([dyn(ru"
    "les)[\'in\']]) : \'\'R\002in\022}\n\006not_in\030\007 \003(\005Bf\302"
    "Hc\na\n\014int32.not_in\032Qthis in rules.not_in"
    " \? \'value must not be in list %s\'.format"
    "([rules.not_in]) : \'\'R\005notIn\0224\n\007example\030"
    "\010 \003(\005B\032\302H\027\n\025\n\rint32.example\032\004trueR\007examp"
    "le*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014greater_th"
    "an\"\224\025\n\nInt64Rules\022p\n\005const\030\001 \001(\003BZ\302HW\nU\n"
    "\013int64.const\032Fthis != rules.const \? \'val"
    "ue must equal %s\'.format([rules.const]) "
    ": \'\'R\005const\022\216\001\n\002lt\030\002 \001(\003B|\302Hy\nw\n\010int64.l"
    "t\032k!has(rules.gte) && !has(rules.gt) && "
    "this >= rules.lt\? \'value must be less th"
    "an %s\'.format([rules.lt]) : \'\'H\000R\002lt\022\241\001\n"
    "\003lte\030\003 \001(\003B\214\001\302H\210\001\n\205\001\n\tint64.lte\032x!has(ru"
    "les.gte) && !has(rules.gt) && this > rul"
    "es.lte\? \'value must be less than or equa"
    "l to %s\'.format([rules.lte]) : \'\'H\000R\003lte"
    "\022\233\007\n\002gt\030\004 \001(\003B\210\007\302H\204\007\nz\n\010int64.gt\032n!has(r"
    "ules.lt) && !has(rules.lte) && this <= r"
    "ules.gt\? \'value must be greater than %s\'"
    ".format([rules.gt]) : \'\'\n\263\001\n\013int64.gt_lt"
    "\032\243\001has(rules.lt) && rules.lt >= rules.gt"
    " && (this >= rules.lt || this <= rules.g"
    "t)\? \'value must be greater than %s and l"
    "ess than %s\'.format([rules.gt, rules.lt]"
    ") : \'\'\n\273\001\n\025int64.gt_lt_exclusive\032\241\001has(r"
    "ules.lt) && rules.lt < rules.gt && (rule"
    "s.lt <= this && this <= rules.gt)\? \'valu"
    "e must be greater than %s or less than %"
    "s\'.format([rules.gt, rules.lt]) : \'\'\n\303\001\n"
    "\014int64.gt_lte\032\262\001has(rules.lte) && rules."
    "lte >= rules.gt && (this > rules.lte || "
    "this <= rules.gt)\? \'value must be greate"
    "r than %s and less than or equal to %s\'."
    "format([rules.gt, rules.lte]) : \'\'\n\313\001\n\026i"
    "nt64.gt_lte_exclusive\032\260\001has(rules.lte) &"
    "& rules.lte < rules.gt && (rules.lte < t"
    "his && this <= rules.gt)\? \'value must be"
    " greater than %s or less than or equal t"
    "o %s\'.format([rules.gt, rules.lte]) : \'\'"
    "H\001R\002gt\022\350\007\n\003gte\030\005 \001(\003B\323\007\302H\317\007\n\210\001\n\tint64.gt"
    "e\032{!has(rules.lt) && !has(rules.lte) && "
    "this < rules.gte\? \'value must be greater"
    " than or equal to %s\'.format([rules.gte]"
    ") : \'\'\n\302\001\n\014int64.gte_lt\032\261\001has(rules.lt) "
    "&& rules.lt >= rules.gte && (this >= rul"
    "es.lt || this < rules.gte)\? \'value must "
    "be greater than or equal to %s and less "
    "than %s\'.format([rules.gte, rules.lt]) :"
    " \'\'\n\312\001\n\026int64.gte_lt_exclusive\032\257\001has(rul"
    "es.lt) && rules.lt < rules.gte && (rules"
    ".lt <= this && this < rules.gte)\? \'value"
    " must be greater than or equal to %s or "
    "less than %s\'.format([rules.gte, rules.l"
    "t]) : \'\'\n\322\001\n\rint64.gte_lte\032\300\001has(rules.l"
    "te) && rules.lte >= rules.gte && (this >"
    " rules.lte || this < rules.gte)\? \'value "
    "must be greater than or equal to %s and "
    "less than or equal to %s\'.format([rules."
    "gte, rules.lte]) : \'\'\n\332\001\n\027int64.gte_lte_"
    "exclusive\032\276\001has(rules.lte) && rules.lte "
    "< rules.gte && (rules.lte < this && this"
    " < rules.gte)\? \'value must be greater th"
    "an or equal to %s or less than or equal "
    "to %s\'.format([rules.gte, rules.lte]) : "
    "\'\'H\001R\003gte\022y\n\002in\030\006 \003(\003Bi\302Hf\nd\n\010int64.in\032X"
    "!(this in dyn(rules)[\'in\']) \? \'value mus"
    "t be in list %s\'.format([dyn(rules)[\'in\'"
    "]]) : \'\'R\002in\022}\n\006not_in\030\007 \003(\003Bf\302Hc\na\n\014int"
    "64.not_in\032Qthis in rules.not_in \? \'value"
    " must not be in list %s\'.format([rules.n"
    "ot_in]) : \'\'R\005notIn\0224\n\007example\030\t \003(\003B\032\302H"
    "\027\n\025\n\rint64.example\032\004trueR\007example*\t\010\350\007\020\200"
    "\200\200\200\002B\013\n\tless_thanB\016\n\014greater_than\"\245\025\n\013UI"
    "nt32Rules\022q\n\005const\030\001 \001(\rB[\302HX\nV\n\014uint32."
    "const\032Fthis != rules.const \? \'value must"
    " equal %s\'.format([rules.const]) : \'\'R\005c"
    "onst\022\217\001\n\002lt\030\002 \001(\rB}\302Hz\nx\n\tuint32.lt\032k!ha"
    "s(rules.gte) && !has(rules.gt) && this >"
    "= rules.lt\? \'value must be less than %s\'"
    ".format([rules.lt]) : \'\'H\000R\002lt\022\242\001\n\003lte\030\003"
    " \001(\rB\215\001\302H\211\001\n\206\001\n\nuint32.lte\032x!has(rules.g"
    "te) && !has(rules.gt) && this > rules.lt"
    "e\? \'value must be less than or equal to "
    "%s\'.format([rules.lte]) : \'\'H\000R\003lte\022\240\007\n\002"
    "gt\030\004 \001(\rB\215\007\302H\211\007\n{\n\tuint32.gt\032n!has(rules"
    ".lt) && !has(rules.lte) && this <= rules"
    ".gt\? \'value must be greater than %s\'.for"
    "mat([rules.gt]) : \'\'\n\264\001\n\014uint32.gt_lt\032\243\001"
    "has(rules.lt) && rules.lt >= rules.gt &&"
    " (this >= rules.lt || this <= rules.gt)\?"
    " \'value must be greater than %s and less"
    " than %s\'.format([rules.gt, rules.lt]) :"
    " \'\'\n\274\001\n\026uint32.gt_lt_exclusive\032\241\001has(rul"
    "es.lt) && rules.lt < rules.gt && (rules."
    "lt <= this && this <= rules.gt)\? \'value "
    "must be greater than %s or less than %s\'"
    ".format([rules.gt, rules.lt]) : \'\'\n\304\001\n\ru"
    "int32.gt_lte\032\262\001has(rules.lte) && rules.l"
    "te >= rules.gt && (this > rules.lte || t"
    "his <= rules.gt)\? \'value must be greater"
    " than %s and less than or equal to %s\'.f"
    "ormat([rules.gt, rules.lte]) : \'\'\n\314\001\n\027ui"
    "nt32.gt_lte_exclusive\032\260\001has(rules.lte) &"
    "& rules.lte < rules.gt && (rules.lte < t"
    "his && this <= rules.gt)\? \'value must be"
    " greater than %s or less than or equal t"
    "o %s\'.format([rules.gt, rules.lte]) : \'\'"
    "H\001R\002gt\022\355\007\n\003gte\030\005 \001(\rB\330\007\302H\324\007\n\211\001\n\nuint32.g"
    "te\032{!has(rules.lt) && !has(rules.lte) &&"
    " this < rules.gte\? \'value must be greate"
    "r than or equal to %s\'.format([rules.gte"
    "]) : \'\'\n\303\001\n\ruint32.gte_lt\032\261\001has(rules.lt"
    ") && rules.lt >= rules.gte && (this >= r"
    "ules.lt || this < rules.gte)\? \'value mus"
    "t be greater than or equal to %s and les"
    "s than %s\'.format([rules.gte, rules.lt])"
    " : \'\'\n\313\001\n\027uint32.gte_lt_exclusive\032\257\001has("
    "rules.lt) && rules.lt < rules.gte && (ru"
    "les.lt <= this && this < rules.gte)\? \'va"
    "lue must be greater than or equal to %s "
    "or less than %s\'.format([rules.gte, rule"
    "s.lt]) : \'\'\n\323\001\n\016uint32.gte_lte\032\300\001has(rul"
    "es.lte) && rules.lte >= rules.gte && (th"
    "is > rules.lte || this < rules.gte)\? \'va"
    "lue must be greater than or equal to %s "
    "and less than or equal to %s\'.format([ru"
    "les.gte, rules.lte]) : \'\'\n\333\001\n\030uint32.gte"
    "_lte_exclusive\032\276\001has(rules.lte) && rules"
    ".lte < rules.gte && (rules.lte < this &&"
    " this < rules.gte)\? \'value must be great"
    "er than or equal to %s or less than or e"
    "qual to %s\'.format([rules.gte, rules.lte"
    "]) : \'\'H\001R\003gte\022z\n\002in\030\006 \003(\rBj\302Hg\ne\n\tuint3"
    "2.in\032X!(this in dyn(rules)[\'in\']) \? \'val"
    "ue must be in list %s\'.format([dyn(rules"
    ")[\'in\']]) : \'\'R\002in\022~\n\006not_in\030\007 \003(\rBg\302Hd\n"
    "b\n\ruint32.not_in\032Qthis in rules.not_in \?"
    " \'value must not be in list %s\'.format(["
    "rules.not_in]) : \'\'R\005notIn\0225\n\007example\030\010 "
    "\003(\rB\033\302H\030\n\026\n\016uint32.example\032\004trueR\007exampl"
    "e*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014greater_tha"
    "n\"\245\025\n\013UInt64Rules\022q\n\005const\030\001 \001(\004B[\302HX\nV\n"
    "\014uint64.const\032Fthis != rules.const \? \'va"
    "lue must equal %s\'.format([rules.const])"
    " : \'\'R\005const\022\217\001\n\002lt\030\002 \001(\004B}\302Hz\nx\n\tuint64"
    ".lt\032k!has(rules.gte) && !has(rules.gt) &"
    "& this >= rules.lt\? \'value must be less "
    "than %s\'.format([rules.lt]) : \'\'H\000R\002lt\022\242"
    "\001\n\003lte\030\003 \001(\004B\215\001\302H\211\001\n\206\001\n\nuint64.lte\032x!has"
    "(rules.gte) && !has(rules.gt) && this > "
    "rules.lte\? \'value must be less than or e"
    "qual to %s\'.format([rules.lte]) : \'\'H\000R\003"
    "lte\022\240\007\n\002gt\030\004 \001(\004B\215\007\302H\211\007\n{\n\tuint64.gt\032n!h"
    "as(rules.lt) && !has(rules.lte) && this "
    "<= rules.gt\? \'value must be greater than"
    " %s\'.format([rules.gt]) : \'\'\n\264\001\n\014uint64."
    "gt_lt\032\243\001has(rules.lt) && rules.lt >= rul"
    "es.gt && (this >= rules.lt || this <= ru"
    "les.gt)\? \'value must be greater than %s "
    "and less than %s\'.format([rules.gt, rule"
    "s.lt]) : \'\'\n\274\001\n\026uint64.gt_lt_exclusive\032\241"
    "\001has(rules.lt) && rules.lt < rules.gt &&"
    " (rules.lt <= this && this <= rules.gt)\?"
    " \'value must be greater than %s or less "
    "than %s\'.format([rules.gt, rules.lt]) : "
    "\'\'\n\304\001\n\ruint64.gt_lte\032\262\001has(rules.lte) &&"
    " rules.lte >= rules.gt && (this > rules."
    "lte || this <= rules.gt)\? \'value must be"
    " greater than %s and less than or equal "
    "to %s\'.format([rules.gt, rules.lte]) : \'"
    "\'\n\314\001\n\027uint64.gt_lte_exclusive\032\260\001has(rule"
    "s.lte) && rules.lte < rules.gt && (rules"
    ".lte < this && this <= rules.gt)\? \'value"
    " must be greater than %s or less than or"
    " equal to %s\'.format([rules.gt, rules.lt"
    "e]) : \'\'H\001R\002gt\022\355\007\n\003gte\030\005 \001(\004B\330\007\302H\324\007\n\211\001\n\n"
    "uint64.gte\032{!has(rules.lt) && !has(rules"
    ".lte) && this < rules.gte\? \'value must b"
    "e greater than or equal to %s\'.format([r"
    "ules.gte]) : \'\'\n\303\001\n\ruint64.gte_lt\032\261\001has("
    "rules.lt) && rules.lt >= rules.gte && (t"
    "his >= rules.lt || this < rules.gte)\? \'v"
    "alue must be greater than or equal to %s"
    " and less than %s\'.format([rules.gte, ru"
    "les.lt]) : \'\'\n\313\001\n\027uint64.gte_lt_exclusiv"
    "e\032\257\001has(rules.lt) && rules.lt < rules.gt"
    "e && (rules.lt <= this && this < rules.g"
    "te)\? \'value must be greater than or equa"
    "l to %s or less than %s\'.format([rules.g"
    "te, rules.lt]) : \'\'\n\323\001\n\016uint64.gte_lte\032\300"
    "\001has(rules.lte) && rules.lte >= rules.gt"
    "e && (this > rules.lte || this < rules.g"
    "te)\? \'value must be greater than or equa"
    "l to %s and less than or equal to %s\'.fo"
    "rmat([rules.gte, rules.lte]) : \'\'\n\333\001\n\030ui"
    "nt64.gte_lte_exclusive\032\276\001has(rules.lte) "
    "&& rules.lte < rules.gte && (rules.lte <"
    " this && this < rules.gte)\? \'value must "
    "be greater than or equal to %s or less t"
    "han or equal to %s\'.format([rules.gte, r"
    "ules.lte]) : \'\'H\001R\003gte\022z\n\002in\030\006 \003(\004Bj\302Hg\n"
    "e\n\tuint64.in\032X!(this in dyn(rules)[\'in\']"
    ") \? \'value must be in list %s\'.format([d"
    "yn(rules)[\'in\']]) : \'\'R\002in\022~\n\006not_in\030\007 \003"
    "(\004Bg\302Hd\nb\n\ruint64.not_in\032Qthis in rules."
    "not_in \? \'value must not be in list %s\'."
    "format([rules.not_in]) : \'\'R\005notIn\0225\n\007ex"
    "ample\030\010 \003(\004B\033\302H\030\n\026\n\016uint64.example\032\004true"
    "R\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014gre"
    "ater_than\"\245\025\n\013SInt32Rules\022q\n\005const\030\001 \001(\021"
    "B[\302HX\nV\n\014sint32.const\032Fthis != rules.con"
    "st \? \'value must equal %s\'.format([rules"
    ".const]) : \'\'R\005const\022\217\001\n\002lt\030\002 \001(\021B}\302Hz\nx"
    "\n\tsint32.lt\032k!has(rules.gte) && !has(rul"
    "es.gt) && this >= rules.lt\? \'value must "
    "be less than %s\'.format([rules.lt]) : \'\'"
    "H\000R\002lt\022\242\001\n\003lte\030\003 \001(\021B\215\001\302H\211\001\n\206\001\n\nsint32.l"
    "te\032x!has(rules.gte) && !has(rules.gt) &&"
    " this > rules.lte\? \'value must be less t"
    "han or equal to %s\'.format([rules.lte]) "
    ": \'\'H\000R\003lte\022\240\007\n\002gt\030\004 \001(\021B\215\007\302H\211\007\n{\n\tsint3"
    "2.gt\032n!has(rules.lt) && !has(rules.lte) "
    "&& this <= rules.gt\? \'value must be grea"
    "ter than %s\'.format([rules.gt]) : \'\'\n\264\001\n"
    "\014sint32.gt_lt\032\243\001has(rules.lt) && rules.l"
    "t >= rules.gt && (this >= rules.lt || th"
    "is <= rules.gt)\? \'value must be greater "
    "than %s and less than %s\'.format([rules."
    "gt, rules.lt]) : \'\'\n\274\001\n\026sint32.gt_lt_exc"
    "lusive\032\241\001has(rules.lt) && rules.lt < rul"
    "es.gt && (rules.lt <= this && this <= ru"
    "les.gt)\? \'value must be greater than %s "
    "or less than %s\'.format([rules.gt, rules"
    ".lt]) : \'\'\n\304\001\n\rsint32.gt_lte\032\262\001has(rules"
    ".lte) && rules.lte >= rules.gt && (this "
    "> rules.lte || this <= rules.gt)\? \'value"
    " must be greater than %s and less than o"
    "r equal to %s\'.format([rules.gt, rules.l"
    "te]) : \'\'\n\314\001\n\027sint32.gt_lte_exclusive\032\260\001"
    "has(rules.lte) && rules.lte < rules.gt &"
    "& (rules.lte < this && this <= rules.gt)"
    "\? \'value must be greater than %s or less"
    " than or equal to %s\'.format([rules.gt, "
    "rules.lte]) : \'\'H\001R\002gt\022\355\007\n\003gte\030\005 \001(\021B\330\007\302"
    "H\324\007\n\211\001\n\nsint32.gte\032{!has(rules.lt) && !h"
    "as(rules.lte) && this < rules.gte\? \'valu"
    "e must be greater than or equal to %s\'.f"
    "ormat([rules.gte]) : \'\'\n\303\001\n\rsint32.gte_l"
    "t\032\261\001has(rules.lt) && rules.lt >= rules.g"
    "te && (this >= rules.lt || this < rules."
    "gte)\? \'value must be greater than or equ"
    "al to %s and less than %s\'.format([rules"
    ".gte, rules.lt]) : \'\'\n\313\001\n\027sint32.gte_lt_"
    "exclusive\032\257\001has(rules.lt) && rules.lt < "
    "rules.gte && (rules.lt <= this && this <"
    " rules.gte)\? \'value must be greater than"
    " or equal to %s or less than %s\'.format("
    "[rules.gte, rules.lt]) : \'\'\n\323\001\n\016sint32.g"
    "te_lte\032\300\001has(rules.lte) && rules.lte >= "
    "rules.gte && (this > rules.lte || this <"
    " rules.gte)\? \'value must be greater than"
    " or equal to %s and less than or equal t"
    "o %s\'.format([rules.gte, rules.lte]) : \'"
    "\'\n\333\001\n\030sint32.gte_lte_exclusive\032\276\001has(rul"
    "es.lte) && rules.lte < rules.gte && (rul"
    "es.lte < this && this < rules.gte)\? \'val"
    "ue must be greater than or equal to %s o"
    "r less than or equal to %s\'.format([rule"
    "s.gte, rules.lte]) : \'\'H\001R\003gte\022z\n\002in\030\006 \003"
    "(\021Bj\302Hg\ne\n\tsint32.in\032X!(this in dyn(rule"
    "s)[\'in\']) \? \'value must be in list %s\'.f"
    "ormat([dyn(rules)[\'in\']]) : \'\'R\002in\022~\n\006no"
    "t_in\030\007 \003(\021Bg\302Hd\nb\n\rsint32.not_in\032Qthis i"
    "n rules.not_in \? \'value must not be in l"
    "ist %s\'.format([rules.not_in]) : \'\'R\005not"
    "In\0225\n\007example\030\010 \003(\021B\033\302H\030\n\026\n\016sint32.examp"
    "le\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_tha"
    "nB\016\n\014greater_than\"\245\025\n\013SInt64Rules\022q\n\005con"
    "st\030\001 \001(\022B[\302HX\nV\n\014sint64.const\032Fthis != r"
    "ules.const \? \'value must equal %s\'.forma"
    "t([rules.const]) : \'\'R\005const\022\217\001\n\002lt\030\002 \001("
    "\022B}\302Hz\nx\n\tsint64.lt\032k!has(rules.gte) && "
    "!has(rules.gt) && this >= rules.lt\? \'val"
    "ue must be less than %s\'.format([rules.l"
    "t]) : \'\'H\000R\002lt\022\242\001\n\003lte\030\003 \001(\022B\215\001\302H\211\001\n\206\001\n\n"
    "sint64.lte\032x!has(rules.gte) && !has(rule"
    "s.gt) && this > rules.lte\? \'value must b"
    "e less than or equal to %s\'.format([rule"
    "s.lte]) : \'\'H\000R\003lte\022\240\007\n\002gt\030\004 \001(\022B\215\007\302H\211\007\n"
    "{\n\tsint64.gt\032n!has(rules.lt) && !has(rul"
    "es.lte) && this <= rules.gt\? \'value must"
    " be greater than %s\'.format([rules.gt]) "
    ": \'\'\n\264\001\n\014sint64.gt_lt\032\243\001has(rules.lt) &&"
    " rules.lt >= rules.gt && (this >= rules."
    "lt || this <= rules.gt)\? \'value must be "
    "greater than %s and less than %s\'.format"
    "([rules.gt, rules.lt]) : \'\'\n\274\001\n\026sint64.g"
    "t_lt_exclusive\032\241\001has(rules.lt) && rules."
    "lt < rules.gt && (rules.lt <= this && th"
    "is <= rules.gt)\? \'value must be greater "
    "than %s or less than %s\'.format([rules.g"
    "t, rules.lt]) : \'\'\n\304\001\n\rsint64.gt_lte\032\262\001h"
    "as(rules.lte) && rules.lte >= rules.gt &"
    "& (this > rules.lte || this <= rules.gt)"
    "\? \'value must be greater than %s and les"
    "s than or equal to %s\'.format([rules.gt,"
    " rules.lte]) : \'\'\n\314\001\n\027sint64.gt_lte_excl"
    "usive\032\260\001has(rules.lte) && rules.lte < ru"
    "les.gt && (rules.lte < this && this <= r"
    "ules.gt)\? \'value must be greater than %s"
    " or less than or equal to %s\'.format([ru"
    "les.gt, rules.lte]) : \'\'H\001R\002gt\022\355\007\n\003gte\030\005"
    " \001(\022B\330\007\302H\324\007\n\211\001\n\nsint64.gte\032{!has(rules.l"
    "t) && !has(rules.lte) && this < rules.gt"
    "e\? \'value must be greater than or equal "
    "to %s\'.format([rules.gte]) : \'\'\n\303\001\n\rsint"
    "64.gte_lt\032\261\001has(rules.lt) && rules.lt >="
    " rules.gte && (this >= rules.lt || this "
    "< rules.gte)\? \'value must be greater tha"
    "n or equal to %s and less than %s\'.forma"
    "t([rules.gte, rules.lt]) : \'\'\n\313\001\n\027sint64"
    ".gte_lt_exclusive\032\257\001has(rules.lt) && rul"
    "es.lt < rules.gte && (rules.lt <= this &"
    "& this < rules.gte)\? \'value must be grea"
    "ter than or equal to %s or less than %s\'"
    ".format([rules.gte, rules.lt]) : \'\'\n\323\001\n\016"
    "sint64.gte_lte\032\300\001has(rules.lte) && rules"
    ".lte >= rules.gte && (this > rules.lte |"
    "| this < rules.gte)\? \'value must be grea"
    "ter than or equal to %s and less than or"
    " equal to %s\'.format([rules.gte, rules.l"
    "te]) : \'\'\n\333\001\n\030sint64.gte_lte_exclusive\032\276"
    "\001has(rules.lte) && rules.lte < rules.gte"
    " && (rules.lte < this && this < rules.gt"
    "e)\? \'value must be greater than or equal"
    " to %s or less than or equal to %s\'.form"
    "at([rules.gte, rules.lte]) : \'\'H\001R\003gte\022z"
    "\n\002in\030\006 \003(\022Bj\302Hg\ne\n\tsint64.in\032X!(this in "
    "dyn(rules)[\'in\']) \? \'value must be in li"
    "st %s\'.format([dyn(rules)[\'in\']]) : \'\'R\002"
    "in\022~\n\006not_in\030\007 \003(\022Bg\302Hd\nb\n\rsint64.not_in"
    "\032Qthis in rules.not_in \? \'value must not"
    " be in list %s\'.format([rules.not_in]) :"
    " \'\'R\005notIn\0225\n\007example\030\010 \003(\022B\033\302H\030\n\026\n\016sint"
    "64.example\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\t"
    "less_thanB\016\n\014greater_than\"\266\025\n\014Fixed32Rul"
    "es\022r\n\005const\030\001 \001(\007B\\\302HY\nW\n\rfixed32.const\032"
    "Fthis != rules.const \? \'value must equal"
    " %s\'.format([rules.const]) : \'\'R\005const\022\220"
    "\001\n\002lt\030\002 \001(\007B~\302H{\ny\n\nfixed32.lt\032k!has(rul"
    "es.gte) && !has(rules.gt) && this >= rul"
    "es.lt\? \'value must be less than %s\'.form"
    "at([rules.lt]) : \'\'H\000R\002lt\022\243\001\n\003lte\030\003 \001(\007B"
    "\216\001\302H\212\001\n\207\001\n\013fixed32.lte\032x!has(rules.gte) "
    "&& !has(rules.gt) && this > rules.lte\? \'"
    "value must be less than or equal to %s\'."
    "format([rules.lte]) : \'\'H\000R\003lte\022\245\007\n\002gt\030\004"
    " \001(\007B\222\007\302H\216\007\n|\n\nfixed32.gt\032n!has(rules.lt"
    ") && !has(rules.lte) && this <= rules.gt"
    "\? \'value must be greater than %s\'.format"
    "([rules.gt]) : \'\'\n\265\001\n\rfixed32.gt_lt\032\243\001ha"
    "s(rules.lt) && rules.lt >= rules.gt && ("
    "this >= rules.lt || this <= rules.gt)\? \'"
    "value must be greater than %s and less t"
    "han %s\'.format([rules.gt, rules.lt]) : \'"
    "\'\n\275\001\n\027fixed32.gt_lt_exclusive\032\241\001has(rule"
    "s.lt) && rules.lt < rules.gt && (rules.l"
    "t <= this && this <= rules.gt)\? \'value m"
    "ust be greater than %s or less than %s\'."
    "format([rules.gt, rules.lt]) : \'\'\n\305\001\n\016fi"
    "xed32.gt_lte\032\262\001has(rules.lte) && rules.l"
    "te >= rules.gt && (this > rules.lte || t"
    "his <= rules.gt)\? \'value must be greater"
    " than %s and less than or equal to %s\'.f"
    "ormat([rules.gt, rules.lte]) : \'\'\n\315\001\n\030fi"
    "xed32.gt_lte_exclusive\032\260\001has(rules.lte) "
    "&& rules.lte < rules.gt && (rules.lte < "
    "this && this <= rules.gt)\? \'value must b"
    "e greater than %s or less than or equal "
    "to %s\'.format([rules.gt, rules.lte]) : \'"
    "\'H\001R\002gt\022\362\007\n\003gte\030\005 \001(\007B\335\007\302H\331\007\n\212\001\n\013fixed32"
    ".gte\032{!has(rules.lt) && !has(rules.lte) "
    "&& this < rules.gte\? \'value must be grea"
    "ter than or equal to %s\'.format([rules.g"
    "te]) : \'\'\n\304\001\n\016fixed32.gte_lt\032\261\001has(rules"
    ".lt) && rules.lt >= rules.gte && (this >"
    "= rules.lt || this < rules.gte)\? \'value "
    "must be greater than or equal to %s and "
    "less than %s\'.format([rules.gte, rules.l"
    "t]) : \'\'\n\314\001\n\030fixed32.gte_lt_exclusive\032\257\001"
    "has(rules.lt) && rules.lt < rules.gte &&"
    " (rules.lt <= this && this < rules.gte)\?"
    " \'value must be greater than or equal to"
    " %s or less than %s\'.format([rules.gte, "
    "rules.lt]) : \'\'\n\324\001\n\017fixed32.gte_lte\032\300\001ha"
    "s(rules.lte) && rules.lte >= rules.gte &"
    "& (this > rules.lte || this < rules.gte)"
    "\? \'value must be greater than or equal t"
    "o %s and less than or equal to %s\'.forma"
    "t([rules.gte, rules.lte]) : \'\'\n\334\001\n\031fixed"
    "32.gte_lte_exclusive\032\276\001has(rules.lte) &&"
    " rules.lte < rules.gte && (rules.lte < t"
    "his && this < rules.gte)\? \'value must be"
    " greater than or equal to %s or less tha"
    "n or equal to %s\'.format([rules.gte, rul"
    "es.lte]) : \'\'H\001R\003gte\022{\n\002in\030\006 \003(\007Bk\302Hh\nf\n"
    "\nfixed32.in\032X!(this in dyn(rules)[\'in\'])"
    " \? \'value must be in list %s\'.format([dy"
    "n(rules)[\'in\']]) : \'\'R\002in\022\177\n\006not_in\030\007 \003("
    "\007Bh\302He\nc\n\016fixed32.not_in\032Qthis in rules."
    "not_in \? \'value must not be in list %s\'."
    "format([rules.not_in]) : \'\'R\005notIn\0226\n\007ex"
    "ample\030\010 \003(\007B\034\302H\031\n\027\n\017fixed32.example\032\004tru"
    "eR\007example*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014gr"
    "eater_than\"\266\025\n\014Fixed64Rules\022r\n\005const\030\001 \001"
    "(\006B\\\302HY\nW\n\rfixed64.const\032Fthis != rules."
    "const \? \'value must equal %s\'.format([ru"
    "les.const]) : \'\'R\005const\022\220\001\n\002lt\030\002 \001(\006B~\302H"
    "{\ny\n\nfixed64.lt\032k!has(rules.gte) && !has"
    "(rules.gt) && this >= rules.lt\? \'value m"
    "ust be less than %s\'.format([rules.lt]) "
    ": \'\'H\000R\002lt\022\243\001\n\003lte\030\003 \001(\006B\216\001\302H\212\001\n\207\001\n\013fixe"
    "d64.lte\032x!has(rules.gte) && !has(rules.g"
    "t) && this > rules.lte\? \'value must be l"
    "ess than or equal to %s\'.format([rules.l"
    "te]) : \'\'H\000R\003lte\022\245\007\n\002gt\030\004 \001(\006B\222\007\302H\216\007\n|\n\n"
    "fixed64.gt\032n!has(rules.lt) && !has(rules"
    ".lte) && this <= rules.gt\? \'value must b"
    "e greater than %s\'.format([rules.gt]) : "
    "\'\'\n\265\001\n\rfixed64.gt_lt\032\243\001has(rules.lt) && "
    "rules.lt >= rules.gt && (this >= rules.l"
    "t || this <= rules.gt)\? \'value must be g"
    "reater than %s and less than %s\'.format("
    "[rules.gt, rules.lt]) : \'\'\n\275\001\n\027fixed64.g"
    "t_lt_exclusive\032\241\001has(rules.lt) && rules."
    "lt < rules.gt && (rules.lt <= this && th"
    "is <= rules.gt)\? \'value must be greater "
    "than %s or less than %s\'.format([rules.g"
    "t, rules.lt]) : \'\'\n\305\001\n\016fixed64.gt_lte\032\262\001"
    "has(rules.lte) && rules.lte >= rules.gt "
    "&& (this > rules.lte || this <= rules.gt"
    ")\? \'value must be greater than %s and le"
    "ss than or equal to %s\'.format([rules.gt"
    ", rules.lte]) : \'\'\n\315\001\n\030fixed64.gt_lte_ex"
    "clusive\032\260\001has(rules.lte) && rules.lte < "
    "rules.gt && (rules.lte < this && this <="
    " rules.gt)\? \'value must be greater than "
    "%s or less than or equal to %s\'.format(["
    "rules.gt, rules.lte]) : \'\'H\001R\002gt\022\362\007\n\003gte"
    "\030\005 \001(\006B\335\007\302H\331\007\n\212\001\n\013fixed64.gte\032{!has(rule"
    "s.lt) && !has(rules.lte) && this < rules"
    ".gte\? \'value must be greater than or equ"
    "al to %s\'.format([rules.gte]) : \'\'\n\304\001\n\016f"
    "ixed64.gte_lt\032\261\001has(rules.lt) && rules.l"
    "t >= rules.gte && (this >= rules.lt || t"
    "his < rules.gte)\? \'value must be greater"
    " than or equal to %s and less than %s\'.f"
    "ormat([rules.gte, rules.lt]) : \'\'\n\314\001\n\030fi"
    "xed64.gte_lt_exclusive\032\257\001has(rules.lt) &"
    "& rules.lt < rules.gte && (rules.lt <= t"
    "his && this < rules.gte)\? \'value must be"
    " greater than or equal to %s or less tha"
    "n %s\'.format([rules.gte, rules.lt]) : \'\'"
    "\n\324\001\n\017fixed64.gte_lte\032\300\001has(rules.lte) &&"
    " rules.lte >= rules.gte && (this > rules"
    ".lte || this < rules.gte)\? \'value must b"
    "e greater than or equal to %s and less t"
    "han or equal to %s\'.format([rules.gte, r"
    "ules.lte]) : \'\'\n\334\001\n\031fixed64.gte_lte_excl"
    "usive\032\276\001has(rules.lte) && rules.lte < ru"
    "les.gte && (rules.lte < this && this < r"
    "ules.gte)\? \'value must be greater than o"
    "r equal to %s or less than or equal to %"
    "s\'.format([rules.gte, rules.lte]) : \'\'H\001"
    "R\003gte\022{\n\002in\030\006 \003(\006Bk\302Hh\nf\n\nfixed64.in\032X!("
    "this in dyn(rules)[\'in\']) \? \'value must "
    "be in list %s\'.format([dyn(rules)[\'in\']]"
    ") : \'\'R\002in\022\177\n\006not_in\030\007 \003(\006Bh\302He\nc\n\016fixed"
    "64.not_in\032Qthis in rules.not_in \? \'value"
    " must not be in list %s\'.format([rules.n"
    "ot_in]) : \'\'R\005notIn\0226\n\007example\030\010 \003(\006B\034\302H"
    "\031\n\027\n\017fixed64.example\032\004trueR\007example*\t\010\350\007"
    "\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014greater_than\"\310\025\n\r"
    "SFixed32Rules\022s\n\005const\030\001 \001(\017B]\302HZ\nX\n\016sfi"
    "xed32.const\032Fthis != rules.const \? \'valu"
    "e must equal %s\'.format([rules.const]) :"
    " \'\'R\005const\022\221\001\n\002lt\030\002 \001(\017B\177\302H|\nz\n\013sfixed32"
    ".lt\032k!has(rules.gte) && !has(rules.gt) &"
    "& this >= rules.lt\? \'value must be less "
    "than %s\'.format([rules.lt]) : \'\'H\000R\002lt\022\244"
    "\001\n\003lte\030\003 \001(\017B\217\001\302H\213\001\n\210\001\n\014sfixed32.lte\032x!h"
    "as(rules.gte) && !has(rules.gt) && this "
    "> rules.lte\? \'value must be less than or"
    " equal to %s\'.format([rules.lte]) : \'\'H\000"
    "R\003lte\022\252\007\n\002gt\030\004 \001(\017B\227\007\302H\223\007\n}\n\013sfixed32.gt"
    "\032n!has(rules.lt) && !has(rules.lte) && t"
    "his <= rules.gt\? \'value must be greater "
    "than %s\'.format([rules.gt]) : \'\'\n\266\001\n\016sfi"
    "xed32.gt_lt\032\243\001has(rules.lt) && rules.lt "
    ">= rules.gt && (this >= rules.lt || this"
    " <= rules.gt)\? \'value must be greater th"
    "an %s and less than %s\'.format([rules.gt"
    ", rules.lt]) : \'\'\n\276\001\n\030sfixed32.gt_lt_exc"
    "lusive\032\241\001has(rules.lt) && rules.lt < rul"
    "es.gt && (rules.lt <= this && this <= ru"
    "les.gt)\? \'value must be greater than %s "
    "or less than %s\'.format([rules.gt, rules"
    ".lt]) : \'\'\n\306\001\n\017sfixed32.gt_lte\032\262\001has(rul"
    "es.lte) && rules.lte >= rules.gt && (thi"
    "s > rules.lte || this <= rules.gt)\? \'val"
    "ue must be greater than %s and less than"
    " or equal to %s\'.format([rules.gt, rules"
    ".lte]) : \'\'\n\316\001\n\031sfixed32.gt_lte_exclusiv"
    "e\032\260\001has(rules.lte) && rules.lte < rules."
    "gt && (rules.lte < this && this <= rules"
    ".gt)\? \'value must be greater than %s or "
    "less than or equal to %s\'.format([rules."
    "gt, rules.lte]) : \'\'H\001R\002gt\022\367\007\n\003gte\030\005 \001(\017"
    "B\342\007\302H\336\007\n\213\001\n\014sfixed32.gte\032{!has(rules.lt)"
    " && !has(rules.lte) && this < rules.gte\?"
    " \'value must be greater than or equal to"
    " %s\'.format([rules.gte]) : \'\'\n\305\001\n\017sfixed"
    "32.gte_lt\032\261\001has(rules.lt) && rules.lt >="
    " rules.gte && (this >= rules.lt || this "
    "< rules.gte)\? \'value must be greater tha"
    "n or equal to %s and less than %s\'.forma"
    "t([rules.gte, rules.lt]) : \'\'\n\315\001\n\031sfixed"
    "32.gte_lt_exclusive\032\257\001has(rules.lt) && r"
    "ules.lt < rules.gte && (rules.lt <= this"
    " && this < rules.gte)\? \'value must be gr"
    "eater than or equal to %s or less than %"
    "s\'.format([rules.gte, rules.lt]) : \'\'\n\325\001"
    "\n\020sfixed32.gte_lte\032\300\001has(rules.lte) && r"
    "ules.lte >= rules.gte && (this > rules.l"
    "te || this < rules.gte)\? \'value must be "
    "greater than or equal to %s and less tha"
    "n or equal to %s\'.format([rules.gte, rul"
    "es.lte]) : \'\'\n\335\001\n\032sfixed32.gte_lte_exclu"
    "sive\032\276\001has(rules.lte) && rules.lte < rul"
    "es.gte && (rules.lte < this && this < ru"
    "les.gte)\? \'value must be greater than or"
    " equal to %s or less than or equal to %s"
    "\'.format([rules.gte, rules.lte]) : \'\'H\001R"
    "\003gte\022|\n\002in\030\006 \003(\017Bl\302Hi\ng\n\013sfixed32.in\032X!("
    "this in dyn(rules)[\'in\']) \? \'value must "
    "be in list %s\'.format([dyn(rules)[\'in\']]"
    ") : \'\'R\002in\022\200\001\n\006not_in\030\007 \003(\017Bi\302Hf\nd\n\017sfix"
    "ed32.not_in\032Qthis in rules.not_in \? \'val"
    "ue must not be in list %s\'.format([rules"
    ".not_in]) : \'\'R\005notIn\0227\n\007example\030\010 \003(\017B\035"
    "\302H\032\n\030\n\020sfixed32.example\032\004trueR\007example*\t"
    "\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014greater_than\"\310"
    "\025\n\rSFixed64Rules\022s\n\005const\030\001 \001(\020B]\302HZ\nX\n\016"
    "sfixed64.const\032Fthis != rules.const \? \'v"
    "alue must equal %s\'.format([rules.const]"
    ") : \'\'R\005const\022\221\001\n\002lt\030\002 \001(\020B\177\302H|\nz\n\013sfixe"
    "d64.lt\032k!has(rules.gte) && !has(rules.gt"
    ") && this >= rules.lt\? \'value must be le"
    "ss than %s\'.format([rules.lt]) : \'\'H\000R\002l"
    "t\022\244\001\n\003lte\030\003 \001(\020B\217\001\302H\213\001\n\210\001\n\014sfixed64.lte\032"
    "x!has(rules.gte) && !has(rules.gt) && th"
    "is > rules.lte\? \'value must be less than"
    " or equal to %s\'.format([rules.lte]) : \'"
    "\'H\000R\003lte\022\252\007\n\002gt\030\004 \001(\020B\227\007\302H\223\007\n}\n\013sfixed64"
    ".gt\032n!has(rules.lt) && !has(rules.lte) &"
    "& this <= rules.gt\? \'value must be great"
    "er than %s\'.format([rules.gt]) : \'\'\n\266\001\n\016"
    "sfixed64.gt_lt\032\243\001has(rules.lt) && rules."
    "lt >= rules.gt && (this >= rules.lt || t"
    "his <= rules.gt)\? \'value must be greater"
    " than %s and less than %s\'.format([rules"
    ".gt, rules.lt]) : \'\'\n\276\001\n\030sfixed64.gt_lt_"
    "exclusive\032\241\001has(rules.lt) && rules.lt < "
    "rules.gt && (rules.lt <= this && this <="
    " rules.gt)\? \'value must be greater than "
    "%s or less than %s\'.format([rules.gt, ru"
    "les.lt]) : \'\'\n\306\001\n\017sfixed64.gt_lte\032\262\001has("
    "rules.lte) && rules.lte >= rules.gt && ("
    "this > rules.lte || this <= rules.gt)\? \'"
    "value must be greater than %s and less t"
    "han or equal to %s\'.format([rules.gt, ru"
    "les.lte]) : \'\'\n\316\001\n\031sfixed64.gt_lte_exclu"
    "sive\032\260\001has(rules.lte) && rules.lte < rul"
    "es.gt && (rules.lte < this && this <= ru"
    "les.gt)\? \'value must be greater than %s "
    "or less than or equal to %s\'.format([rul"
    "es.gt, rules.lte]) : \'\'H\001R\002gt\022\367\007\n\003gte\030\005 "
    "\001(\020B\342\007\302H\336\007\n\213\001\n\014sfixed64.gte\032{!has(rules."
    "lt) && !has(rules.lte) && this < rules.g"
    "te\? \'value must be greater than or equal"
    " to %s\'.format([rules.gte]) : \'\'\n\305\001\n\017sfi"
    "xed64.gte_lt\032\261\001has(rules.lt) && rules.lt"
    " >= rules.gte && (this >= rules.lt || th"
    "is < rules.gte)\? \'value must be greater "
    "than or equal to %s and less than %s\'.fo"
    "rmat([rules.gte, rules.lt]) : \'\'\n\315\001\n\031sfi"
    "xed64.gte_lt_exclusive\032\257\001has(rules.lt) &"
    "& rules.lt < rules.gte && (rules.lt <= t"
    "his && this < rules.gte)\? \'value must be"
    " greater than or equal to %s or less tha"
    "n %s\'.format([rules.gte, rules.lt]) : \'\'"
    "\n\325\001\n\020sfixed64.gte_lte\032\300\001has(rules.lte) &"
    "& rules.lte >= rules.gte && (this > rule"
    "s.lte || this < rules.gte)\? \'value must "
    "be greater than or equal to %s and less "
    "than or equal to %s\'.format([rules.gte, "
    "rules.lte]) : \'\'\n\335\001\n\032sfixed64.gte_lte_ex"
    "clusive\032\276\001has(rules.lte) && rules.lte < "
    "rules.gte && (rules.lte < this && this <"
    " rules.gte)\? \'value must be greater than"
    " or equal to %s or less than or equal to"
    " %s\'.format([rules.gte, rules.lte]) : \'\'"
    "H\001R\003gte\022|\n\002in\030\006 \003(\020Bl\302Hi\ng\n\013sfixed64.in\032"
    "X!(this in dyn(rules)[\'in\']) \? \'value mu"
    "st be in list %s\'.format([dyn(rules)[\'in"
    "\']]) : \'\'R\002in\022\200\001\n\006not_in\030\007 \003(\020Bi\302Hf\nd\n\017s"
    "fixed64.not_in\032Qthis in rules.not_in \? \'"
    "value must not be in list %s\'.format([ru"
    "les.not_in]) : \'\'R\005notIn\0227\n\007example\030\010 \003("
    "\020B\035\302H\032\n\030\n\020sfixed64.example\032\004trueR\007exampl"
    "e*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014greater_tha"
    "n\"\274\001\n\tBoolRules\022o\n\005const\030\001 \001(\010BY\302HV\nT\n\nb"
    "ool.const\032Fthis != rules.const \? \'value "
    "must equal %s\'.format([rules.const]) : \'"
    "\'R\005const\0223\n\007example\030\002 \003(\010B\031\302H\026\n\024\n\014bool.e"
    "xample\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002\"\2419\n\013Str"
    "ingRules\022s\n\005const\030\001 \001(\tB]\302HZ\nX\n\014string.c"
    "onst\032Hthis != rules.const \? \'value must "
    "equal `%s`\'.format([rules.const]) : \'\'R\005"
    "const\022\203\001\n\003len\030\023 \001(\004Bq\302Hn\nl\n\nstring.len\032^"
    "uint(this.size()) != rules.len \? \'value "
    "length must be %s characters\'.format([ru"
    "les.len]) : \'\'R\003len\022\241\001\n\007min_len\030\002 \001(\004B\207\001"
    "\302H\203\001\n\200\001\n\016string.min_len\032nuint(this.size("
    ")) < rules.min_len \? \'value length must "
    "be at least %s characters\'.format([rules"
    ".min_len]) : \'\'R\006minLen\022\237\001\n\007max_len\030\003 \001("
    "\004B\205\001\302H\201\001\n\177\n\016string.max_len\032muint(this.si"
    "ze()) > rules.max_len \? \'value length mu"
    "st be at most %s characters\'.format([rul"
    "es.max_len]) : \'\'R\006maxLen\022\245\001\n\tlen_bytes\030"
    "\024 \001(\004B\207\001\302H\203\001\n\200\001\n\020string.len_bytes\032luint("
    "bytes(this).size()) != rules.len_bytes \?"
    " \'value length must be %s bytes\'.format("
    "[rules.len_bytes]) : \'\'R\010lenBytes\022\255\001\n\tmi"
    "n_bytes\030\004 \001(\004B\217\001\302H\213\001\n\210\001\n\020string.min_byte"
    "s\032tuint(bytes(this).size()) < rules.min_"
    "bytes \? \'value length must be at least %"
    "s bytes\'.format([rules.min_bytes]) : \'\'R"
    "\010minBytes\022\254\001\n\tmax_bytes\030\005 \001(\004B\216\001\302H\212\001\n\207\001\n"
    "\020string.max_bytes\032suint(bytes(this).size"
    "()) > rules.max_bytes \? \'value length mu"
    "st be at most %s bytes\'.format([rules.ma"
    "x_bytes]) : \'\'R\010maxBytes\022\226\001\n\007pattern\030\006 \001"
    "(\tB|\302Hy\nw\n\016string.pattern\032e!this.matches"
    "(rules.pattern) \? \'value does not match "
    "regex pattern `%s`\'.format([rules.patter"
    "n]) : \'\'R\007pattern\022\214\001\n\006prefix\030\007 \001(\tBt\302Hq\n"
    "o\n\rstring.prefix\032^!this.startsWith(rules"
    ".prefix) \? \'value does not have prefix `"
    "%s`\'.format([rules.prefix]) : \'\'R\006prefix"
    "\022\212\001\n\006suffix\030\010 \001(\tBr\302Ho\nm\n\rstring.suffix\032"
    "\\!this.endsWith(rules.suffix) \? \'value d"
    "oes not have suffix `%s`\'.format([rules."
    "suffix]) : \'\'R\006suffix\022\232\001\n\010contains\030\t \001(\t"
    "B~\302H{\ny\n\017string.contains\032f!this.contains"
    "(rules.contains) \? \'value does not conta"
    "in substring `%s`\'.format([rules.contain"
    "s]) : \'\'R\010contains\022\245\001\n\014not_contains\030\027 \001("
    "\tB\201\001\302H~\n|\n\023string.not_contains\032ethis.con"
    "tains(rules.not_contains) \? \'value conta"
    "ins substring `%s`\'.format([rules.not_co"
    "ntains]) : \'\'R\013notContains\022z\n\002in\030\n \003(\tBj"
    "\302Hg\ne\n\tstring.in\032X!(this in dyn(rules)[\'"
    "in\']) \? \'value must be in list %s\'.forma"
    "t([dyn(rules)[\'in\']]) : \'\'R\002in\022~\n\006not_in"
    "\030\013 \003(\tBg\302Hd\nb\n\rstring.not_in\032Qthis in ru"
    "les.not_in \? \'value must not be in list "
    "%s\'.format([rules.not_in]) : \'\'R\005notIn\022\346"
    "\001\n\005email\030\014 \001(\010B\315\001\302H\311\001\na\n\014string.email\022#v"
    "alue must be a valid email address\032,!rul"
    "es.email || this == \'\' || this.isEmail()"
    "\nd\n\022string.email_empty\0222value is empty, "
    "which is not a valid email address\032\032!rul"
    "es.email || this != \'\'H\000R\005email\022\361\001\n\010host"
    "name\030\r \001(\010B\322\001\302H\316\001\ne\n\017string.hostname\022\036va"
    "lue must be a valid hostname\0322!rules.hos"
    "tname || this == \'\' || this.isHostname()"
    "\ne\n\025string.hostname_empty\022-value is empt"
    "y, which is not a valid hostname\032\035!rules"
    ".hostname || this != \'\'H\000R\010hostname\022\313\001\n\002"
    "ip\030\016 \001(\010B\270\001\302H\264\001\nU\n\tstring.ip\022 value must"
    " be a valid IP address\032&!rules.ip || thi"
    "s == \'\' || this.isIp()\n[\n\017string.ip_empt"
    "y\022/value is empty, which is not a valid "
    "IP address\032\027!rules.ip || this != \'\'H\000R\002i"
    "p\022\334\001\n\004ipv4\030\017 \001(\010B\305\001\302H\301\001\n\\\n\013string.ipv4\022\""
    "value must be a valid IPv4 address\032)!rul"
    "es.ipv4 || this == \'\' || this.isIp(4)\na\n"
    "\021string.ipv4_empty\0221value is empty, whic"
    "h is not a valid IPv4 address\032\031!rules.ip"
    "v4 || this != \'\'H\000R\004ipv4\022\334\001\n\004ipv6\030\020 \001(\010B"
    "\305\001\302H\301\001\n\\\n\013string.ipv6\022\"value must be a v"
    "alid IPv6 address\032)!rules.ipv6 || this ="
    "= \'\' || this.isIp(6)\na\n\021string.ipv6_empt"
    "y\0221value is empty, which is not a valid "
    "IPv6 address\032\031!rules.ipv6 || this != \'\'H"
    "\000R\004ipv6\022\304\001\n\003uri\030\021 \001(\010B\257\001\302H\253\001\nQ\n\nstring.u"
    "ri\022\031value must be a valid URI\032(!rules.ur"
    "i || this == \'\' || this.isUri()\nV\n\020strin"
    "g.uri_empty\022(value is empty, which is no"
    "t a valid URI\032\030!rules.uri || this != \'\'H"
    "\000R\003uri\022n\n\007uri_ref\030\022 \001(\010BS\302HP\nN\n\016string.u"
    "ri_ref\022\031value must be a valid URI\032!!rule"
    "s.uri_ref || this.isUriRef()H\000R\006uriRef\022\231"
    "\002\n\007address\030\025 \001(\010B\374\001\302H\370\001\n\201\001\n\016string.addre"
    "ss\022-value must be a valid hostname, or i"
    "p address\032@!rules.address || this == \'\' "
    "|| this.isHostname() || this.isIp()\nr\n\024s"
    "tring.address_empty\022<value is empty, whi"
    "ch is not a valid hostname, or ip addres"
    "s\032\034!rules.address || this != \'\'H\000R\007addre"
    "ss\022\236\002\n\004uuid\030\026 \001(\010B\207\002\302H\203\002\n\245\001\n\013string.uuid"
    "\022\032value must be a valid UUID\032z!rules.uui"
    "d || this == \'\' || this.matches(\'^[0-9a-"
    "fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-["
    "0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\')\nY\n\021stri"
    "ng.uuid_empty\022)value is empty, which is "
    "not a valid UUID\032\031!rules.uuid || this !="
    " \'\'H\000R\004uuid\022\367\001\n\005tuuid\030! \001(\010B\336\001\302H\332\001\ns\n\014st"
    "ring.tuuid\022\"value must be a valid trimme"
    "d UUID\032\?!rules.tuuid || this == \'\' || th"
    "is.matches(\'^[0-9a-fA-F]{32}$\')\nc\n\022strin"
    "g.tuuid_empty\0221value is empty, which is "
    "not a valid trimmed UUID\032\032!rules.tuuid |"
    "| this != \'\'H\000R\005tuuid\022\247\002\n\021ip_with_prefix"
    "len\030\032 \001(\010B\370\001\302H\364\001\nx\n\030string.ip_with_prefi"
    "xlen\022\037value must be a valid IP prefix\032;!"
    "rules.ip_with_prefixlen || this == \'\' ||"
    " this.isIpPrefix()\nx\n\036string.ip_with_pre"
    "fixlen_empty\022.value is empty, which is n"
    "ot a valid IP prefix\032&!rules.ip_with_pre"
    "fixlen || this != \'\'H\000R\017ipWithPrefixlen\022"
    "\342\002\n\023ipv4_with_prefixlen\030\033 \001(\010B\257\002\302H\253\002\n\223\001\n"
    "\032string.ipv4_with_prefixlen\0225value must "
    "be a valid IPv4 address with prefix leng"
    "th\032>!rules.ipv4_with_prefixlen || this ="
    "= \'\' || this.isIpPrefix(4)\n\222\001\n string.ip"
    "v4_with_prefixlen_empty\022Dvalue is empty,"
    " which is not a valid IPv4 address with "
    "prefix length\032(!rules.ipv4_with_prefixle"
    "n || this != \'\'H\000R\021ipv4WithPrefixlen\022\342\002\n"
    "\023ipv6_with_prefixlen\030\034 \001(\010B\257\002\302H\253\002\n\223\001\n\032st"
    "ring.ipv6_with_prefixlen\0225value must be "
    "a valid IPv6 address with prefix length\032"
    ">!rules.ipv6_with_prefixlen || this == \'"
    "\' || this.isIpPrefix(6)\n\222\001\n string.ipv6_"
    "with_prefixlen_empty\022Dvalue is empty, wh"
    "ich is not a valid IPv6 address with pre"
    "fix length\032(!rules.ipv6_with_prefixlen |"
    "| this != \'\'H\000R\021ipv6WithPrefixlen\022\374\001\n\tip"
    "_prefix\030\035 \001(\010B\334\001\302H\330\001\nl\n\020string.ip_prefix"
    "\022\037value must be a valid IP prefix\0327!rule"
    "s.ip_prefix || this == \'\' || this.isIpPr"
    "efix(true)\nh\n\026string.ip_prefix_empty\022.va"
    "lue is empty, which is not a valid IP pr"
    "efix\032\036!rules.ip_prefix || this != \'\'H\000R\010"
    "ipPrefix\022\217\002\n\013ipv4_prefix\030\036 \001(\010B\353\001\302H\347\001\nu\n"
    "\022string.ipv4_prefix\022!value must be a val"
    "id IPv4 prefix\032<!rules.ipv4_prefix || th"
    "is == \'\' || this.isIpPrefix(4, true)\nn\n\030"
    "string.ipv4_prefix_empty\0220value is empty"
    ", which is not a valid IPv4 prefix\032 !rul"
    "es.ipv4_prefix || this != \'\'H\000R\nipv4Pref"
    "ix\022\217\002\n\013ipv6_prefix\030\037 \001(\010B\353\001\302H\347\001\nu\n\022strin"
    "g.ipv6_prefix\022!value must be a valid IPv"
    "6 prefix\032<!rules.ipv6_prefix || this == "
    "\'\' || this.isIpPrefix(6, true)\nn\n\030string"
    ".ipv6_prefix_empty\0220value is empty, whic"
    "h is not a valid IPv6 prefix\032 !rules.ipv"
    "6_prefix || this != \'\'H\000R\nipv6Prefix\022\302\002\n"
    "\rhost_and_port\030  \001(\010B\233\002\302H\227\002\n\231\001\n\024string.h"
    "ost_and_port\022Avalue must be a valid host"
    " (hostname or IP address) and port pair\032"
    ">!rules.host_and_port || this == \'\' || t"
    "his.isHostAndPort(true)\ny\n\032string.host_a"
    "nd_port_empty\0227value is empty, which is "
    "not a valid host and port pair\032\"!rules.h"
    "ost_and_port || this != \'\'H\000R\013hostAndPor"
    "t\022\270\005\n\020well_known_regex\030\030 \001(\0162\030.buf.valid"
    "ate.KnownRegexB\361\004\302H\355\004\n\360\001\n#string.well_kn"
    "own_regex.header_name\022&value must be a v"
    "alid HTTP header name\032\240\001rules.well_known"
    "_regex != 1 || this == \'\' || this.matche"
    "s(!has(rules.strict) || rules.strict \?\'^"
    ":\?[0-9a-zA-Z!#$%&\\\'*+-.^_|~\\x60]+$\' :\'^["
    "^\\u0000\\u000A\\u000D]+$\')\n\215\001\n)string.well"
    "_known_regex.header_name_empty\0225value is"
    " empty, which is not a valid HTTP header"
    " name\032)rules.well_known_regex != 1 || th"
    "is != \'\'\n\347\001\n$string.well_known_regex.hea"
    "der_value\022\'value must be a valid HTTP he"
    "ader value\032\225\001rules.well_known_regex != 2"
    " || this.matches(!has(rules.strict) || r"
    "ules.strict \?\'^[^\\u0000-\\u0008\\u000A-\\u0"
    "01F\\u007F]*$\' :\'^[^\\u0000\\u000A\\u000D]*$"
    "\')H\000R\016wellKnownRegex\022\026\n\006strict\030\031 \001(\010R\006st"
    "rict\0225\n\007example\030\" \003(\tB\033\302H\030\n\026\n\016string.exa"
    "mple\032\004trueR\007example*\t\010\350\007\020\200\200\200\200\002B\014\n\nwell_k"
    "nown\"\243\021\n\nBytesRules\022m\n\005const\030\001 \001(\014BW\302HT\n"
    "R\n\013bytes.const\032Cthis != rules.const \? \'v"
    "alue must be %x\'.format([rules.const]) :"
    " \'\'R\005const\022}\n\003len\030\r \001(\004Bk\302Hh\nf\n\tbytes.le"
    "n\032Yuint(this.size()) != rules.len \? \'val"
    "ue length must be %s bytes\'.format([rule"
    "s.len]) : \'\'R\003len\022\230\001\n\007min_len\030\002 \001(\004B\177\302H|"
    "\nz\n\rbytes.min_len\032iuint(this.size()) < r"
    "ules.min_len \? \'value length must be at "
    "least %s bytes\'.format([rules.min_len]) "
    ": \'\'R\006minLen\022\220\001\n\007max_len\030\003 \001(\004Bw\302Ht\nr\n\rb"
    "ytes.max_len\032auint(this.size()) > rules."
    "max_len \? \'value must be at most %s byte"
    "s\'.format([rules.max_len]) : \'\'R\006maxLen\022"
    "\231\001\n\007pattern\030\004 \001(\tB\177\302H|\nz\n\rbytes.pattern\032"
    "i!string(this).matches(rules.pattern) \? "
    "\'value must match regex pattern `%s`\'.fo"
    "rmat([rules.pattern]) : \'\'R\007pattern\022\211\001\n\006"
    "prefix\030\005 \001(\014Bq\302Hn\nl\n\014bytes.prefix\032\\!this"
    ".startsWith(rules.prefix) \? \'value does "
    "not have prefix %x\'.format([rules.prefix"
    "]) : \'\'R\006prefix\022\207\001\n\006suffix\030\006 \001(\014Bo\302Hl\nj\n"
    "\014bytes.suffix\032Z!this.endsWith(rules.suff"
    "ix) \? \'value does not have suffix %x\'.fo"
    "rmat([rules.suffix]) : \'\'R\006suffix\022\215\001\n\010co"
    "ntains\030\007 \001(\014Bq\302Hn\nl\n\016bytes.contains\032Z!th"
    "is.contains(rules.contains) \? \'value doe"
    "s not contain %x\'.format([rules.contains"
    "]) : \'\'R\010contains\022\233\001\n\002in\030\010 \003(\014B\212\001\302H\206\001\n\203\001"
    "\n\010bytes.in\032wdyn(rules)[\'in\'].size() > 0 "
    "&& !(this in dyn(rules)[\'in\']) \? \'value "
    "must be in list %s\'.format([dyn(rules)[\'"
    "in\']]) : \'\'R\002in\022}\n\006not_in\030\t \003(\014Bf\302Hc\na\n\014"
    "bytes.not_in\032Qthis in rules.not_in \? \'va"
    "lue must not be in list %s\'.format([rule"
    "s.not_in]) : \'\'R\005notIn\022\357\001\n\002ip\030\n \001(\010B\334\001\302H"
    "\330\001\nt\n\010bytes.ip\022 value must be a valid IP"
    " address\032F!rules.ip || this.size() == 0 "
    "|| this.size() == 4 || this.size() == 16"
    "\n`\n\016bytes.ip_empty\022/value is empty, whic"
    "h is not a valid IP address\032\035!rules.ip |"
    "| this.size() != 0H\000R\002ip\022\352\001\n\004ipv4\030\013 \001(\010B"
    "\323\001\302H\317\001\ne\n\nbytes.ipv4\022\"value must be a va"
    "lid IPv4 address\0323!rules.ipv4 || this.si"
    "ze() == 0 || this.size() == 4\nf\n\020bytes.i"
    "pv4_empty\0221value is empty, which is not "
    "a valid IPv4 address\032\037!rules.ipv4 || thi"
    "s.size() != 0H\000R\004ipv4\022\353\001\n\004ipv6\030\014 \001(\010B\324\001\302"
    "H\320\001\nf\n\nbytes.ipv6\022\"value must be a valid"
    " IPv6 address\0324!rules.ipv6 || this.size("
    ") == 0 || this.size() == 16\nf\n\020bytes.ipv"
    "6_empty\0221value is empty, which is not a "
    "valid IPv6 address\032\037!rules.ipv6 || this."
    "size() != 0H\000R\004ipv6\0224\n\007example\030\016 \003(\014B\032\302H"
    "\027\n\025\n\rbytes.example\032\004trueR\007example*\t\010\350\007\020\200"
    "\200\200\200\002B\014\n\nwell_known\"\327\003\n\tEnumRules\022o\n\005cons"
    "t\030\001 \001(\005BY\302HV\nT\n\nenum.const\032Fthis != rule"
    "s.const \? \'value must equal %s\'.format(["
    "rules.const]) : \'\'R\005const\022!\n\014defined_onl"
    "y\030\002 \001(\010R\013definedOnly\022x\n\002in\030\003 \003(\005Bh\302He\nc\n"
    "\007enum.in\032X!(this in dyn(rules)[\'in\']) \? "
    "\'value must be in list %s\'.format([dyn(r"
    "ules)[\'in\']]) : \'\'R\002in\022|\n\006not_in\030\004 \003(\005Be"
    "\302Hb\n`\n\013enum.not_in\032Qthis in rules.not_in"
    " \? \'value must not be in list %s\'.format"
    "([rules.not_in]) : \'\'R\005notIn\0223\n\007example\030"
    "\005 \003(\005B\031\302H\026\n\024\n\014enum.example\032\004trueR\007exampl"
    "e*\t\010\350\007\020\200\200\200\200\002\"\244\004\n\rRepeatedRules\022\250\001\n\tmin_i"
    "tems\030\001 \001(\004B\212\001\302H\206\001\n\203\001\n\022repeated.min_items"
    "\032muint(this.size()) < rules.min_items \? "
    "\'value must contain at least %d item(s)\'"
    ".format([rules.min_items]) : \'\'R\010minItem"
    "s\022\254\001\n\tmax_items\030\002 \001(\004B\216\001\302H\212\001\n\207\001\n\022repeate"
    "d.max_items\032quint(this.size()) > rules.m"
    "ax_items \? \'value must contain no more t"
    "han %s item(s)\'.format([rules.max_items]"
    ") : \'\'R\010maxItems\022x\n\006unique\030\003 \001(\010B`\302H]\n[\n"
    "\017repeated.unique\022(repeated value must co"
    "ntain unique items\032\036!rules.unique || thi"
    "s.unique()R\006unique\0224\n\005items\030\004 \001(\0132\036.buf."
    "validate.FieldConstraintsR\005items*\t\010\350\007\020\200\200"
    "\200\200\002\"\270\003\n\010MapRules\022\231\001\n\tmin_pairs\030\001 \001(\004B|\302H"
    "y\nw\n\rmap.min_pairs\032fuint(this.size()) < "
    "rules.min_pairs \? \'map must be at least "
    "%d entries\'.format([rules.min_pairs]) : "
    "\'\'R\010minPairs\022\230\001\n\tmax_pairs\030\002 \001(\004B{\302Hx\nv\n"
    "\rmap.max_pairs\032euint(this.size()) > rule"
    "s.max_pairs \? \'map must be at most %d en"
    "tries\'.format([rules.max_pairs]) : \'\'R\010m"
    "axPairs\0222\n\004keys\030\004 \001(\0132\036.buf.validate.Fie"
    "ldConstraintsR\004keys\0226\n\006values\030\005 \001(\0132\036.bu"
    "f.validate.FieldConstraintsR\006values*\t\010\350\007"
    "\020\200\200\200\200\002\"1\n\010AnyRules\022\016\n\002in\030\002 \003(\tR\002in\022\025\n\006no"
    "t_in\030\003 \003(\tR\005notIn\"\242\027\n\rDurationRules\022\216\001\n\005"
    "const\030\002 \001(\0132\031.google.protobuf.DurationB]"
    "\302HZ\nX\n\016duration.const\032Fthis != rules.con"
    "st \? \'value must equal %s\'.format([rules"
    ".const]) : \'\'R\005const\022\254\001\n\002lt\030\003 \001(\0132\031.goog"
    "le.protobuf.DurationB\177\302H|\nz\n\013duration.lt"
    "\032k!has(rules.gte) && !has(rules.gt) && t"
    "his >= rules.lt\? \'value must be less tha"
    "n %s\'.format([rules.lt]) : \'\'H\000R\002lt\022\277\001\n\003"
    "lte\030\004 \001(\0132\031.google.protobuf.DurationB\217\001\302"
    "H\213\001\n\210\001\n\014duration.lte\032x!has(rules.gte) &&"
    " !has(rules.gt) && this > rules.lte\? \'va"
    "lue must be less than or equal to %s\'.fo"
    "rmat([rules.lte]) : \'\'H\000R\003lte\022\305\007\n\002gt\030\005 \001"
    "(\0132\031.google.protobuf.DurationB\227\007\302H\223\007\n}\n\013"
    "duration.gt\032n!has(rules.lt) && !has(rule"
    "s.lte) && this <= rules.gt\? \'value must "
    "be greater than %s\'.format([rules.gt]) :"
    " \'\'\n\266\001\n\016duration.gt_lt\032\243\001has(rules.lt) &"
    "& rules.lt >= rules.gt && (this >= rules"
    ".lt || this <= rules.gt)\? \'value must be"
    " greater than %s and less than %s\'.forma"
    "t([rules.gt, rules.lt]) : \'\'\n\276\001\n\030duratio"
    "n.gt_lt_exclusive\032\241\001has(rules.lt) && rul"
    "es.lt < rules.gt && (rules.lt <= this &&"
    " this <= rules.gt)\? \'value must be great"
    "er than %s or less than %s\'.format([rule"
    "s.gt, rules.lt]) : \'\'\n\306\001\n\017duration.gt_lt"
    "e\032\262\001has(rules.lte) && rules.lte >= rules"
    ".gt && (this > rules.lte || this <= rule"
    "s.gt)\? \'value must be greater than %s an"
    "d less than or equal to %s\'.format([rule"
    "s.gt, rules.lte]) : \'\'\n\316\001\n\031duration.gt_l"
    "te_exclusive\032\260\001has(rules.lte) && rules.l"
    "te < rules.gt && (rules.lte < this && th"
    "is <= rules.gt)\? \'value must be greater "
    "than %s or less than or equal to %s\'.for"
    "mat([rules.gt, rules.lte]) : \'\'H\001R\002gt\022\222\010"
    "\n\003gte\030\006 \001(\0132\031.google.protobuf.DurationB\342"
    "\007\302H\336\007\n\213\001\n\014duration.gte\032{!has(rules.lt) &"
    "& !has(rules.lte) && this < rules.gte\? \'"
    "value must be greater than or equal to %"
    "s\'.format([rules.gte]) : \'\'\n\305\001\n\017duration"
    ".gte_lt\032\261\001has(rules.lt) && rules.lt >= r"
    "ules.gte && (this >= rules.lt || this < "
    "rules.gte)\? \'value must be greater than "
    "or equal to %s and less than %s\'.format("
    "[rules.gte, rules.lt]) : \'\'\n\315\001\n\031duration"
    ".gte_lt_exclusive\032\257\001has(rules.lt) && rul"
    "es.lt < rules.gte && (rules.lt <= this &"
    "& this < rules.gte)\? \'value must be grea"
    "ter than or equal to %s or less than %s\'"
    ".format([rules.gte, rules.lt]) : \'\'\n\325\001\n\020"
    "duration.gte_lte\032\300\001has(rules.lte) && rul"
    "es.lte >= rules.gte && (this > rules.lte"
    " || this < rules.gte)\? \'value must be gr"
    "eater than or equal to %s and less than "
    "or equal to %s\'.format([rules.gte, rules"
    ".lte]) : \'\'\n\335\001\n\032duration.gte_lte_exclusi"
    "ve\032\276\001has(rules.lte) && rules.lte < rules"
    ".gte && (rules.lte < this && this < rule"
    "s.gte)\? \'value must be greater than or e"
    "qual to %s or less than or equal to %s\'."
    "format([rules.gte, rules.lte]) : \'\'H\001R\003g"
    "te\022\227\001\n\002in\030\007 \003(\0132\031.google.protobuf.Durati"
    "onBl\302Hi\ng\n\013duration.in\032X!(this in dyn(ru"
    "les)[\'in\']) \? \'value must be in list %s\'"
    ".format([dyn(rules)[\'in\']]) : \'\'R\002in\022\233\001\n"
    "\006not_in\030\010 \003(\0132\031.google.protobuf.Duration"
    "Bi\302Hf\nd\n\017duration.not_in\032Qthis in rules."
    "not_in \? \'value must not be in list %s\'."
    "format([rules.not_in]) : \'\'R\005notIn\022R\n\007ex"
    "ample\030\t \003(\0132\031.google.protobuf.DurationB\035"
    "\302H\032\n\030\n\020duration.example\032\004trueR\007example*\t"
    "\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014greater_than\"\260"
    "\030\n\016TimestampRules\022\220\001\n\005const\030\002 \001(\0132\032.goog"
    "le.protobuf.TimestampB^\302H[\nY\n\017timestamp."
    "const\032Fthis != rules.const \? \'value must"
    " equal %s\'.format([rules.const]) : \'\'R\005c"
    "onst\022\257\001\n\002lt\030\003 \001(\0132\032.google.protobuf.Time"
    "stampB\200\001\302H}\n{\n\014timestamp.lt\032k!has(rules."
    "gte) && !has(rules.gt) && this >= rules."
    "lt\? \'value must be less than %s\'.format("
    "[rules.lt]) : \'\'H\000R\002lt\022\301\001\n\003lte\030\004 \001(\0132\032.g"
    "oogle.protobuf.TimestampB\220\001\302H\214\001\n\211\001\n\rtime"
    "stamp.lte\032x!has(rules.gte) && !has(rules"
    ".gt) && this > rules.lte\? \'value must be"
    " less than or equal to %s\'.format([rules"
    ".lte]) : \'\'H\000R\003lte\022s\n\006lt_now\030\007 \001(\010BZ\302HW\n"
    "U\n\020timestamp.lt_now\032A(rules.lt_now && th"
    "is > now) \? \'value must be less than now"
    "\' : \'\'H\000R\005ltNow\022\313\007\n\002gt\030\005 \001(\0132\032.google.pr"
    "otobuf.TimestampB\234\007\302H\230\007\n~\n\014timestamp.gt\032"
    "n!has(rules.lt) && !has(rules.lte) && th"
    "is <= rules.gt\? \'value must be greater t"
    "han %s\'.format([rules.gt]) : \'\'\n\267\001\n\017time"
    "stamp.gt_lt\032\243\001has(rules.lt) && rules.lt "
    ">= rules.gt && (this >= rules.lt || this"
    " <= rules.gt)\? \'value must be greater th"
    "an %s and less than %s\'.format([rules.gt"
    ", rules.lt]) : \'\'\n\277\001\n\031timestamp.gt_lt_ex"
    "clusive\032\241\001has(rules.lt) && rules.lt < ru"
    "les.gt && (rules.lt <= this && this <= r"
    "ules.gt)\? \'value must be greater than %s"
    " or less than %s\'.format([rules.gt, rule"
    "s.lt]) : \'\'\n\307\001\n\020timestamp.gt_lte\032\262\001has(r"
    "ules.lte) && rules.lte >= rules.gt && (t"
    "his > rules.lte || this <= rules.gt)\? \'v"
    "alue must be greater than %s and less th"
    "an or equal to %s\'.format([rules.gt, rul"
    "es.lte]) : \'\'\n\317\001\n\032timestamp.gt_lte_exclu"
    "sive\032\260\001has(rules.lte) && rules.lte < rul"
    "es.gt && (rules.lte < this && this <= ru"
    "les.gt)\? \'value must be greater than %s "
    "or less than or equal to %s\'.format([rul"
    "es.gt, rules.lte]) : \'\'H\001R\002gt\022\230\010\n\003gte\030\006 "
    "\001(\0132\032.google.protobuf.TimestampB\347\007\302H\343\007\n\214"
    "\001\n\rtimestamp.gte\032{!has(rules.lt) && !has"
    "(rules.lte) && this < rules.gte\? \'value "
    "must be greater than or equal to %s\'.for"
    "mat([rules.gte]) : \'\'\n\306\001\n\020timestamp.gte_"
    "lt\032\261\001has(rules.lt) && rules.lt >= rules."
    "gte && (this >= rules.lt || this < rules"
    ".gte)\? \'value must be greater than or eq"
    "ual to %s and less than %s\'.format([rule"
    "s.gte, rules.lt]) : \'\'\n\316\001\n\032timestamp.gte"
    "_lt_exclusive\032\257\001has(rules.lt) && rules.l"
    "t < rules.gte && (rules.lt <= this && th"
    "is < rules.gte)\? \'value must be greater "
    "than or equal to %s or less than %s\'.for"
    "mat([rules.gte, rules.lt]) : \'\'\n\326\001\n\021time"
    "stamp.gte_lte\032\300\001has(rules.lte) && rules."
    "lte >= rules.gte && (this > rules.lte ||"
    " this < rules.gte)\? \'value must be great"
    "er than or equal to %s and less than or "
    "equal to %s\'.format([rules.gte, rules.lt"
    "e]) : \'\'\n\336\001\n\033timestamp.gte_lte_exclusive"
    "\032\276\001has(rules.lte) && rules.lte < rules.g"
    "te && (rules.lte < this && this < rules."
    "gte)\? \'value must be greater than or equ"
    "al to %s or less than or equal to %s\'.fo"
    "rmat([rules.gte, rules.lte]) : \'\'H\001R\003gte"
    "\022v\n\006gt_now\030\010 \001(\010B]\302HZ\nX\n\020timestamp.gt_no"
    "w\032D(rules.gt_now && this < now) \? \'value"
    " must be greater than now\' : \'\'H\001R\005gtNow"
    "\022\300\001\n\006within\030\t \001(\0132\031.google.protobuf.Dura"
    "tionB\214\001\302H\210\001\n\205\001\n\020timestamp.within\032qthis <"
    " now-rules.within || this > now+rules.wi"
    "thin \? \'value must be within %s of now\'."
    "format([rules.within]) : \'\'R\006within\022T\n\007e"
    "xample\030\n \003(\0132\032.google.protobuf.Timestamp"
    "B\036\302H\033\n\031\n\021timestamp.example\032\004trueR\007exampl"
    "e*\t\010\350\007\020\200\200\200\200\002B\013\n\tless_thanB\016\n\014greater_tha"
    "n\"E\n\nViolations\0227\n\nviolations\030\001 \003(\0132\027.bu"
    "f.validate.ViolationR\nviolations\"\202\001\n\tVio"
    "lation\022\035\n\nfield_path\030\001 \001(\tR\tfieldPath\022#\n"
    "\rconstraint_id\030\002 \001(\tR\014constraintId\022\030\n\007me"
    "ssage\030\003 \001(\tR\007message\022\027\n\007for_key\030\004 \001(\010R\006f"
    "orKey*\235\001\n\006Ignore\022\026\n\022IGNORE_UNSPECIFIED\020\000"
    "\022\031\n\025IGNORE_IF_UNPOPULATED\020\001\022\033\n\027IGNORE_IF"
    "_DEFAULT_VALUE\020\002\022\021\n\rIGNORE_ALWAYS\020\003\022\024\n\014I"
    "GNORE_EMPTY\020\001\032\002\010\001\022\026\n\016IGNORE_DEFAULT\020\002\032\002\010"
    "\001\032\002\020\001*n\n\nKnownRegex\022\033\n\027KNOWN_REGEX_UNSPE"
    "CIFIED\020\000\022 \n\034KNOWN_REGEX_HTTP_HEADER_NAME"
    "\020\001\022!\n\035KNOWN_REGEX_HTTP_HEADER_VALUE\020\002:\\\n"
    "\007message\022\037.google.protobuf.MessageOption"
    "s\030\207\t \001(\0132 .buf.validate.MessageConstrain"
    "tsR\007message:T\n\005oneof\022\035.google.protobuf.O"
    "neofOptions\030\207\t \001(\0132\036.buf.validate.OneofC"
    "onstraintsR\005oneof:T\n\005field\022\035.google.prot"
    "obuf.FieldOptions\030\207\t \001(\0132\036.buf.validate."
    "FieldConstraintsR\005field:c\n\npredefined\022\035."
    "google.protobuf.FieldOptions\030\210\t \001(\0132#.bu"
    "f.validate.PredefinedConstraintsR\npredef"
    "inedBn\n\022build.buf.validateB\rValidateProt"
    "oP\001ZGbuf.build/gen/go/bufbuild/protovali"
    "date/protocolbuffers/go/buf/validate"
};
static const ::_pbi::DescriptorTable* const descriptor_table_buf_2fvalidate_2fvalidate_2eproto_deps[3] =
    {
        &::descriptor_table_google_2fprotobuf_2fdescriptor_2eproto,
        &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
};
static ::absl::once_flag descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_buf_2fvalidate_2fvalidate_2eproto = {
    false,
    false,
    53556,
    descriptor_table_protodef_buf_2fvalidate_2fvalidate_2eproto,
    "buf/validate/validate.proto",
    &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
    descriptor_table_buf_2fvalidate_2fvalidate_2eproto_deps,
    3,
    28,
    schemas,
    file_default_instances,
    TableStruct_buf_2fvalidate_2fvalidate_2eproto::offsets,
    file_level_enum_descriptors_buf_2fvalidate_2fvalidate_2eproto,
    file_level_service_descriptors_buf_2fvalidate_2fvalidate_2eproto,
};
namespace buf {
namespace validate {
const ::google::protobuf::EnumDescriptor* Ignore_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_buf_2fvalidate_2fvalidate_2eproto);
  return file_level_enum_descriptors_buf_2fvalidate_2fvalidate_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t Ignore_internal_data_[] = {
    262144u, 0u, };
bool Ignore_IsValid(int value) {
  return 0 <= value && value <= 3;
}
const ::google::protobuf::EnumDescriptor* KnownRegex_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_buf_2fvalidate_2fvalidate_2eproto);
  return file_level_enum_descriptors_buf_2fvalidate_2fvalidate_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t KnownRegex_internal_data_[] = {
    196608u, 0u, };
bool KnownRegex_IsValid(int value) {
  return 0 <= value && value <= 2;
}
// ===================================================================

class Constraint::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Constraint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Constraint, _impl_._has_bits_);
};

Constraint::Constraint(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Constraint)
}
inline PROTOBUF_NDEBUG_INLINE Constraint::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::Constraint& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        id_(arena, from.id_),
        message_(arena, from.message_),
        expression_(arena, from.expression_) {}

Constraint::Constraint(
    ::google::protobuf::Arena* arena,
    const Constraint& from)
    : ::google::protobuf::Message(arena) {
  Constraint* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:buf.validate.Constraint)
}
inline PROTOBUF_NDEBUG_INLINE Constraint::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        id_(arena),
        message_(arena),
        expression_(arena) {}

inline void Constraint::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
Constraint::~Constraint() {
  // @@protoc_insertion_point(destructor:buf.validate.Constraint)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Constraint::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.id_.Destroy();
  _impl_.message_.Destroy();
  _impl_.expression_.Destroy();
  _impl_.~Impl_();
}

const ::google::protobuf::MessageLite::ClassData*
Constraint::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              nullptr,  // IsInitialized
              PROTOBUF_FIELD_OFFSET(Constraint, _impl_._cached_size_),
              false,
          },
          &Constraint::MergeImpl,
          &Constraint::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 51, 2> Constraint::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Constraint, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Constraint_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::Constraint>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string id = 1 [json_name = "id"];
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Constraint, _impl_.id_)}},
    // optional string message = 2 [json_name = "message"];
    {::_pbi::TcParser::FastSS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(Constraint, _impl_.message_)}},
    // optional string expression = 3 [json_name = "expression"];
    {::_pbi::TcParser::FastSS1,
     {26, 2, 0, PROTOBUF_FIELD_OFFSET(Constraint, _impl_.expression_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string id = 1 [json_name = "id"];
    {PROTOBUF_FIELD_OFFSET(Constraint, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string message = 2 [json_name = "message"];
    {PROTOBUF_FIELD_OFFSET(Constraint, _impl_.message_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string expression = 3 [json_name = "expression"];
    {PROTOBUF_FIELD_OFFSET(Constraint, _impl_.expression_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\27\2\7\12\0\0\0\0"
    "buf.validate.Constraint"
    "id"
    "message"
    "expression"
  }},
};

PROTOBUF_NOINLINE void Constraint::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Constraint)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.expression_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* Constraint::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Constraint)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1 [json_name = "id"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_id();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.Constraint.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string message = 2 [json_name = "message"];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_message();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.Constraint.message");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string expression = 3 [json_name = "expression"];
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_expression();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.Constraint.expression");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Constraint)
  return target;
}

::size_t Constraint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Constraint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string id = 1 [json_name = "id"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_id());
    }

    // optional string message = 2 [json_name = "message"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_message());
    }

    // optional string expression = 3 [json_name = "expression"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_expression());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void Constraint::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Constraint*>(&to_msg);
  auto& from = static_cast<const Constraint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Constraint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_expression(from._internal_expression());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Constraint::CopyFrom(const Constraint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Constraint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Constraint::InternalSwap(Constraint* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, &other->_impl_.id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.expression_, &other->_impl_.expression_, arena);
}

::google::protobuf::Metadata Constraint::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MessageConstraints::_Internal {
 public:
  using HasBits =
      decltype(std::declval<MessageConstraints>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_._has_bits_);
};

MessageConstraints::MessageConstraints(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.MessageConstraints)
}
inline PROTOBUF_NDEBUG_INLINE MessageConstraints::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::MessageConstraints& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        cel_{visibility, arena, from.cel_} {}

MessageConstraints::MessageConstraints(
    ::google::protobuf::Arena* arena,
    const MessageConstraints& from)
    : ::google::protobuf::Message(arena) {
  MessageConstraints* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.disabled_ = from._impl_.disabled_;

  // @@protoc_insertion_point(copy_constructor:buf.validate.MessageConstraints)
}
inline PROTOBUF_NDEBUG_INLINE MessageConstraints::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        cel_{visibility, arena} {}

inline void MessageConstraints::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.disabled_ = {};
}
MessageConstraints::~MessageConstraints() {
  // @@protoc_insertion_point(destructor:buf.validate.MessageConstraints)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MessageConstraints::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

const ::google::protobuf::MessageLite::ClassData*
MessageConstraints::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              nullptr,  // IsInitialized
              PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_._cached_size_),
              false,
          },
          &MessageConstraints::MergeImpl,
          &MessageConstraints::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 2, 1, 0, 2> MessageConstraints::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967290,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_MessageConstraints_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::MessageConstraints>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool disabled = 1 [json_name = "disabled"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MessageConstraints, _impl_.disabled_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_.disabled_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_.cel_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool disabled = 1 [json_name = "disabled"];
    {PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_.disabled_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
    {PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_.cel_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::buf::validate::Constraint>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void MessageConstraints::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.MessageConstraints)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cel_.Clear();
  _impl_.disabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* MessageConstraints::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.MessageConstraints)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool disabled = 1 [json_name = "disabled"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_disabled(), target);
  }

  // repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this->_internal_cel_size());
       i < n; i++) {
    const auto& repfield = this->_internal_cel().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            3, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.MessageConstraints)
  return target;
}

::size_t MessageConstraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.MessageConstraints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
  total_size += 1UL * this->_internal_cel_size();
  for (const auto& msg : this->_internal_cel()) {
    total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // optional bool disabled = 1 [json_name = "disabled"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void MessageConstraints::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MessageConstraints*>(&to_msg);
  auto& from = static_cast<const MessageConstraints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.MessageConstraints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_cel()->MergeFrom(
      from._internal_cel());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.disabled_ = from._impl_.disabled_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MessageConstraints::CopyFrom(const MessageConstraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.MessageConstraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MessageConstraints::InternalSwap(MessageConstraints* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.cel_.InternalSwap(&other->_impl_.cel_);
        swap(_impl_.disabled_, other->_impl_.disabled_);
}

::google::protobuf::Metadata MessageConstraints::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class OneofConstraints::_Internal {
 public:
  using HasBits =
      decltype(std::declval<OneofConstraints>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(OneofConstraints, _impl_._has_bits_);
};

OneofConstraints::OneofConstraints(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.OneofConstraints)
}
OneofConstraints::OneofConstraints(
    ::google::protobuf::Arena* arena, const OneofConstraints& from)
    : OneofConstraints(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE OneofConstraints::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void OneofConstraints::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.required_ = {};
}
OneofConstraints::~OneofConstraints() {
  // @@protoc_insertion_point(destructor:buf.validate.OneofConstraints)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void OneofConstraints::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

const ::google::protobuf::MessageLite::ClassData*
OneofConstraints::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              nullptr,  // IsInitialized
              PROTOBUF_FIELD_OFFSET(OneofConstraints, _impl_._cached_size_),
              false,
          },
          &OneofConstraints::MergeImpl,
          &OneofConstraints::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> OneofConstraints::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(OneofConstraints, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_OneofConstraints_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::OneofConstraints>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool required = 1 [json_name = "required"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(OneofConstraints, _impl_.required_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(OneofConstraints, _impl_.required_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool required = 1 [json_name = "required"];
    {PROTOBUF_FIELD_OFFSET(OneofConstraints, _impl_.required_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void OneofConstraints::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.OneofConstraints)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.required_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* OneofConstraints::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.OneofConstraints)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool required = 1 [json_name = "required"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_required(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.OneofConstraints)
  return target;
}

::size_t OneofConstraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.OneofConstraints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool required = 1 [json_name = "required"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void OneofConstraints::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<OneofConstraints*>(&to_msg);
  auto& from = static_cast<const OneofConstraints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.OneofConstraints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.required_ = from._impl_.required_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void OneofConstraints::CopyFrom(const OneofConstraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.OneofConstraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void OneofConstraints::InternalSwap(OneofConstraints* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
        swap(_impl_.required_, other->_impl_.required_);
}

::google::protobuf::Metadata OneofConstraints::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class FieldConstraints::_Internal {
 public:
  using HasBits =
      decltype(std::declval<FieldConstraints>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_._oneof_case_);
};

void FieldConstraints::set_allocated_float_(::buf::validate::FloatRules* float_) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (float_) {
    ::google::protobuf::Arena* submessage_arena = float_->GetArena();
    if (message_arena != submessage_arena) {
      float_ = ::google::protobuf::internal::GetOwnedMessage(message_arena, float_, submessage_arena);
    }
    set_has_float_();
    _impl_.type_.float__ = float_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.float)
}
void FieldConstraints::set_allocated_double_(::buf::validate::DoubleRules* double_) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (double_) {
    ::google::protobuf::Arena* submessage_arena = double_->GetArena();
    if (message_arena != submessage_arena) {
      double_ = ::google::protobuf::internal::GetOwnedMessage(message_arena, double_, submessage_arena);
    }
    set_has_double_();
    _impl_.type_.double__ = double_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.double)
}
void FieldConstraints::set_allocated_int32(::buf::validate::Int32Rules* int32) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (int32) {
    ::google::protobuf::Arena* submessage_arena = int32->GetArena();
    if (message_arena != submessage_arena) {
      int32 = ::google::protobuf::internal::GetOwnedMessage(message_arena, int32, submessage_arena);
    }
    set_has_int32();
    _impl_.type_.int32_ = int32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.int32)
}
void FieldConstraints::set_allocated_int64(::buf::validate::Int64Rules* int64) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (int64) {
    ::google::protobuf::Arena* submessage_arena = int64->GetArena();
    if (message_arena != submessage_arena) {
      int64 = ::google::protobuf::internal::GetOwnedMessage(message_arena, int64, submessage_arena);
    }
    set_has_int64();
    _impl_.type_.int64_ = int64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.int64)
}
void FieldConstraints::set_allocated_uint32(::buf::validate::UInt32Rules* uint32) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (uint32) {
    ::google::protobuf::Arena* submessage_arena = uint32->GetArena();
    if (message_arena != submessage_arena) {
      uint32 = ::google::protobuf::internal::GetOwnedMessage(message_arena, uint32, submessage_arena);
    }
    set_has_uint32();
    _impl_.type_.uint32_ = uint32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.uint32)
}
void FieldConstraints::set_allocated_uint64(::buf::validate::UInt64Rules* uint64) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (uint64) {
    ::google::protobuf::Arena* submessage_arena = uint64->GetArena();
    if (message_arena != submessage_arena) {
      uint64 = ::google::protobuf::internal::GetOwnedMessage(message_arena, uint64, submessage_arena);
    }
    set_has_uint64();
    _impl_.type_.uint64_ = uint64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.uint64)
}
void FieldConstraints::set_allocated_sint32(::buf::validate::SInt32Rules* sint32) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (sint32) {
    ::google::protobuf::Arena* submessage_arena = sint32->GetArena();
    if (message_arena != submessage_arena) {
      sint32 = ::google::protobuf::internal::GetOwnedMessage(message_arena, sint32, submessage_arena);
    }
    set_has_sint32();
    _impl_.type_.sint32_ = sint32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.sint32)
}
void FieldConstraints::set_allocated_sint64(::buf::validate::SInt64Rules* sint64) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (sint64) {
    ::google::protobuf::Arena* submessage_arena = sint64->GetArena();
    if (message_arena != submessage_arena) {
      sint64 = ::google::protobuf::internal::GetOwnedMessage(message_arena, sint64, submessage_arena);
    }
    set_has_sint64();
    _impl_.type_.sint64_ = sint64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.sint64)
}
void FieldConstraints::set_allocated_fixed32(::buf::validate::Fixed32Rules* fixed32) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (fixed32) {
    ::google::protobuf::Arena* submessage_arena = fixed32->GetArena();
    if (message_arena != submessage_arena) {
      fixed32 = ::google::protobuf::internal::GetOwnedMessage(message_arena, fixed32, submessage_arena);
    }
    set_has_fixed32();
    _impl_.type_.fixed32_ = fixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.fixed32)
}
void FieldConstraints::set_allocated_fixed64(::buf::validate::Fixed64Rules* fixed64) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (fixed64) {
    ::google::protobuf::Arena* submessage_arena = fixed64->GetArena();
    if (message_arena != submessage_arena) {
      fixed64 = ::google::protobuf::internal::GetOwnedMessage(message_arena, fixed64, submessage_arena);
    }
    set_has_fixed64();
    _impl_.type_.fixed64_ = fixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.fixed64)
}
void FieldConstraints::set_allocated_sfixed32(::buf::validate::SFixed32Rules* sfixed32) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (sfixed32) {
    ::google::protobuf::Arena* submessage_arena = sfixed32->GetArena();
    if (message_arena != submessage_arena) {
      sfixed32 = ::google::protobuf::internal::GetOwnedMessage(message_arena, sfixed32, submessage_arena);
    }
    set_has_sfixed32();
    _impl_.type_.sfixed32_ = sfixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.sfixed32)
}
void FieldConstraints::set_allocated_sfixed64(::buf::validate::SFixed64Rules* sfixed64) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (sfixed64) {
    ::google::protobuf::Arena* submessage_arena = sfixed64->GetArena();
    if (message_arena != submessage_arena) {
      sfixed64 = ::google::protobuf::internal::GetOwnedMessage(message_arena, sfixed64, submessage_arena);
    }
    set_has_sfixed64();
    _impl_.type_.sfixed64_ = sfixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.sfixed64)
}
void FieldConstraints::set_allocated_bool_(::buf::validate::BoolRules* bool_) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (bool_) {
    ::google::protobuf::Arena* submessage_arena = bool_->GetArena();
    if (message_arena != submessage_arena) {
      bool_ = ::google::protobuf::internal::GetOwnedMessage(message_arena, bool_, submessage_arena);
    }
    set_has_bool_();
    _impl_.type_.bool__ = bool_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.bool)
}
void FieldConstraints::set_allocated_string(::buf::validate::StringRules* string) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (string) {
    ::google::protobuf::Arena* submessage_arena = string->GetArena();
    if (message_arena != submessage_arena) {
      string = ::google::protobuf::internal::GetOwnedMessage(message_arena, string, submessage_arena);
    }
    set_has_string();
    _impl_.type_.string_ = string;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.string)
}
void FieldConstraints::set_allocated_bytes(::buf::validate::BytesRules* bytes) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (bytes) {
    ::google::protobuf::Arena* submessage_arena = bytes->GetArena();
    if (message_arena != submessage_arena) {
      bytes = ::google::protobuf::internal::GetOwnedMessage(message_arena, bytes, submessage_arena);
    }
    set_has_bytes();
    _impl_.type_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.bytes)
}
void FieldConstraints::set_allocated_enum_(::buf::validate::EnumRules* enum_) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (enum_) {
    ::google::protobuf::Arena* submessage_arena = enum_->GetArena();
    if (message_arena != submessage_arena) {
      enum_ = ::google::protobuf::internal::GetOwnedMessage(message_arena, enum_, submessage_arena);
    }
    set_has_enum_();
    _impl_.type_.enum__ = enum_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.enum)
}
void FieldConstraints::set_allocated_repeated(::buf::validate::RepeatedRules* repeated) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (repeated) {
    ::google::protobuf::Arena* submessage_arena = repeated->GetArena();
    if (message_arena != submessage_arena) {
      repeated = ::google::protobuf::internal::GetOwnedMessage(message_arena, repeated, submessage_arena);
    }
    set_has_repeated();
    _impl_.type_.repeated_ = repeated;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.repeated)
}
void FieldConstraints::set_allocated_map(::buf::validate::MapRules* map) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (map) {
    ::google::protobuf::Arena* submessage_arena = map->GetArena();
    if (message_arena != submessage_arena) {
      map = ::google::protobuf::internal::GetOwnedMessage(message_arena, map, submessage_arena);
    }
    set_has_map();
    _impl_.type_.map_ = map;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.map)
}
void FieldConstraints::set_allocated_any(::buf::validate::AnyRules* any) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (any) {
    ::google::protobuf::Arena* submessage_arena = any->GetArena();
    if (message_arena != submessage_arena) {
      any = ::google::protobuf::internal::GetOwnedMessage(message_arena, any, submessage_arena);
    }
    set_has_any();
    _impl_.type_.any_ = any;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.any)
}
void FieldConstraints::set_allocated_duration(::buf::validate::DurationRules* duration) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (duration) {
    ::google::protobuf::Arena* submessage_arena = duration->GetArena();
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(message_arena, duration, submessage_arena);
    }
    set_has_duration();
    _impl_.type_.duration_ = duration;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.duration)
}
void FieldConstraints::set_allocated_timestamp(::buf::validate::TimestampRules* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = timestamp->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(message_arena, timestamp, submessage_arena);
    }
    set_has_timestamp();
    _impl_.type_.timestamp_ = timestamp;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.timestamp)
}
FieldConstraints::FieldConstraints(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.FieldConstraints)
}
inline PROTOBUF_NDEBUG_INLINE FieldConstraints::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::FieldConstraints& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        cel_{visibility, arena, from.cel_},
        type_{},
        _oneof_case_{from._oneof_case_[0]} {}

FieldConstraints::FieldConstraints(
    ::google::protobuf::Arena* arena,
    const FieldConstraints& from)
    : ::google::protobuf::Message(arena) {
  FieldConstraints* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, required_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, required_),
           offsetof(Impl_, ignore_) -
               offsetof(Impl_, required_) +
               sizeof(Impl_::ignore_));
  switch (type_case()) {
    case TYPE_NOT_SET:
      break;
      case kFloat:
        _impl_.type_.float__ = ::google::protobuf::Message::CopyConstruct<::buf::validate::FloatRules>(arena, *from._impl_.type_.float__);
        break;
      case kDouble:
        _impl_.type_.double__ = ::google::protobuf::Message::CopyConstruct<::buf::validate::DoubleRules>(arena, *from._impl_.type_.double__);
        break;
      case kInt32:
        _impl_.type_.int32_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::Int32Rules>(arena, *from._impl_.type_.int32_);
        break;
      case kInt64:
        _impl_.type_.int64_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::Int64Rules>(arena, *from._impl_.type_.int64_);
        break;
      case kUint32:
        _impl_.type_.uint32_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::UInt32Rules>(arena, *from._impl_.type_.uint32_);
        break;
      case kUint64:
        _impl_.type_.uint64_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::UInt64Rules>(arena, *from._impl_.type_.uint64_);
        break;
      case kSint32:
        _impl_.type_.sint32_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::SInt32Rules>(arena, *from._impl_.type_.sint32_);
        break;
      case kSint64:
        _impl_.type_.sint64_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::SInt64Rules>(arena, *from._impl_.type_.sint64_);
        break;
      case kFixed32:
        _impl_.type_.fixed32_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::Fixed32Rules>(arena, *from._impl_.type_.fixed32_);
        break;
      case kFixed64:
        _impl_.type_.fixed64_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::Fixed64Rules>(arena, *from._impl_.type_.fixed64_);
        break;
      case kSfixed32:
        _impl_.type_.sfixed32_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::SFixed32Rules>(arena, *from._impl_.type_.sfixed32_);
        break;
      case kSfixed64:
        _impl_.type_.sfixed64_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::SFixed64Rules>(arena, *from._impl_.type_.sfixed64_);
        break;
      case kBool:
        _impl_.type_.bool__ = ::google::protobuf::Message::CopyConstruct<::buf::validate::BoolRules>(arena, *from._impl_.type_.bool__);
        break;
      case kString:
        _impl_.type_.string_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::StringRules>(arena, *from._impl_.type_.string_);
        break;
      case kBytes:
        _impl_.type_.bytes_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::BytesRules>(arena, *from._impl_.type_.bytes_);
        break;
      case kEnum:
        _impl_.type_.enum__ = ::google::protobuf::Message::CopyConstruct<::buf::validate::EnumRules>(arena, *from._impl_.type_.enum__);
        break;
      case kRepeated:
        _impl_.type_.repeated_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::RepeatedRules>(arena, *from._impl_.type_.repeated_);
        break;
      case kMap:
        _impl_.type_.map_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::MapRules>(arena, *from._impl_.type_.map_);
        break;
      case kAny:
        _impl_.type_.any_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::AnyRules>(arena, *from._impl_.type_.any_);
        break;
      case kDuration:
        _impl_.type_.duration_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::DurationRules>(arena, *from._impl_.type_.duration_);
        break;
      case kTimestamp:
        _impl_.type_.timestamp_ = ::google::protobuf::Message::CopyConstruct<::buf::validate::TimestampRules>(arena, *from._impl_.type_.timestamp_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.FieldConstraints)
}
inline PROTOBUF_NDEBUG_INLINE FieldConstraints::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        cel_{visibility, arena},
        type_{},
        _oneof_case_{} {}

inline void FieldConstraints::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, required_),
           0,
           offsetof(Impl_, ignore_) -
               offsetof(Impl_, required_) +
               sizeof(Impl_::ignore_));
}
FieldConstraints::~FieldConstraints() {
  // @@protoc_insertion_point(destructor:buf.validate.FieldConstraints)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void FieldConstraints::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_type()) {
    clear_type();
  }
  _impl_.~Impl_();
}

void FieldConstraints::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.FieldConstraints)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (type_case()) {
    case kFloat: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.float__;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.float__);
      }
      break;
    }
    case kDouble: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.double__;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.double__);
      }
      break;
    }
    case kInt32: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.int32_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.int32_);
      }
      break;
    }
    case kInt64: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.int64_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.int64_);
      }
      break;
    }
    case kUint32: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.uint32_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.uint32_);
      }
      break;
    }
    case kUint64: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.uint64_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.uint64_);
      }
      break;
    }
    case kSint32: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.sint32_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sint32_);
      }
      break;
    }
    case kSint64: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.sint64_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sint64_);
      }
      break;
    }
    case kFixed32: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.fixed32_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.fixed32_);
      }
      break;
    }
    case kFixed64: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.fixed64_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.fixed64_);
      }
      break;
    }
    case kSfixed32: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.sfixed32_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sfixed32_);
      }
      break;
    }
    case kSfixed64: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.sfixed64_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sfixed64_);
      }
      break;
    }
    case kBool: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.bool__;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.bool__);
      }
      break;
    }
    case kString: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.string_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.string_);
      }
      break;
    }
    case kBytes: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.bytes_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.bytes_);
      }
      break;
    }
    case kEnum: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.enum__;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.enum__);
      }
      break;
    }
    case kRepeated: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.repeated_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.repeated_);
      }
      break;
    }
    case kMap: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.map_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.map_);
      }
      break;
    }
    case kAny: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.any_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.any_);
      }
      break;
    }
    case kDuration: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.duration_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.duration_);
      }
      break;
    }
    case kTimestamp: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.timestamp_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.timestamp_);
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
FieldConstraints::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              FieldConstraints::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_._cached_size_),
              false,
          },
          &FieldConstraints::MergeImpl,
          &FieldConstraints::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 26, 23, 0, 2> FieldConstraints::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_._has_bits_),
    0, // no _extensions_
    27, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4160815104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    26,  // num_field_entries
    23,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_FieldConstraints_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::FieldConstraints>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool skipped = 24 [json_name = "skipped", deprecated = true];
    {::_pbi::TcParser::FastV8S2,
     {448, 1, 0, PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.skipped_)}},
    // optional bool required = 25 [json_name = "required"];
    {::_pbi::TcParser::FastV8S2,
     {456, 0, 0, PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.required_)}},
    // optional bool ignore_empty = 26 [json_name = "ignoreEmpty", deprecated = true];
    {::_pbi::TcParser::FastV8S2,
     {464, 2, 0, PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.ignore_empty_)}},
    // optional .buf.validate.Ignore ignore = 27 [json_name = "ignore"];
    {::_pbi::TcParser::FastEr0S2,
     {472, 3, 3, PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.ignore_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
    {::_pbi::TcParser::FastMtR2,
     {442, 63, 21, PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.cel_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .buf.validate.FloatRules float = 1 [json_name = "float"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.float__), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.DoubleRules double = 2 [json_name = "double"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.double__), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.Int32Rules int32 = 3 [json_name = "int32"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.int32_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.Int64Rules int64 = 4 [json_name = "int64"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.int64_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.UInt32Rules uint32 = 5 [json_name = "uint32"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.uint32_), _Internal::kOneofCaseOffset + 0, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.UInt64Rules uint64 = 6 [json_name = "uint64"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.uint64_), _Internal::kOneofCaseOffset + 0, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.SInt32Rules sint32 = 7 [json_name = "sint32"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.sint32_), _Internal::kOneofCaseOffset + 0, 6,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.SInt64Rules sint64 = 8 [json_name = "sint64"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.sint64_), _Internal::kOneofCaseOffset + 0, 7,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.Fixed32Rules fixed32 = 9 [json_name = "fixed32"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.fixed32_), _Internal::kOneofCaseOffset + 0, 8,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.Fixed64Rules fixed64 = 10 [json_name = "fixed64"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.fixed64_), _Internal::kOneofCaseOffset + 0, 9,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.SFixed32Rules sfixed32 = 11 [json_name = "sfixed32"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.sfixed32_), _Internal::kOneofCaseOffset + 0, 10,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.SFixed64Rules sfixed64 = 12 [json_name = "sfixed64"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.sfixed64_), _Internal::kOneofCaseOffset + 0, 11,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.BoolRules bool = 13 [json_name = "bool"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.bool__), _Internal::kOneofCaseOffset + 0, 12,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.StringRules string = 14 [json_name = "string"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.string_), _Internal::kOneofCaseOffset + 0, 13,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.BytesRules bytes = 15 [json_name = "bytes"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.bytes_), _Internal::kOneofCaseOffset + 0, 14,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.EnumRules enum = 16 [json_name = "enum"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.enum__), _Internal::kOneofCaseOffset + 0, 15,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.RepeatedRules repeated = 18 [json_name = "repeated"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.repeated_), _Internal::kOneofCaseOffset + 0, 16,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.MapRules map = 19 [json_name = "map"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.map_), _Internal::kOneofCaseOffset + 0, 17,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.AnyRules any = 20 [json_name = "any"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.any_), _Internal::kOneofCaseOffset + 0, 18,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.DurationRules duration = 21 [json_name = "duration"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.duration_), _Internal::kOneofCaseOffset + 0, 19,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.TimestampRules timestamp = 22 [json_name = "timestamp"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.timestamp_), _Internal::kOneofCaseOffset + 0, 20,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.cel_), -1, 21,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool skipped = 24 [json_name = "skipped", deprecated = true];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.skipped_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool required = 25 [json_name = "required"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.required_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool ignore_empty = 26 [json_name = "ignoreEmpty", deprecated = true];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.ignore_empty_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .buf.validate.Ignore ignore = 27 [json_name = "ignore"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.ignore_), _Internal::kHasBitsOffset + 3, 22,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }}, {{
    {::_pbi::TcParser::GetTable<::buf::validate::FloatRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::DoubleRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::Int32Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::Int64Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::UInt32Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::UInt64Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::SInt32Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::SInt64Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::Fixed32Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::Fixed64Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::SFixed32Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::SFixed64Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::BoolRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::StringRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::BytesRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::EnumRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::RepeatedRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::MapRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::AnyRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::DurationRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::TimestampRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::Constraint>()},
    {0, 4},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void FieldConstraints::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.FieldConstraints)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cel_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.required_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ignore_) -
        reinterpret_cast<char*>(&_impl_.required_)) + sizeof(_impl_.ignore_));
  }
  clear_type();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* FieldConstraints::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.FieldConstraints)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (type_case()) {
    case kFloat: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, *_impl_.type_.float__, _impl_.type_.float__->GetCachedSize(), target, stream);
      break;
    }
    case kDouble: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, *_impl_.type_.double__, _impl_.type_.double__->GetCachedSize(), target, stream);
      break;
    }
    case kInt32: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, *_impl_.type_.int32_, _impl_.type_.int32_->GetCachedSize(), target, stream);
      break;
    }
    case kInt64: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *_impl_.type_.int64_, _impl_.type_.int64_->GetCachedSize(), target, stream);
      break;
    }
    case kUint32: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *_impl_.type_.uint32_, _impl_.type_.uint32_->GetCachedSize(), target, stream);
      break;
    }
    case kUint64: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *_impl_.type_.uint64_, _impl_.type_.uint64_->GetCachedSize(), target, stream);
      break;
    }
    case kSint32: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          7, *_impl_.type_.sint32_, _impl_.type_.sint32_->GetCachedSize(), target, stream);
      break;
    }
    case kSint64: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          8, *_impl_.type_.sint64_, _impl_.type_.sint64_->GetCachedSize(), target, stream);
      break;
    }
    case kFixed32: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          9, *_impl_.type_.fixed32_, _impl_.type_.fixed32_->GetCachedSize(), target, stream);
      break;
    }
    case kFixed64: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          10, *_impl_.type_.fixed64_, _impl_.type_.fixed64_->GetCachedSize(), target, stream);
      break;
    }
    case kSfixed32: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          11, *_impl_.type_.sfixed32_, _impl_.type_.sfixed32_->GetCachedSize(), target, stream);
      break;
    }
    case kSfixed64: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          12, *_impl_.type_.sfixed64_, _impl_.type_.sfixed64_->GetCachedSize(), target, stream);
      break;
    }
    case kBool: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          13, *_impl_.type_.bool__, _impl_.type_.bool__->GetCachedSize(), target, stream);
      break;
    }
    case kString: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          14, *_impl_.type_.string_, _impl_.type_.string_->GetCachedSize(), target, stream);
      break;
    }
    case kBytes: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          15, *_impl_.type_.bytes_, _impl_.type_.bytes_->GetCachedSize(), target, stream);
      break;
    }
    case kEnum: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          16, *_impl_.type_.enum__, _impl_.type_.enum__->GetCachedSize(), target, stream);
      break;
    }
    case kRepeated: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          18, *_impl_.type_.repeated_, _impl_.type_.repeated_->GetCachedSize(), target, stream);
      break;
    }
    case kMap: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          19, *_impl_.type_.map_, _impl_.type_.map_->GetCachedSize(), target, stream);
      break;
    }
    case kAny: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          20, *_impl_.type_.any_, _impl_.type_.any_->GetCachedSize(), target, stream);
      break;
    }
    case kDuration: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          21, *_impl_.type_.duration_, _impl_.type_.duration_->GetCachedSize(), target, stream);
      break;
    }
    case kTimestamp: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          22, *_impl_.type_.timestamp_, _impl_.type_.timestamp_->GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this->_internal_cel_size());
       i < n; i++) {
    const auto& repfield = this->_internal_cel().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            23, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool skipped = 24 [json_name = "skipped", deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        24, this->_internal_skipped(), target);
  }

  // optional bool required = 25 [json_name = "required"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this->_internal_required(), target);
  }

  // optional bool ignore_empty = 26 [json_name = "ignoreEmpty", deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        26, this->_internal_ignore_empty(), target);
  }

  // optional .buf.validate.Ignore ignore = 27 [json_name = "ignore"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        27, this->_internal_ignore(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.FieldConstraints)
  return target;
}

::size_t FieldConstraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.FieldConstraints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
  total_size += 2UL * this->_internal_cel_size();
  for (const auto& msg : this->_internal_cel()) {
    total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool required = 25 [json_name = "required"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 3;
    }

    // optional bool skipped = 24 [json_name = "skipped", deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 3;
    }

    // optional bool ignore_empty = 26 [json_name = "ignoreEmpty", deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 3;
    }

    // optional .buf.validate.Ignore ignore = 27 [json_name = "ignore"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_ignore());
    }

  }
  switch (type_case()) {
    // .buf.validate.FloatRules float = 1 [json_name = "float"];
    case kFloat: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.float__);
      break;
    }
    // .buf.validate.DoubleRules double = 2 [json_name = "double"];
    case kDouble: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.double__);
      break;
    }
    // .buf.validate.Int32Rules int32 = 3 [json_name = "int32"];
    case kInt32: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.int32_);
      break;
    }
    // .buf.validate.Int64Rules int64 = 4 [json_name = "int64"];
    case kInt64: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.int64_);
      break;
    }
    // .buf.validate.UInt32Rules uint32 = 5 [json_name = "uint32"];
    case kUint32: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.uint32_);
      break;
    }
    // .buf.validate.UInt64Rules uint64 = 6 [json_name = "uint64"];
    case kUint64: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.uint64_);
      break;
    }
    // .buf.validate.SInt32Rules sint32 = 7 [json_name = "sint32"];
    case kSint32: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.sint32_);
      break;
    }
    // .buf.validate.SInt64Rules sint64 = 8 [json_name = "sint64"];
    case kSint64: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.sint64_);
      break;
    }
    // .buf.validate.Fixed32Rules fixed32 = 9 [json_name = "fixed32"];
    case kFixed32: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.fixed32_);
      break;
    }
    // .buf.validate.Fixed64Rules fixed64 = 10 [json_name = "fixed64"];
    case kFixed64: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.fixed64_);
      break;
    }
    // .buf.validate.SFixed32Rules sfixed32 = 11 [json_name = "sfixed32"];
    case kSfixed32: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.sfixed32_);
      break;
    }
    // .buf.validate.SFixed64Rules sfixed64 = 12 [json_name = "sfixed64"];
    case kSfixed64: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.sfixed64_);
      break;
    }
    // .buf.validate.BoolRules bool = 13 [json_name = "bool"];
    case kBool: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.bool__);
      break;
    }
    // .buf.validate.StringRules string = 14 [json_name = "string"];
    case kString: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.string_);
      break;
    }
    // .buf.validate.BytesRules bytes = 15 [json_name = "bytes"];
    case kBytes: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.bytes_);
      break;
    }
    // .buf.validate.EnumRules enum = 16 [json_name = "enum"];
    case kEnum: {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.enum__);
      break;
    }
    // .buf.validate.RepeatedRules repeated = 18 [json_name = "repeated"];
    case kRepeated: {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.repeated_);
      break;
    }
    // .buf.validate.MapRules map = 19 [json_name = "map"];
    case kMap: {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.map_);
      break;
    }
    // .buf.validate.AnyRules any = 20 [json_name = "any"];
    case kAny: {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.any_);
      break;
    }
    // .buf.validate.DurationRules duration = 21 [json_name = "duration"];
    case kDuration: {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.duration_);
      break;
    }
    // .buf.validate.TimestampRules timestamp = 22 [json_name = "timestamp"];
    case kTimestamp: {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.type_.timestamp_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void FieldConstraints::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<FieldConstraints*>(&to_msg);
  auto& from = static_cast<const FieldConstraints&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.FieldConstraints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_cel()->MergeFrom(
      from._internal_cel());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.required_ = from._impl_.required_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.skipped_ = from._impl_.skipped_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ignore_empty_ = from._impl_.ignore_empty_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ignore_ = from._impl_.ignore_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_type();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kFloat: {
        if (oneof_needs_init) {
          _this->_impl_.type_.float__ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::FloatRules>(arena, *from._impl_.type_.float__);
        } else {
          _this->_impl_.type_.float__->MergeFrom(from._internal_float_());
        }
        break;
      }
      case kDouble: {
        if (oneof_needs_init) {
          _this->_impl_.type_.double__ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::DoubleRules>(arena, *from._impl_.type_.double__);
        } else {
          _this->_impl_.type_.double__->MergeFrom(from._internal_double_());
        }
        break;
      }
      case kInt32: {
        if (oneof_needs_init) {
          _this->_impl_.type_.int32_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::Int32Rules>(arena, *from._impl_.type_.int32_);
        } else {
          _this->_impl_.type_.int32_->MergeFrom(from._internal_int32());
        }
        break;
      }
      case kInt64: {
        if (oneof_needs_init) {
          _this->_impl_.type_.int64_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::Int64Rules>(arena, *from._impl_.type_.int64_);
        } else {
          _this->_impl_.type_.int64_->MergeFrom(from._internal_int64());
        }
        break;
      }
      case kUint32: {
        if (oneof_needs_init) {
          _this->_impl_.type_.uint32_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::UInt32Rules>(arena, *from._impl_.type_.uint32_);
        } else {
          _this->_impl_.type_.uint32_->MergeFrom(from._internal_uint32());
        }
        break;
      }
      case kUint64: {
        if (oneof_needs_init) {
          _this->_impl_.type_.uint64_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::UInt64Rules>(arena, *from._impl_.type_.uint64_);
        } else {
          _this->_impl_.type_.uint64_->MergeFrom(from._internal_uint64());
        }
        break;
      }
      case kSint32: {
        if (oneof_needs_init) {
          _this->_impl_.type_.sint32_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::SInt32Rules>(arena, *from._impl_.type_.sint32_);
        } else {
          _this->_impl_.type_.sint32_->MergeFrom(from._internal_sint32());
        }
        break;
      }
      case kSint64: {
        if (oneof_needs_init) {
          _this->_impl_.type_.sint64_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::SInt64Rules>(arena, *from._impl_.type_.sint64_);
        } else {
          _this->_impl_.type_.sint64_->MergeFrom(from._internal_sint64());
        }
        break;
      }
      case kFixed32: {
        if (oneof_needs_init) {
          _this->_impl_.type_.fixed32_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::Fixed32Rules>(arena, *from._impl_.type_.fixed32_);
        } else {
          _this->_impl_.type_.fixed32_->MergeFrom(from._internal_fixed32());
        }
        break;
      }
      case kFixed64: {
        if (oneof_needs_init) {
          _this->_impl_.type_.fixed64_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::Fixed64Rules>(arena, *from._impl_.type_.fixed64_);
        } else {
          _this->_impl_.type_.fixed64_->MergeFrom(from._internal_fixed64());
        }
        break;
      }
      case kSfixed32: {
        if (oneof_needs_init) {
          _this->_impl_.type_.sfixed32_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::SFixed32Rules>(arena, *from._impl_.type_.sfixed32_);
        } else {
          _this->_impl_.type_.sfixed32_->MergeFrom(from._internal_sfixed32());
        }
        break;
      }
      case kSfixed64: {
        if (oneof_needs_init) {
          _this->_impl_.type_.sfixed64_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::SFixed64Rules>(arena, *from._impl_.type_.sfixed64_);
        } else {
          _this->_impl_.type_.sfixed64_->MergeFrom(from._internal_sfixed64());
        }
        break;
      }
      case kBool: {
        if (oneof_needs_init) {
          _this->_impl_.type_.bool__ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::BoolRules>(arena, *from._impl_.type_.bool__);
        } else {
          _this->_impl_.type_.bool__->MergeFrom(from._internal_bool_());
        }
        break;
      }
      case kString: {
        if (oneof_needs_init) {
          _this->_impl_.type_.string_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::StringRules>(arena, *from._impl_.type_.string_);
        } else {
          _this->_impl_.type_.string_->MergeFrom(from._internal_string());
        }
        break;
      }
      case kBytes: {
        if (oneof_needs_init) {
          _this->_impl_.type_.bytes_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::BytesRules>(arena, *from._impl_.type_.bytes_);
        } else {
          _this->_impl_.type_.bytes_->MergeFrom(from._internal_bytes());
        }
        break;
      }
      case kEnum: {
        if (oneof_needs_init) {
          _this->_impl_.type_.enum__ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::EnumRules>(arena, *from._impl_.type_.enum__);
        } else {
          _this->_impl_.type_.enum__->MergeFrom(from._internal_enum_());
        }
        break;
      }
      case kRepeated: {
        if (oneof_needs_init) {
          _this->_impl_.type_.repeated_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::RepeatedRules>(arena, *from._impl_.type_.repeated_);
        } else {
          _this->_impl_.type_.repeated_->MergeFrom(from._internal_repeated());
        }
        break;
      }
      case kMap: {
        if (oneof_needs_init) {
          _this->_impl_.type_.map_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::MapRules>(arena, *from._impl_.type_.map_);
        } else {
          _this->_impl_.type_.map_->MergeFrom(from._internal_map());
        }
        break;
      }
      case kAny: {
        if (oneof_needs_init) {
          _this->_impl_.type_.any_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::AnyRules>(arena, *from._impl_.type_.any_);
        } else {
          _this->_impl_.type_.any_->MergeFrom(from._internal_any());
        }
        break;
      }
      case kDuration: {
        if (oneof_needs_init) {
          _this->_impl_.type_.duration_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::DurationRules>(arena, *from._impl_.type_.duration_);
        } else {
          _this->_impl_.type_.duration_->MergeFrom(from._internal_duration());
        }
        break;
      }
      case kTimestamp: {
        if (oneof_needs_init) {
          _this->_impl_.type_.timestamp_ =
              ::google::protobuf::Message::CopyConstruct<::buf::validate::TimestampRules>(arena, *from._impl_.type_.timestamp_);
        } else {
          _this->_impl_.type_.timestamp_->MergeFrom(from._internal_timestamp());
        }
        break;
      }
      case TYPE_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FieldConstraints::CopyFrom(const FieldConstraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.FieldConstraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool FieldConstraints::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const FieldConstraints&>(msg);
  switch (this_.type_case()) {
    case kFloat: {
      if (this_.type_case() == kFloat && !this_._impl_.type_.float__->IsInitialized())
        return false;
      break;
    }
    case kDouble: {
      if (this_.type_case() == kDouble && !this_._impl_.type_.double__->IsInitialized())
        return false;
      break;
    }
    case kInt32: {
      if (this_.type_case() == kInt32 && !this_._impl_.type_.int32_->IsInitialized())
        return false;
      break;
    }
    case kInt64: {
      if (this_.type_case() == kInt64 && !this_._impl_.type_.int64_->IsInitialized())
        return false;
      break;
    }
    case kUint32: {
      if (this_.type_case() == kUint32 && !this_._impl_.type_.uint32_->IsInitialized())
        return false;
      break;
    }
    case kUint64: {
      if (this_.type_case() == kUint64 && !this_._impl_.type_.uint64_->IsInitialized())
        return false;
      break;
    }
    case kSint32: {
      if (this_.type_case() == kSint32 && !this_._impl_.type_.sint32_->IsInitialized())
        return false;
      break;
    }
    case kSint64: {
      if (this_.type_case() == kSint64 && !this_._impl_.type_.sint64_->IsInitialized())
        return false;
      break;
    }
    case kFixed32: {
      if (this_.type_case() == kFixed32 && !this_._impl_.type_.fixed32_->IsInitialized())
        return false;
      break;
    }
    case kFixed64: {
      if (this_.type_case() == kFixed64 && !this_._impl_.type_.fixed64_->IsInitialized())
        return false;
      break;
    }
    case kSfixed32: {
      if (this_.type_case() == kSfixed32 && !this_._impl_.type_.sfixed32_->IsInitialized())
        return false;
      break;
    }
    case kSfixed64: {
      if (this_.type_case() == kSfixed64 && !this_._impl_.type_.sfixed64_->IsInitialized())
        return false;
      break;
    }
    case kBool: {
      if (this_.type_case() == kBool && !this_._impl_.type_.bool__->IsInitialized())
        return false;
      break;
    }
    case kString: {
      if (this_.type_case() == kString && !this_._impl_.type_.string_->IsInitialized())
        return false;
      break;
    }
    case kBytes: {
      if (this_.type_case() == kBytes && !this_._impl_.type_.bytes_->IsInitialized())
        return false;
      break;
    }
    case kEnum: {
      if (this_.type_case() == kEnum && !this_._impl_.type_.enum__->IsInitialized())
        return false;
      break;
    }
    case kRepeated: {
      if (this_.type_case() == kRepeated && !this_._impl_.type_.repeated_->IsInitialized())
        return false;
      break;
    }
    case kMap: {
      if (this_.type_case() == kMap && !this_._impl_.type_.map_->IsInitialized())
        return false;
      break;
    }
    case kAny: {
      break;
    }
    case kDuration: {
      if (this_.type_case() == kDuration && !this_._impl_.type_.duration_->IsInitialized())
        return false;
      break;
    }
    case kTimestamp: {
      if (this_.type_case() == kTimestamp && !this_._impl_.type_.timestamp_->IsInitialized())
        return false;
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return true;
}

void FieldConstraints::InternalSwap(FieldConstraints* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.cel_.InternalSwap(&other->_impl_.cel_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.ignore_)
      + sizeof(FieldConstraints::_impl_.ignore_)
      - PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.required_)>(
          reinterpret_cast<char*>(&_impl_.required_),
          reinterpret_cast<char*>(&other->_impl_.required_));
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata FieldConstraints::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PredefinedConstraints::_Internal {
 public:
};

PredefinedConstraints::PredefinedConstraints(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.PredefinedConstraints)
}
inline PROTOBUF_NDEBUG_INLINE PredefinedConstraints::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::PredefinedConstraints& from_msg)
      : cel_{visibility, arena, from.cel_},
        _cached_size_{0} {}

PredefinedConstraints::PredefinedConstraints(
    ::google::protobuf::Arena* arena,
    const PredefinedConstraints& from)
    : ::google::protobuf::Message(arena) {
  PredefinedConstraints* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:buf.validate.PredefinedConstraints)
}
inline PROTOBUF_NDEBUG_INLINE PredefinedConstraints::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : cel_{visibility, arena},
        _cached_size_{0} {}

inline void PredefinedConstraints::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PredefinedConstraints::~PredefinedConstraints() {
  // @@protoc_insertion_point(destructor:buf.validate.PredefinedConstraints)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void PredefinedConstraints::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

const ::google::protobuf::MessageLite::ClassData*
PredefinedConstraints::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              nullptr,  // IsInitialized
              PROTOBUF_FIELD_OFFSET(PredefinedConstraints, _impl_._cached_size_),
              false,
          },
          &PredefinedConstraints::MergeImpl,
          &PredefinedConstraints::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> PredefinedConstraints::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_PredefinedConstraints_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::PredefinedConstraints>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .buf.validate.Constraint cel = 1 [json_name = "cel"];
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(PredefinedConstraints, _impl_.cel_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .buf.validate.Constraint cel = 1 [json_name = "cel"];
    {PROTOBUF_FIELD_OFFSET(PredefinedConstraints, _impl_.cel_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::buf::validate::Constraint>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void PredefinedConstraints::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.PredefinedConstraints)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cel_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* PredefinedConstraints::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.PredefinedConstraints)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .buf.validate.Constraint cel = 1 [json_name = "cel"];
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this->_internal_cel_size());
       i < n; i++) {
    const auto& repfield = this->_internal_cel().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            1, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.PredefinedConstraints)
  return target;
}

::size_t PredefinedConstraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.PredefinedConstraints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated .buf.validate.Constraint cel = 1 [json_name = "cel"];
  total_size += 1UL * this->_internal_cel_size();
  for (const auto& msg : this->_internal_cel()) {
    total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void PredefinedConstraints::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PredefinedConstraints*>(&to_msg);
  auto& from = static_cast<const PredefinedConstraints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.PredefinedConstraints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_cel()->MergeFrom(
      from._internal_cel());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PredefinedConstraints::CopyFrom(const PredefinedConstraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.PredefinedConstraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PredefinedConstraints::InternalSwap(PredefinedConstraints* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.cel_.InternalSwap(&other->_impl_.cel_);
}

::google::protobuf::Metadata PredefinedConstraints::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class FloatRules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<FloatRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(FloatRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_._oneof_case_);
};

FloatRules::FloatRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.FloatRules)
}
inline PROTOBUF_NDEBUG_INLINE FloatRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::FloatRules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

FloatRules::FloatRules(
    ::google::protobuf::Arena* arena,
    const FloatRules& from)
    : ::google::protobuf::Message(arena) {
  FloatRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, finite_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::finite_));
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.FloatRules)
}
inline PROTOBUF_NDEBUG_INLINE FloatRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void FloatRules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, finite_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::finite_));
}
FloatRules::~FloatRules() {
  // @@protoc_insertion_point(destructor:buf.validate.FloatRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void FloatRules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void FloatRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.FloatRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void FloatRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.FloatRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
FloatRules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              FloatRules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(FloatRules, _impl_._cached_size_),
              false,
          },
          &FloatRules::MergeImpl,
          &FloatRules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 0, 0, 2> FloatRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FloatRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(FloatRules, _impl_._extensions_),
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_FloatRules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::FloatRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional float const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.const__)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated float in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32R1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.in_)}},
    // repeated float not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32R1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.not_in_)}},
    // optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(FloatRules, _impl_.finite_), 1>(),
     {64, 1, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.finite_)}},
    // repeated float example = 9 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32R1,
     {77, 63, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.example_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional float const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // repeated float in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFloat)},
    // repeated float not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFloat)},
    // optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.finite_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated float example = 9 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void FloatRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.FloatRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.finite_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.finite_));
  }
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* FloatRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.FloatRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated float in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated float not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_finite(), target);
  }

  // repeated float example = 9 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.FloatRules)
  return target;
}

::size_t FloatRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.FloatRules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated float in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated float not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated float example = 9 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_example_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float const = 1 [json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 5;
    }

    // optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

  }
  switch (less_than_case()) {
    // float lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 5;
      break;
    }
    // float lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 5;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // float gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 5;
      break;
    }
    // float gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 5;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void FloatRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<FloatRules*>(&to_msg);
  auto& from = static_cast<const FloatRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.FloatRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.finite_ = from._impl_.finite_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FloatRules::CopyFrom(const FloatRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.FloatRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool FloatRules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const FloatRules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void FloatRules::InternalSwap(FloatRules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.finite_)
      + sizeof(FloatRules::_impl_.finite_)
      - PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata FloatRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DoubleRules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<DoubleRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_._oneof_case_);
};

DoubleRules::DoubleRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.DoubleRules)
}
inline PROTOBUF_NDEBUG_INLINE DoubleRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::DoubleRules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

DoubleRules::DoubleRules(
    ::google::protobuf::Arena* arena,
    const DoubleRules& from)
    : ::google::protobuf::Message(arena) {
  DoubleRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, finite_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::finite_));
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.DoubleRules)
}
inline PROTOBUF_NDEBUG_INLINE DoubleRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void DoubleRules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, finite_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::finite_));
}
DoubleRules::~DoubleRules() {
  // @@protoc_insertion_point(destructor:buf.validate.DoubleRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void DoubleRules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void DoubleRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DoubleRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void DoubleRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DoubleRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
DoubleRules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              DoubleRules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_._cached_size_),
              false,
          },
          &DoubleRules::MergeImpl,
          &DoubleRules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 0, 0, 2> DoubleRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_._extensions_),
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_DoubleRules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::DoubleRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.const__)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated double in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64R1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.in_)}},
    // repeated double not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64R1,
     {57, 63, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.not_in_)}},
    // optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DoubleRules, _impl_.finite_), 1>(),
     {64, 1, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.finite_)}},
    // repeated double example = 9 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64R1,
     {73, 63, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.example_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // double lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
    // double lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
    // double gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
    // double gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
    // repeated double in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // repeated double not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
    // optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.finite_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated double example = 9 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void DoubleRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.DoubleRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.finite_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.finite_));
  }
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* DoubleRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.DoubleRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated double in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated double not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_finite(), target);
  }

  // repeated double example = 9 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.DoubleRules)
  return target;
}

::size_t DoubleRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.DoubleRules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated double in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated double not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated double example = 9 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_example_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double const = 1 [json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

  }
  switch (less_than_case()) {
    // double lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 9;
      break;
    }
    // double lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 9;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // double gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 9;
      break;
    }
    // double gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 9;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void DoubleRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<DoubleRules*>(&to_msg);
  auto& from = static_cast<const DoubleRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.DoubleRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.finite_ = from._impl_.finite_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DoubleRules::CopyFrom(const DoubleRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.DoubleRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DoubleRules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const DoubleRules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void DoubleRules::InternalSwap(DoubleRules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.finite_)
      + sizeof(DoubleRules::_impl_.finite_)
      - PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata DoubleRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Int32Rules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Int32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_._oneof_case_);
};

Int32Rules::Int32Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Int32Rules)
}
inline PROTOBUF_NDEBUG_INLINE Int32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::Int32Rules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

Int32Rules::Int32Rules(
    ::google::protobuf::Arena* arena,
    const Int32Rules& from)
    : ::google::protobuf::Message(arena) {
  Int32Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  _impl_.const__ = from._impl_.const__;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.Int32Rules)
}
inline PROTOBUF_NDEBUG_INLINE Int32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void Int32Rules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
Int32Rules::~Int32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Int32Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Int32Rules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void Int32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Int32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
Int32Rules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              Int32Rules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_._cached_size_),
              false,
          },
          &Int32Rules::MergeImpl,
          &Int32Rules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 0, 0, 2> Int32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_._extensions_),
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Int32Rules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::Int32Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV32R1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.example_)}},
    // optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Int32Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.const__)}},
    // repeated int32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV32R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.in_)}},
    // repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV32R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt32)},
    // int32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt32)},
    // int32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt32)},
    // int32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt32)},
    // repeated int32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
    // repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
    // repeated int32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void Int32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Int32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  _impl_.const__ = 0;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* Int32Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Int32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt32ToArrayWithField<2>(
              stream, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt32ToArrayWithField<3>(
              stream, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt32ToArrayWithField<4>(
              stream, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt32ToArrayWithField<5>(
              stream, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated int32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // repeated int32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Int32Rules)
  return target;
}

::size_t Int32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Int32Rules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated int32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_not_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated int32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_example())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // int32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_lt());
      break;
    }
    // int32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // int32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_gt());
      break;
    }
    // int32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void Int32Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Int32Rules*>(&to_msg);
  auto& from = static_cast<const Int32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Int32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Int32Rules::CopyFrom(const Int32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Int32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Int32Rules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const Int32Rules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void Int32Rules::InternalSwap(Int32Rules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata Int32Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Int64Rules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Int64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_._oneof_case_);
};

Int64Rules::Int64Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Int64Rules)
}
inline PROTOBUF_NDEBUG_INLINE Int64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::Int64Rules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

Int64Rules::Int64Rules(
    ::google::protobuf::Arena* arena,
    const Int64Rules& from)
    : ::google::protobuf::Message(arena) {
  Int64Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  _impl_.const__ = from._impl_.const__;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.Int64Rules)
}
inline PROTOBUF_NDEBUG_INLINE Int64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void Int64Rules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
Int64Rules::~Int64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Int64Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Int64Rules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void Int64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Int64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
Int64Rules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              Int64Rules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_._cached_size_),
              false,
          },
          &Int64Rules::MergeImpl,
          &Int64Rules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 8, 0, 0, 2> Int64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_._extensions_),
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966912,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Int64Rules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::Int64Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Int64Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.const__)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated int64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV64R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.in_)}},
    // repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV64R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.not_in_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated int64 example = 9 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV64R1,
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.example_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt64)},
    // int64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt64)},
    // int64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt64)},
    // int64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt64)},
    // repeated int64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt64)},
    // repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt64)},
    // repeated int64 example = 9 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt64)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void Int64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Int64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  _impl_.const__ = ::int64_t{0};
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* Int64Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Int64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt64ToArrayWithField<2>(
              stream, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt64ToArrayWithField<3>(
              stream, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt64ToArrayWithField<4>(
              stream, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt64ToArrayWithField<5>(
              stream, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated int64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // repeated int64 example = 9 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        9, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Int64Rules)
  return target;
}

::size_t Int64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Int64Rules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated int64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_not_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated int64 example = 9 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_example())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional int64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // int64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_lt());
      break;
    }
    // int64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // int64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_gt());
      break;
    }
    // int64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void Int64Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Int64Rules*>(&to_msg);
  auto& from = static_cast<const Int64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Int64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Int64Rules::CopyFrom(const Int64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Int64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Int64Rules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const Int64Rules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void Int64Rules::InternalSwap(Int64Rules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata Int64Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UInt32Rules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<UInt32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_._oneof_case_);
};

UInt32Rules::UInt32Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.UInt32Rules)
}
inline PROTOBUF_NDEBUG_INLINE UInt32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::UInt32Rules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

UInt32Rules::UInt32Rules(
    ::google::protobuf::Arena* arena,
    const UInt32Rules& from)
    : ::google::protobuf::Message(arena) {
  UInt32Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  _impl_.const__ = from._impl_.const__;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.UInt32Rules)
}
inline PROTOBUF_NDEBUG_INLINE UInt32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void UInt32Rules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
UInt32Rules::~UInt32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.UInt32Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void UInt32Rules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void UInt32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void UInt32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
UInt32Rules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              UInt32Rules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_._cached_size_),
              false,
          },
          &UInt32Rules::MergeImpl,
          &UInt32Rules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 0, 0, 2> UInt32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_._extensions_),
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_UInt32Rules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::UInt32Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated uint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV32R1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.example_)}},
    // optional uint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UInt32Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.const__)}},
    // repeated uint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV32R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.in_)}},
    // repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV32R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // repeated uint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void UInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.UInt32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  _impl_.const__ = 0u;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* UInt32Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.UInt32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated uint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // repeated uint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.UInt32Rules)
  return target;
}

::size_t UInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.UInt32Rules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated uint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_not_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated uint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_example())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional uint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // uint32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lt());
      break;
    }
    // uint32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // uint32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gt());
      break;
    }
    // uint32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void UInt32Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UInt32Rules*>(&to_msg);
  auto& from = static_cast<const UInt32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.UInt32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UInt32Rules::CopyFrom(const UInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.UInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UInt32Rules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const UInt32Rules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void UInt32Rules::InternalSwap(UInt32Rules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata UInt32Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UInt64Rules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<UInt64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_._oneof_case_);
};

UInt64Rules::UInt64Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.UInt64Rules)
}
inline PROTOBUF_NDEBUG_INLINE UInt64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::UInt64Rules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

UInt64Rules::UInt64Rules(
    ::google::protobuf::Arena* arena,
    const UInt64Rules& from)
    : ::google::protobuf::Message(arena) {
  UInt64Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  _impl_.const__ = from._impl_.const__;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.UInt64Rules)
}
inline PROTOBUF_NDEBUG_INLINE UInt64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void UInt64Rules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
UInt64Rules::~UInt64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.UInt64Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void UInt64Rules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void UInt64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void UInt64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
UInt64Rules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              UInt64Rules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_._cached_size_),
              false,
          },
          &UInt64Rules::MergeImpl,
          &UInt64Rules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 0, 0, 2> UInt64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_._extensions_),
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_UInt64Rules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::UInt64Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated uint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV64R1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.example_)}},
    // optional uint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(UInt64Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.const__)}},
    // repeated uint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV64R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.in_)}},
    // repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV64R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // uint64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt64)},
    // uint64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt64)},
    // uint64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt64)},
    // uint64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt64)},
    // repeated uint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt64)},
    // repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt64)},
    // repeated uint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void UInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.UInt64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  _impl_.const__ = ::uint64_t{0u};
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* UInt64Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.UInt64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated uint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // repeated uint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.UInt64Rules)
  return target;
}

::size_t UInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.UInt64Rules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated uint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_not_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated uint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_example())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional uint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // uint64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_lt());
      break;
    }
    // uint64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // uint64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_gt());
      break;
    }
    // uint64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void UInt64Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UInt64Rules*>(&to_msg);
  auto& from = static_cast<const UInt64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.UInt64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UInt64Rules::CopyFrom(const UInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.UInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UInt64Rules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const UInt64Rules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void UInt64Rules::InternalSwap(UInt64Rules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata UInt64Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SInt32Rules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SInt32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_._oneof_case_);
};

SInt32Rules::SInt32Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SInt32Rules)
}
inline PROTOBUF_NDEBUG_INLINE SInt32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::SInt32Rules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

SInt32Rules::SInt32Rules(
    ::google::protobuf::Arena* arena,
    const SInt32Rules& from)
    : ::google::protobuf::Message(arena) {
  SInt32Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  _impl_.const__ = from._impl_.const__;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.SInt32Rules)
}
inline PROTOBUF_NDEBUG_INLINE SInt32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void SInt32Rules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
SInt32Rules::~SInt32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SInt32Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SInt32Rules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void SInt32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SInt32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
SInt32Rules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              SInt32Rules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_._cached_size_),
              false,
          },
          &SInt32Rules::MergeImpl,
          &SInt32Rules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 0, 0, 2> SInt32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_._extensions_),
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SInt32Rules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::SInt32Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated sint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastZ32R1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.example_)}},
    // optional sint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastZ32S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.const__)}},
    // repeated sint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastZ32R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.in_)}},
    // repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastZ32R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt32)},
    // sint32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt32)},
    // sint32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt32)},
    // sint32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt32)},
    // sint32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt32)},
    // repeated sint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSInt32)},
    // repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSInt32)},
    // repeated sint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void SInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SInt32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  _impl_.const__ = 0;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* SInt32Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SInt32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated sint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // repeated sint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        8, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SInt32Rules)
  return target;
}

::size_t SInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SInt32Rules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated sint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::SInt32Size(
        this->_internal_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::SInt32Size(
        this->_internal_not_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated sint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::SInt32Size(
        this->_internal_example())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional sint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // sint32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this->_internal_lt());
      break;
    }
    // sint32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sint32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this->_internal_gt());
      break;
    }
    // sint32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void SInt32Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SInt32Rules*>(&to_msg);
  auto& from = static_cast<const SInt32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SInt32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SInt32Rules::CopyFrom(const SInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SInt32Rules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const SInt32Rules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void SInt32Rules::InternalSwap(SInt32Rules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata SInt32Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SInt64Rules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SInt64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_._oneof_case_);
};

SInt64Rules::SInt64Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SInt64Rules)
}
inline PROTOBUF_NDEBUG_INLINE SInt64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::SInt64Rules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

SInt64Rules::SInt64Rules(
    ::google::protobuf::Arena* arena,
    const SInt64Rules& from)
    : ::google::protobuf::Message(arena) {
  SInt64Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  _impl_.const__ = from._impl_.const__;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.SInt64Rules)
}
inline PROTOBUF_NDEBUG_INLINE SInt64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void SInt64Rules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
SInt64Rules::~SInt64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SInt64Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SInt64Rules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void SInt64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SInt64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
SInt64Rules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              SInt64Rules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_._cached_size_),
              false,
          },
          &SInt64Rules::MergeImpl,
          &SInt64Rules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 0, 0, 2> SInt64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_._extensions_),
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SInt64Rules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::SInt64Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated sint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastZ64R1,
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.example_)}},
    // optional sint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastZ64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.const__)}},
    // repeated sint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastZ64R1,
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.in_)}},
    // repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastZ64R1,
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt64)},
    // sint64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt64)},
    // sint64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt64)},
    // sint64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt64)},
    // sint64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt64)},
    // repeated sint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSInt64)},
    // repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSInt64)},
    // repeated sint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSInt64)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void SInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SInt64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  _impl_.const__ = ::int64_t{0};
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* SInt64Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SInt64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated sint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // repeated sint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        8, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SInt64Rules)
  return target;
}

::size_t SInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SInt64Rules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated sint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::SInt64Size(
        this->_internal_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::SInt64Size(
        this->_internal_not_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated sint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::SInt64Size(
        this->_internal_example())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional sint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // sint64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this->_internal_lt());
      break;
    }
    // sint64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sint64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this->_internal_gt());
      break;
    }
    // sint64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void SInt64Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SInt64Rules*>(&to_msg);
  auto& from = static_cast<const SInt64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SInt64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SInt64Rules::CopyFrom(const SInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SInt64Rules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const SInt64Rules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void SInt64Rules::InternalSwap(SInt64Rules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata SInt64Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Fixed32Rules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Fixed32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_._oneof_case_);
};

Fixed32Rules::Fixed32Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Fixed32Rules)
}
inline PROTOBUF_NDEBUG_INLINE Fixed32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::Fixed32Rules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

Fixed32Rules::Fixed32Rules(
    ::google::protobuf::Arena* arena,
    const Fixed32Rules& from)
    : ::google::protobuf::Message(arena) {
  Fixed32Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  _impl_.const__ = from._impl_.const__;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.Fixed32Rules)
}
inline PROTOBUF_NDEBUG_INLINE Fixed32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void Fixed32Rules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
Fixed32Rules::~Fixed32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Fixed32Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Fixed32Rules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void Fixed32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Fixed32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
Fixed32Rules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              Fixed32Rules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_._cached_size_),
              false,
          },
          &Fixed32Rules::MergeImpl,
          &Fixed32Rules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 0, 0, 2> Fixed32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_._extensions_),
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Fixed32Rules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::Fixed32Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated fixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32R1,
     {69, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.example_)}},
    // optional fixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.const__)}},
    // repeated fixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32R1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.in_)}},
    // repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32R1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional fixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // fixed32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed32)},
    // fixed32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed32)},
    // fixed32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed32)},
    // fixed32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed32)},
    // repeated fixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFixed32)},
    // repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFixed32)},
    // repeated fixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFixed32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void Fixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Fixed32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  _impl_.const__ = 0u;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* Fixed32Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Fixed32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated fixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // repeated fixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        8, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Fixed32Rules)
  return target;
}

::size_t Fixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Fixed32Rules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated fixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated fixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_example_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional fixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 5;
  }

  switch (less_than_case()) {
    // fixed32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 5;
      break;
    }
    // fixed32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 5;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // fixed32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 5;
      break;
    }
    // fixed32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 5;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void Fixed32Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Fixed32Rules*>(&to_msg);
  auto& from = static_cast<const Fixed32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Fixed32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Fixed32Rules::CopyFrom(const Fixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Fixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Fixed32Rules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const Fixed32Rules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void Fixed32Rules::InternalSwap(Fixed32Rules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata Fixed32Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Fixed64Rules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Fixed64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_._oneof_case_);
};

Fixed64Rules::Fixed64Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Fixed64Rules)
}
inline PROTOBUF_NDEBUG_INLINE Fixed64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::Fixed64Rules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

Fixed64Rules::Fixed64Rules(
    ::google::protobuf::Arena* arena,
    const Fixed64Rules& from)
    : ::google::protobuf::Message(arena) {
  Fixed64Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  _impl_.const__ = from._impl_.const__;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.Fixed64Rules)
}
inline PROTOBUF_NDEBUG_INLINE Fixed64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void Fixed64Rules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
Fixed64Rules::~Fixed64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Fixed64Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Fixed64Rules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void Fixed64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Fixed64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
Fixed64Rules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              Fixed64Rules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_._cached_size_),
              false,
          },
          &Fixed64Rules::MergeImpl,
          &Fixed64Rules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 0, 0, 2> Fixed64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_._extensions_),
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Fixed64Rules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::Fixed64Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated fixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64R1,
     {65, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.example_)}},
    // optional fixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.const__)}},
    // repeated fixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64R1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.in_)}},
    // repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64R1,
     {57, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional fixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // fixed64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed64)},
    // fixed64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed64)},
    // fixed64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed64)},
    // fixed64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed64)},
    // repeated fixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFixed64)},
    // repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFixed64)},
    // repeated fixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kFixed64)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void Fixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Fixed64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  _impl_.const__ = ::uint64_t{0u};
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* Fixed64Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Fixed64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated fixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // repeated fixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        8, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Fixed64Rules)
  return target;
}

::size_t Fixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Fixed64Rules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated fixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated fixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_example_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional fixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 9;
  }

  switch (less_than_case()) {
    // fixed64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 9;
      break;
    }
    // fixed64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 9;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // fixed64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 9;
      break;
    }
    // fixed64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 9;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void Fixed64Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Fixed64Rules*>(&to_msg);
  auto& from = static_cast<const Fixed64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Fixed64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Fixed64Rules::CopyFrom(const Fixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Fixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Fixed64Rules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const Fixed64Rules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void Fixed64Rules::InternalSwap(Fixed64Rules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata Fixed64Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SFixed32Rules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SFixed32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_._oneof_case_);
};

SFixed32Rules::SFixed32Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SFixed32Rules)
}
inline PROTOBUF_NDEBUG_INLINE SFixed32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::SFixed32Rules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

SFixed32Rules::SFixed32Rules(
    ::google::protobuf::Arena* arena,
    const SFixed32Rules& from)
    : ::google::protobuf::Message(arena) {
  SFixed32Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  _impl_.const__ = from._impl_.const__;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.SFixed32Rules)
}
inline PROTOBUF_NDEBUG_INLINE SFixed32Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void SFixed32Rules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
SFixed32Rules::~SFixed32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SFixed32Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SFixed32Rules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void SFixed32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SFixed32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
SFixed32Rules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              SFixed32Rules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_._cached_size_),
              false,
          },
          &SFixed32Rules::MergeImpl,
          &SFixed32Rules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 0, 0, 2> SFixed32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_._extensions_),
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SFixed32Rules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::SFixed32Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated sfixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32R1,
     {69, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.example_)}},
    // optional sfixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.const__)}},
    // repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32R1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.in_)}},
    // repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF32R1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sfixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed32)},
    // sfixed32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed32)},
    // sfixed32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed32)},
    // sfixed32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed32)},
    // sfixed32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed32)},
    // repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSFixed32)},
    // repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSFixed32)},
    // repeated sfixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSFixed32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void SFixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SFixed32Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  _impl_.const__ = 0;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* SFixed32Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SFixed32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sfixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // repeated sfixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        8, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SFixed32Rules)
  return target;
}

::size_t SFixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SFixed32Rules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated sfixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_example_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional sfixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 5;
  }

  switch (less_than_case()) {
    // sfixed32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 5;
      break;
    }
    // sfixed32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 5;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sfixed32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 5;
      break;
    }
    // sfixed32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 5;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void SFixed32Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SFixed32Rules*>(&to_msg);
  auto& from = static_cast<const SFixed32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SFixed32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SFixed32Rules::CopyFrom(const SFixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SFixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SFixed32Rules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const SFixed32Rules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void SFixed32Rules::InternalSwap(SFixed32Rules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata SFixed32Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SFixed64Rules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SFixed64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_._oneof_case_);
};

SFixed64Rules::SFixed64Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SFixed64Rules)
}
inline PROTOBUF_NDEBUG_INLINE SFixed64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::SFixed64Rules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

SFixed64Rules::SFixed64Rules(
    ::google::protobuf::Arena* arena,
    const SFixed64Rules& from)
    : ::google::protobuf::Message(arena) {
  SFixed64Rules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  _impl_.const__ = from._impl_.const__;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      case kLte:
        _impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      case kGte:
        _impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.SFixed64Rules)
}
inline PROTOBUF_NDEBUG_INLINE SFixed64Rules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void SFixed64Rules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
SFixed64Rules::~SFixed64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SFixed64Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SFixed64Rules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void SFixed64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SFixed64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
SFixed64Rules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              SFixed64Rules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_._cached_size_),
              false,
          },
          &SFixed64Rules::MergeImpl,
          &SFixed64Rules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 0, 0, 2> SFixed64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_._extensions_),
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SFixed64Rules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::SFixed64Rules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated sfixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64R1,
     {65, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.example_)}},
    // optional sfixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.const__)}},
    // repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64R1,
     {49, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.in_)}},
    // repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastF64R1,
     {57, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sfixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed64)},
    // sfixed64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed64)},
    // sfixed64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed64)},
    // sfixed64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed64)},
    // sfixed64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed64)},
    // repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSFixed64)},
    // repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSFixed64)},
    // repeated sfixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kSFixed64)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void SFixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SFixed64Rules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  _impl_.const__ = ::int64_t{0};
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* SFixed64Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SFixed64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sfixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        6, this->_internal_in().Get(i), target);
  }

  // repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        7, this->_internal_not_in().Get(i), target);
  }

  // repeated sfixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        8, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SFixed64Rules)
  return target;
}

::size_t SFixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SFixed64Rules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated sfixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_example_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional sfixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 9;
  }

  switch (less_than_case()) {
    // sfixed64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size += 9;
      break;
    }
    // sfixed64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size += 9;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sfixed64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size += 9;
      break;
    }
    // sfixed64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size += 9;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void SFixed64Rules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SFixed64Rules*>(&to_msg);
  auto& from = static_cast<const SFixed64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SFixed64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        _this->_impl_.less_than_.lt_ = from._impl_.less_than_.lt_;
        break;
      }
      case kLte: {
        _this->_impl_.less_than_.lte_ = from._impl_.less_than_.lte_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        _this->_impl_.greater_than_.gt_ = from._impl_.greater_than_.gt_;
        break;
      }
      case kGte: {
        _this->_impl_.greater_than_.gte_ = from._impl_.greater_than_.gte_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SFixed64Rules::CopyFrom(const SFixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SFixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SFixed64Rules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const SFixed64Rules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void SFixed64Rules::InternalSwap(SFixed64Rules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata SFixed64Rules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class BoolRules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<BoolRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BoolRules, _impl_._has_bits_);
};

BoolRules::BoolRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.BoolRules)
}
inline PROTOBUF_NDEBUG_INLINE BoolRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::BoolRules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        example_{visibility, arena, from.example_} {}

BoolRules::BoolRules(
    ::google::protobuf::Arena* arena,
    const BoolRules& from)
    : ::google::protobuf::Message(arena) {
  BoolRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  _impl_.const__ = from._impl_.const__;

  // @@protoc_insertion_point(copy_constructor:buf.validate.BoolRules)
}
inline PROTOBUF_NDEBUG_INLINE BoolRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        example_{visibility, arena} {}

inline void BoolRules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
BoolRules::~BoolRules() {
  // @@protoc_insertion_point(destructor:buf.validate.BoolRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void BoolRules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

const ::google::protobuf::MessageLite::ClassData*
BoolRules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              BoolRules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(BoolRules, _impl_._cached_size_),
              false,
          },
          &BoolRules::MergeImpl,
          &BoolRules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> BoolRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BoolRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(BoolRules, _impl_._extensions_),
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_BoolRules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::BoolRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated bool example = 2 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV8R1,
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(BoolRules, _impl_.example_)}},
    // optional bool const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(BoolRules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(BoolRules, _impl_.const__)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BoolRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated bool example = 2 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BoolRules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void BoolRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.BoolRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.example_.Clear();
  _impl_.const__ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* BoolRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.BoolRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_const_(), target);
  }

  // repeated bool example = 2 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.BoolRules)
  return target;
}

::size_t BoolRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.BoolRules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated bool example = 2 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional bool const = 1 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void BoolRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<BoolRules*>(&to_msg);
  auto& from = static_cast<const BoolRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.BoolRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.const__ = from._impl_.const__;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BoolRules::CopyFrom(const BoolRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.BoolRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BoolRules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const BoolRules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void BoolRules::InternalSwap(BoolRules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
        swap(_impl_.const__, other->_impl_.const__);
}

::google::protobuf::Metadata BoolRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class StringRules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<StringRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(StringRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_._oneof_case_);
};

StringRules::StringRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.StringRules)
}
inline PROTOBUF_NDEBUG_INLINE StringRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::StringRules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        const__(arena, from.const__),
        pattern_(arena, from.pattern_),
        prefix_(arena, from.prefix_),
        suffix_(arena, from.suffix_),
        contains_(arena, from.contains_),
        not_contains_(arena, from.not_contains_),
        well_known_{},
        _oneof_case_{from._oneof_case_[0]} {}

StringRules::StringRules(
    ::google::protobuf::Arena* arena,
    const StringRules& from)
    : ::google::protobuf::Message(arena) {
  StringRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_len_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, min_len_),
           offsetof(Impl_, strict_) -
               offsetof(Impl_, min_len_) +
               sizeof(Impl_::strict_));
  switch (well_known_case()) {
    case WELL_KNOWN_NOT_SET:
      break;
      case kEmail:
        _impl_.well_known_.email_ = from._impl_.well_known_.email_;
        break;
      case kHostname:
        _impl_.well_known_.hostname_ = from._impl_.well_known_.hostname_;
        break;
      case kIp:
        _impl_.well_known_.ip_ = from._impl_.well_known_.ip_;
        break;
      case kIpv4:
        _impl_.well_known_.ipv4_ = from._impl_.well_known_.ipv4_;
        break;
      case kIpv6:
        _impl_.well_known_.ipv6_ = from._impl_.well_known_.ipv6_;
        break;
      case kUri:
        _impl_.well_known_.uri_ = from._impl_.well_known_.uri_;
        break;
      case kUriRef:
        _impl_.well_known_.uri_ref_ = from._impl_.well_known_.uri_ref_;
        break;
      case kAddress:
        _impl_.well_known_.address_ = from._impl_.well_known_.address_;
        break;
      case kUuid:
        _impl_.well_known_.uuid_ = from._impl_.well_known_.uuid_;
        break;
      case kTuuid:
        _impl_.well_known_.tuuid_ = from._impl_.well_known_.tuuid_;
        break;
      case kIpWithPrefixlen:
        _impl_.well_known_.ip_with_prefixlen_ = from._impl_.well_known_.ip_with_prefixlen_;
        break;
      case kIpv4WithPrefixlen:
        _impl_.well_known_.ipv4_with_prefixlen_ = from._impl_.well_known_.ipv4_with_prefixlen_;
        break;
      case kIpv6WithPrefixlen:
        _impl_.well_known_.ipv6_with_prefixlen_ = from._impl_.well_known_.ipv6_with_prefixlen_;
        break;
      case kIpPrefix:
        _impl_.well_known_.ip_prefix_ = from._impl_.well_known_.ip_prefix_;
        break;
      case kIpv4Prefix:
        _impl_.well_known_.ipv4_prefix_ = from._impl_.well_known_.ipv4_prefix_;
        break;
      case kIpv6Prefix:
        _impl_.well_known_.ipv6_prefix_ = from._impl_.well_known_.ipv6_prefix_;
        break;
      case kHostAndPort:
        _impl_.well_known_.host_and_port_ = from._impl_.well_known_.host_and_port_;
        break;
      case kWellKnownRegex:
        _impl_.well_known_.well_known_regex_ = from._impl_.well_known_.well_known_regex_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.StringRules)
}
inline PROTOBUF_NDEBUG_INLINE StringRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        const__(arena),
        pattern_(arena),
        prefix_(arena),
        suffix_(arena),
        contains_(arena),
        not_contains_(arena),
        well_known_{},
        _oneof_case_{} {}

inline void StringRules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_len_),
           0,
           offsetof(Impl_, strict_) -
               offsetof(Impl_, min_len_) +
               sizeof(Impl_::strict_));
}
StringRules::~StringRules() {
  // @@protoc_insertion_point(destructor:buf.validate.StringRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void StringRules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.const__.Destroy();
  _impl_.pattern_.Destroy();
  _impl_.prefix_.Destroy();
  _impl_.suffix_.Destroy();
  _impl_.contains_.Destroy();
  _impl_.not_contains_.Destroy();
  if (has_well_known()) {
    clear_well_known();
  }
  _impl_.~Impl_();
}

void StringRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.StringRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (well_known_case()) {
    case kEmail: {
      // No need to clear
      break;
    }
    case kHostname: {
      // No need to clear
      break;
    }
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case kUri: {
      // No need to clear
      break;
    }
    case kUriRef: {
      // No need to clear
      break;
    }
    case kAddress: {
      // No need to clear
      break;
    }
    case kUuid: {
      // No need to clear
      break;
    }
    case kTuuid: {
      // No need to clear
      break;
    }
    case kIpWithPrefixlen: {
      // No need to clear
      break;
    }
    case kIpv4WithPrefixlen: {
      // No need to clear
      break;
    }
    case kIpv6WithPrefixlen: {
      // No need to clear
      break;
    }
    case kIpPrefix: {
      // No need to clear
      break;
    }
    case kIpv4Prefix: {
      // No need to clear
      break;
    }
    case kIpv6Prefix: {
      // No need to clear
      break;
    }
    case kHostAndPort: {
      // No need to clear
      break;
    }
    case kWellKnownRegex: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
StringRules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              StringRules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(StringRules, _impl_._cached_size_),
              false,
          },
          &StringRules::MergeImpl,
          &StringRules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 34, 1, 124, 7> StringRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(StringRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(StringRules, _impl_._extensions_),
    34, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    0,  // skipmap
    offsetof(decltype(_table_), field_entries),
    34,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_StringRules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::StringRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.const__)}},
    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.min_len_), 6>(),
     {16, 6, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_len_)}},
    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.max_len_), 7>(),
     {24, 7, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_len_)}},
    // optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.min_bytes_), 8>(),
     {32, 8, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_bytes_)}},
    // optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.max_bytes_), 9>(),
     {40, 9, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_bytes_)}},
    // optional string pattern = 6 [json_name = "pattern", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastSS1,
     {50, 1, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.pattern_)}},
    // optional string prefix = 7 [json_name = "prefix", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastSS1,
     {58, 2, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.prefix_)}},
    // optional string suffix = 8 [json_name = "suffix", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastSS1,
     {66, 3, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.suffix_)}},
    // optional string contains = 9 [json_name = "contains", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastSS1,
     {74, 4, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.contains_)}},
    // repeated string in = 10 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastSR1,
     {82, 63, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.in_)}},
    // repeated string not_in = 11 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastSR1,
     {90, 63, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_in_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated string example = 34 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastSR2,
     {658, 63, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.example_)}},
    // optional uint64 len = 19 [json_name = "len", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV64S2,
     {408, 10, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_)}},
    // optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV64S2,
     {416, 11, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_bytes_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional string not_contains = 23 [json_name = "notContains", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastSS2,
     {442, 5, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_contains_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool strict = 25 [json_name = "strict"];
    {::_pbi::TcParser::FastV8S2,
     {456, 12, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.strict_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    33, 0, 1,
    65532, 32,
    65535, 65535
  }}, {{
    // optional string const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_len_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_len_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_bytes_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_bytes_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string pattern = 6 [json_name = "pattern", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.pattern_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string prefix = 7 [json_name = "prefix", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.prefix_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string suffix = 8 [json_name = "suffix", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.suffix_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string contains = 9 [json_name = "contains", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.contains_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // repeated string in = 10 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated string not_in = 11 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // bool email = 12 [json_name = "email", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.email_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool hostname = 13 [json_name = "hostname", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.hostname_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ip = 14 [json_name = "ip", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ip_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ipv4_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ipv6_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool uri = 17 [json_name = "uri", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.uri_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.uri_ref_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // optional uint64 len = 19 [json_name = "len", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_bytes_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // bool address = 21 [json_name = "address", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.address_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool uuid = 22 [json_name = "uuid", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.uuid_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // optional string not_contains = 23 [json_name = "notContains", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_contains_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // .buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.well_known_regex_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kEnumRange)},
    // optional bool strict = 25 [json_name = "strict"];
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.strict_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool ip_with_prefixlen = 26 [json_name = "ipWithPrefixlen", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ip_with_prefixlen_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv4_with_prefixlen = 27 [json_name = "ipv4WithPrefixlen", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ipv4_with_prefixlen_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv6_with_prefixlen = 28 [json_name = "ipv6WithPrefixlen", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ipv6_with_prefixlen_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ip_prefix = 29 [json_name = "ipPrefix", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ip_prefix_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv4_prefix = 30 [json_name = "ipv4Prefix", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ipv4_prefix_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv6_prefix = 31 [json_name = "ipv6Prefix", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ipv6_prefix_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool host_and_port = 32 [json_name = "hostAndPort", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.host_and_port_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool tuuid = 33 [json_name = "tuuid", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.tuuid_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // repeated string example = 34 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
  }}, {{
    {0, 3},
  }}, {{
    "\30\5\0\0\0\0\7\6\6\10\2\6\0\0\0\0\0\0\0\0\0\0\0\14\0\0\0\0\0\0\0\0\0\0\7\0\0\0\0\0"
    "buf.validate.StringRules"
    "const"
    "pattern"
    "prefix"
    "suffix"
    "contains"
    "in"
    "not_in"
    "not_contains"
    "example"
  }},
};

PROTOBUF_NOINLINE void StringRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.StringRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.const__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.suffix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.contains_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.not_contains_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.min_len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_len_) -
        reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.max_len_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.min_bytes_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.strict_) -
        reinterpret_cast<char*>(&_impl_.min_bytes_)) + sizeof(_impl_.strict_));
  }
  clear_well_known();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* StringRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.StringRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_const_();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.StringRules.const");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_min_len(), target);
  }

  // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_max_len(), target);
  }

  // optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_min_bytes(), target);
  }

  // optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_max_bytes(), target);
  }

  // optional string pattern = 6 [json_name = "pattern", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_pattern();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.StringRules.pattern");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // optional string prefix = 7 [json_name = "prefix", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_prefix();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.StringRules.prefix");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional string suffix = 8 [json_name = "suffix", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_suffix();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.StringRules.suffix");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // optional string contains = 9 [json_name = "contains", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_contains();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.StringRules.contains");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // repeated string in = 10 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    const auto& s = this->_internal_in().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.StringRules.in");
    target = stream->WriteString(10, s, target);
  }

  // repeated string not_in = 11 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    const auto& s = this->_internal_not_in().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.StringRules.not_in");
    target = stream->WriteString(11, s, target);
  }

  switch (well_known_case()) {
    case kEmail: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          12, this->_internal_email(), target);
      break;
    }
    case kHostname: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          13, this->_internal_hostname(), target);
      break;
    }
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          14, this->_internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          15, this->_internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          16, this->_internal_ipv6(), target);
      break;
    }
    case kUri: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          17, this->_internal_uri(), target);
      break;
    }
    case kUriRef: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          18, this->_internal_uri_ref(), target);
      break;
    }
    default:
      break;
  }
  // optional uint64 len = 19 [json_name = "len", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        19, this->_internal_len(), target);
  }

  // optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        20, this->_internal_len_bytes(), target);
  }

  switch (well_known_case()) {
    case kAddress: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          21, this->_internal_address(), target);
      break;
    }
    case kUuid: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          22, this->_internal_uuid(), target);
      break;
    }
    default:
      break;
  }
  // optional string not_contains = 23 [json_name = "notContains", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000020u) {
    const std::string& _s = this->_internal_not_contains();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.StringRules.not_contains");
    target = stream->WriteStringMaybeAliased(23, _s, target);
  }

  // .buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.predefined) = {
  if (well_known_case() == kWellKnownRegex) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        24, this->_internal_well_known_regex(), target);
  }

  // optional bool strict = 25 [json_name = "strict"];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this->_internal_strict(), target);
  }

  switch (well_known_case()) {
    case kIpWithPrefixlen: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          26, this->_internal_ip_with_prefixlen(), target);
      break;
    }
    case kIpv4WithPrefixlen: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          27, this->_internal_ipv4_with_prefixlen(), target);
      break;
    }
    case kIpv6WithPrefixlen: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          28, this->_internal_ipv6_with_prefixlen(), target);
      break;
    }
    case kIpPrefix: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          29, this->_internal_ip_prefix(), target);
      break;
    }
    case kIpv4Prefix: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          30, this->_internal_ipv4_prefix(), target);
      break;
    }
    case kIpv6Prefix: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          31, this->_internal_ipv6_prefix(), target);
      break;
    }
    case kHostAndPort: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          32, this->_internal_host_and_port(), target);
      break;
    }
    case kTuuid: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          33, this->_internal_tuuid(), target);
      break;
    }
    default:
      break;
  }
  // repeated string example = 34 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    const auto& s = this->_internal_example().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.StringRules.example");
    target = stream->WriteString(34, s, target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.StringRules)
  return target;
}

::size_t StringRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.StringRules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated string in = 10 [json_name = "in", (.buf.validate.predefined) = {
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_in().size());
  for (int i = 0, n = _internal_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_in().Get(i));
  }
  // repeated string not_in = 11 [json_name = "notIn", (.buf.validate.predefined) = {
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_not_in().size());
  for (int i = 0, n = _internal_not_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_not_in().Get(i));
  }
  // repeated string example = 34 [json_name = "example", (.buf.validate.predefined) = {
  total_size += 2 * ::google::protobuf::internal::FromIntSize(_internal_example().size());
  for (int i = 0, n = _internal_example().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_example().Get(i));
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string const = 1 [json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_const_());
    }

    // optional string pattern = 6 [json_name = "pattern", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_pattern());
    }

    // optional string prefix = 7 [json_name = "prefix", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_prefix());
    }

    // optional string suffix = 8 [json_name = "suffix", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_suffix());
    }

    // optional string contains = 9 [json_name = "contains", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_contains());
    }

    // optional string not_contains = 23 [json_name = "notContains", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_not_contains());
    }

    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_min_len());
    }

    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_max_len());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_min_bytes());
    }

    // optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_max_bytes());
    }

    // optional uint64 len = 19 [json_name = "len", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this->_internal_len());
    }

    // optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this->_internal_len_bytes());
    }

    // optional bool strict = 25 [json_name = "strict"];
    if (cached_has_bits & 0x00001000u) {
      total_size += 3;
    }

  }
  switch (well_known_case()) {
    // bool email = 12 [json_name = "email", (.buf.validate.predefined) = {
    case kEmail: {
      total_size += 2;
      break;
    }
    // bool hostname = 13 [json_name = "hostname", (.buf.validate.predefined) = {
    case kHostname: {
      total_size += 2;
      break;
    }
    // bool ip = 14 [json_name = "ip", (.buf.validate.predefined) = {
    case kIp: {
      total_size += 2;
      break;
    }
    // bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.predefined) = {
    case kIpv4: {
      total_size += 2;
      break;
    }
    // bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.predefined) = {
    case kIpv6: {
      total_size += 3;
      break;
    }
    // bool uri = 17 [json_name = "uri", (.buf.validate.predefined) = {
    case kUri: {
      total_size += 3;
      break;
    }
    // bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.predefined) = {
    case kUriRef: {
      total_size += 3;
      break;
    }
    // bool address = 21 [json_name = "address", (.buf.validate.predefined) = {
    case kAddress: {
      total_size += 3;
      break;
    }
    // bool uuid = 22 [json_name = "uuid", (.buf.validate.predefined) = {
    case kUuid: {
      total_size += 3;
      break;
    }
    // bool tuuid = 33 [json_name = "tuuid", (.buf.validate.predefined) = {
    case kTuuid: {
      total_size += 3;
      break;
    }
    // bool ip_with_prefixlen = 26 [json_name = "ipWithPrefixlen", (.buf.validate.predefined) = {
    case kIpWithPrefixlen: {
      total_size += 3;
      break;
    }
    // bool ipv4_with_prefixlen = 27 [json_name = "ipv4WithPrefixlen", (.buf.validate.predefined) = {
    case kIpv4WithPrefixlen: {
      total_size += 3;
      break;
    }
    // bool ipv6_with_prefixlen = 28 [json_name = "ipv6WithPrefixlen", (.buf.validate.predefined) = {
    case kIpv6WithPrefixlen: {
      total_size += 3;
      break;
    }
    // bool ip_prefix = 29 [json_name = "ipPrefix", (.buf.validate.predefined) = {
    case kIpPrefix: {
      total_size += 3;
      break;
    }
    // bool ipv4_prefix = 30 [json_name = "ipv4Prefix", (.buf.validate.predefined) = {
    case kIpv4Prefix: {
      total_size += 3;
      break;
    }
    // bool ipv6_prefix = 31 [json_name = "ipv6Prefix", (.buf.validate.predefined) = {
    case kIpv6Prefix: {
      total_size += 3;
      break;
    }
    // bool host_and_port = 32 [json_name = "hostAndPort", (.buf.validate.predefined) = {
    case kHostAndPort: {
      total_size += 3;
      break;
    }
    // .buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.predefined) = {
    case kWellKnownRegex: {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void StringRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<StringRules*>(&to_msg);
  auto& from = static_cast<const StringRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.StringRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_const_(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pattern(from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_prefix(from._internal_prefix());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_suffix(from._internal_suffix());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_contains(from._internal_contains());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_not_contains(from._internal_not_contains());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.min_len_ = from._impl_.min_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.max_len_ = from._impl_.max_len_;
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.min_bytes_ = from._impl_.min_bytes_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.max_bytes_ = from._impl_.max_bytes_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.len_bytes_ = from._impl_.len_bytes_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.strict_ = from._impl_.strict_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_well_known();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kEmail: {
        _this->_impl_.well_known_.email_ = from._impl_.well_known_.email_;
        break;
      }
      case kHostname: {
        _this->_impl_.well_known_.hostname_ = from._impl_.well_known_.hostname_;
        break;
      }
      case kIp: {
        _this->_impl_.well_known_.ip_ = from._impl_.well_known_.ip_;
        break;
      }
      case kIpv4: {
        _this->_impl_.well_known_.ipv4_ = from._impl_.well_known_.ipv4_;
        break;
      }
      case kIpv6: {
        _this->_impl_.well_known_.ipv6_ = from._impl_.well_known_.ipv6_;
        break;
      }
      case kUri: {
        _this->_impl_.well_known_.uri_ = from._impl_.well_known_.uri_;
        break;
      }
      case kUriRef: {
        _this->_impl_.well_known_.uri_ref_ = from._impl_.well_known_.uri_ref_;
        break;
      }
      case kAddress: {
        _this->_impl_.well_known_.address_ = from._impl_.well_known_.address_;
        break;
      }
      case kUuid: {
        _this->_impl_.well_known_.uuid_ = from._impl_.well_known_.uuid_;
        break;
      }
      case kTuuid: {
        _this->_impl_.well_known_.tuuid_ = from._impl_.well_known_.tuuid_;
        break;
      }
      case kIpWithPrefixlen: {
        _this->_impl_.well_known_.ip_with_prefixlen_ = from._impl_.well_known_.ip_with_prefixlen_;
        break;
      }
      case kIpv4WithPrefixlen: {
        _this->_impl_.well_known_.ipv4_with_prefixlen_ = from._impl_.well_known_.ipv4_with_prefixlen_;
        break;
      }
      case kIpv6WithPrefixlen: {
        _this->_impl_.well_known_.ipv6_with_prefixlen_ = from._impl_.well_known_.ipv6_with_prefixlen_;
        break;
      }
      case kIpPrefix: {
        _this->_impl_.well_known_.ip_prefix_ = from._impl_.well_known_.ip_prefix_;
        break;
      }
      case kIpv4Prefix: {
        _this->_impl_.well_known_.ipv4_prefix_ = from._impl_.well_known_.ipv4_prefix_;
        break;
      }
      case kIpv6Prefix: {
        _this->_impl_.well_known_.ipv6_prefix_ = from._impl_.well_known_.ipv6_prefix_;
        break;
      }
      case kHostAndPort: {
        _this->_impl_.well_known_.host_and_port_ = from._impl_.well_known_.host_and_port_;
        break;
      }
      case kWellKnownRegex: {
        _this->_impl_.well_known_.well_known_regex_ = from._impl_.well_known_.well_known_regex_;
        break;
      }
      case WELL_KNOWN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void StringRules::CopyFrom(const StringRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.StringRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool StringRules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const StringRules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void StringRules::InternalSwap(StringRules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.const__, &other->_impl_.const__, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.pattern_, &other->_impl_.pattern_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.prefix_, &other->_impl_.prefix_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.suffix_, &other->_impl_.suffix_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.contains_, &other->_impl_.contains_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.not_contains_, &other->_impl_.not_contains_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StringRules, _impl_.strict_)
      + sizeof(StringRules::_impl_.strict_)
      - PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_len_)>(
          reinterpret_cast<char*>(&_impl_.min_len_),
          reinterpret_cast<char*>(&other->_impl_.min_len_));
  swap(_impl_.well_known_, other->_impl_.well_known_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata StringRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class BytesRules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<BytesRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BytesRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_._oneof_case_);
};

BytesRules::BytesRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.BytesRules)
}
inline PROTOBUF_NDEBUG_INLINE BytesRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::BytesRules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        const__(arena, from.const__),
        pattern_(arena, from.pattern_),
        prefix_(arena, from.prefix_),
        suffix_(arena, from.suffix_),
        contains_(arena, from.contains_),
        well_known_{},
        _oneof_case_{from._oneof_case_[0]} {}

BytesRules::BytesRules(
    ::google::protobuf::Arena* arena,
    const BytesRules& from)
    : ::google::protobuf::Message(arena) {
  BytesRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_len_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, min_len_),
           offsetof(Impl_, len_) -
               offsetof(Impl_, min_len_) +
               sizeof(Impl_::len_));
  switch (well_known_case()) {
    case WELL_KNOWN_NOT_SET:
      break;
      case kIp:
        _impl_.well_known_.ip_ = from._impl_.well_known_.ip_;
        break;
      case kIpv4:
        _impl_.well_known_.ipv4_ = from._impl_.well_known_.ipv4_;
        break;
      case kIpv6:
        _impl_.well_known_.ipv6_ = from._impl_.well_known_.ipv6_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.BytesRules)
}
inline PROTOBUF_NDEBUG_INLINE BytesRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        const__(arena),
        pattern_(arena),
        prefix_(arena),
        suffix_(arena),
        contains_(arena),
        well_known_{},
        _oneof_case_{} {}

inline void BytesRules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_len_),
           0,
           offsetof(Impl_, len_) -
               offsetof(Impl_, min_len_) +
               sizeof(Impl_::len_));
}
BytesRules::~BytesRules() {
  // @@protoc_insertion_point(destructor:buf.validate.BytesRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void BytesRules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.const__.Destroy();
  _impl_.pattern_.Destroy();
  _impl_.prefix_.Destroy();
  _impl_.suffix_.Destroy();
  _impl_.contains_.Destroy();
  if (has_well_known()) {
    clear_well_known();
  }
  _impl_.~Impl_();
}

void BytesRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.BytesRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (well_known_case()) {
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
BytesRules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              BytesRules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(BytesRules, _impl_._cached_size_),
              false,
          },
          &BytesRules::MergeImpl,
          &BytesRules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 14, 0, 47, 2> BytesRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BytesRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(BytesRules, _impl_._extensions_),
    14, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950912,  // skipmap
    offsetof(decltype(_table_), field_entries),
    14,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_BytesRules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::BytesRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bytes const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.const__)}},
    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(BytesRules, _impl_.min_len_), 5>(),
     {16, 5, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.min_len_)}},
    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(BytesRules, _impl_.max_len_), 6>(),
     {24, 6, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.max_len_)}},
    // optional string pattern = 4 [json_name = "pattern", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastSS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.pattern_)}},
    // optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastBS1,
     {42, 2, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.prefix_)}},
    // optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastBS1,
     {50, 3, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.suffix_)}},
    // optional bytes contains = 7 [json_name = "contains", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastBS1,
     {58, 4, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.contains_)}},
    // repeated bytes in = 8 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastBR1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.in_)}},
    // repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastBR1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.not_in_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 len = 13 [json_name = "len", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(BytesRules, _impl_.len_), 7>(),
     {104, 7, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.len_)}},
    // repeated bytes example = 14 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastBR1,
     {114, 63, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.example_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bytes const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.min_len_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.max_len_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string pattern = 4 [json_name = "pattern", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.pattern_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.prefix_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.suffix_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes contains = 7 [json_name = "contains", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.contains_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // repeated bytes in = 8 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // bool ip = 10 [json_name = "ip", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.well_known_.ip_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv4 = 11 [json_name = "ipv4", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.well_known_.ipv4_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv6 = 12 [json_name = "ipv6", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.well_known_.ipv6_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // optional uint64 len = 13 [json_name = "len", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.len_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated bytes example = 14 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
  }},
  // no aux_entries
  {{
    "\27\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0"
    "buf.validate.BytesRules"
    "pattern"
  }},
};

PROTOBUF_NOINLINE void BytesRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.BytesRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.const__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.suffix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.contains_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.min_len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.len_));
  }
  clear_well_known();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* BytesRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.BytesRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_const_();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_min_len(), target);
  }

  // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_max_len(), target);
  }

  // optional string pattern = 4 [json_name = "pattern", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_pattern();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.BytesRules.pattern");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_prefix();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  // optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_suffix();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  // optional bytes contains = 7 [json_name = "contains", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_contains();
    target = stream->WriteBytesMaybeAliased(7, _s, target);
  }

  // repeated bytes in = 8 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    const auto& s = this->_internal_in().Get(i);
    target = stream->WriteBytes(8, s, target);
  }

  // repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    const auto& s = this->_internal_not_in().Get(i);
    target = stream->WriteBytes(9, s, target);
  }

  switch (well_known_case()) {
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          10, this->_internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          11, this->_internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          12, this->_internal_ipv6(), target);
      break;
    }
    default:
      break;
  }
  // optional uint64 len = 13 [json_name = "len", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        13, this->_internal_len(), target);
  }

  // repeated bytes example = 14 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    const auto& s = this->_internal_example().Get(i);
    target = stream->WriteBytes(14, s, target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.BytesRules)
  return target;
}

::size_t BytesRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.BytesRules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated bytes in = 8 [json_name = "in", (.buf.validate.predefined) = {
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_in().size());
  for (int i = 0, n = _internal_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
        _internal_in().Get(i));
  }
  // repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.predefined) = {
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_not_in().size());
  for (int i = 0, n = _internal_not_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
        _internal_not_in().Get(i));
  }
  // repeated bytes example = 14 [json_name = "example", (.buf.validate.predefined) = {
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_example().size());
  for (int i = 0, n = _internal_example().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
        _internal_example().Get(i));
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes const = 1 [json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_const_());
    }

    // optional string pattern = 4 [json_name = "pattern", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_pattern());
    }

    // optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_prefix());
    }

    // optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_suffix());
    }

    // optional bytes contains = 7 [json_name = "contains", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_contains());
    }

    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_min_len());
    }

    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_max_len());
    }

    // optional uint64 len = 13 [json_name = "len", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  switch (well_known_case()) {
    // bool ip = 10 [json_name = "ip", (.buf.validate.predefined) = {
    case kIp: {
      total_size += 2;
      break;
    }
    // bool ipv4 = 11 [json_name = "ipv4", (.buf.validate.predefined) = {
    case kIpv4: {
      total_size += 2;
      break;
    }
    // bool ipv6 = 12 [json_name = "ipv6", (.buf.validate.predefined) = {
    case kIpv6: {
      total_size += 2;
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void BytesRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<BytesRules*>(&to_msg);
  auto& from = static_cast<const BytesRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.BytesRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_const_(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pattern(from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_prefix(from._internal_prefix());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_suffix(from._internal_suffix());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_contains(from._internal_contains());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.min_len_ = from._impl_.min_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.max_len_ = from._impl_.max_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_well_known();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kIp: {
        _this->_impl_.well_known_.ip_ = from._impl_.well_known_.ip_;
        break;
      }
      case kIpv4: {
        _this->_impl_.well_known_.ipv4_ = from._impl_.well_known_.ipv4_;
        break;
      }
      case kIpv6: {
        _this->_impl_.well_known_.ipv6_ = from._impl_.well_known_.ipv6_;
        break;
      }
      case WELL_KNOWN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BytesRules::CopyFrom(const BytesRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.BytesRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BytesRules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const BytesRules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void BytesRules::InternalSwap(BytesRules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.const__, &other->_impl_.const__, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.pattern_, &other->_impl_.pattern_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.prefix_, &other->_impl_.prefix_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.suffix_, &other->_impl_.suffix_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.contains_, &other->_impl_.contains_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.len_)
      + sizeof(BytesRules::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.min_len_)>(
          reinterpret_cast<char*>(&_impl_.min_len_),
          reinterpret_cast<char*>(&other->_impl_.min_len_));
  swap(_impl_.well_known_, other->_impl_.well_known_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata BytesRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class EnumRules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<EnumRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(EnumRules, _impl_._has_bits_);
};

EnumRules::EnumRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.EnumRules)
}
inline PROTOBUF_NDEBUG_INLINE EnumRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::EnumRules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_} {}

EnumRules::EnumRules(
    ::google::protobuf::Arena* arena,
    const EnumRules& from)
    : ::google::protobuf::Message(arena) {
  EnumRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, const__),
           offsetof(Impl_, defined_only_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::defined_only_));

  // @@protoc_insertion_point(copy_constructor:buf.validate.EnumRules)
}
inline PROTOBUF_NDEBUG_INLINE EnumRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena} {}

inline void EnumRules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, defined_only_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::defined_only_));
}
EnumRules::~EnumRules() {
  // @@protoc_insertion_point(destructor:buf.validate.EnumRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void EnumRules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

const ::google::protobuf::MessageLite::ClassData*
EnumRules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              EnumRules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(EnumRules, _impl_._cached_size_),
              false,
          },
          &EnumRules::MergeImpl,
          &EnumRules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> EnumRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EnumRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(EnumRules, _impl_._extensions_),
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_EnumRules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::EnumRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(EnumRules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.const__)}},
    // optional bool defined_only = 2 [json_name = "definedOnly"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(EnumRules, _impl_.defined_only_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.defined_only_)}},
    // repeated int32 in = 3 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV32R1,
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.in_)}},
    // repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV32R1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.not_in_)}},
    // repeated int32 example = 5 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastV32R1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.example_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bool defined_only = 2 [json_name = "definedOnly"];
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.defined_only_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated int32 in = 3 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
    // repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
    // repeated int32 example = 5 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.example_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void EnumRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.EnumRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.defined_only_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.defined_only_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* EnumRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.EnumRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_const_(), target);
  }

  // optional bool defined_only = 2 [json_name = "definedOnly"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_defined_only(), target);
  }

  // repeated int32 in = 3 [json_name = "in", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_in().Get(i), target);
  }

  // repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_not_in().Get(i), target);
  }

  // repeated int32 example = 5 [json_name = "example", (.buf.validate.predefined) = {
  for (int i = 0, n = this->_internal_example_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_example().Get(i), target);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.EnumRules)
  return target;
}

::size_t EnumRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.EnumRules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated int32 in = 3 [json_name = "in", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_not_in())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_not_in_size());
    ;
    total_size += tag_size + data_size;
  }
  // repeated int32 example = 5 [json_name = "example", (.buf.validate.predefined) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_example())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_example_size());
    ;
    total_size += tag_size + data_size;
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_const_());
    }

    // optional bool defined_only = 2 [json_name = "definedOnly"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void EnumRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<EnumRules*>(&to_msg);
  auto& from = static_cast<const EnumRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.EnumRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.defined_only_ = from._impl_.defined_only_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EnumRules::CopyFrom(const EnumRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.EnumRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool EnumRules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const EnumRules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void EnumRules::InternalSwap(EnumRules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.defined_only_)
      + sizeof(EnumRules::_impl_.defined_only_)
      - PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata EnumRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RepeatedRules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<RepeatedRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_._has_bits_);
};

RepeatedRules::RepeatedRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.RepeatedRules)
}
inline PROTOBUF_NDEBUG_INLINE RepeatedRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::RepeatedRules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RepeatedRules::RepeatedRules(
    ::google::protobuf::Arena* arena,
    const RepeatedRules& from)
    : ::google::protobuf::Message(arena) {
  RepeatedRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.items_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::buf::validate::FieldConstraints>(
                              arena, *from._impl_.items_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_items_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, min_items_),
           offsetof(Impl_, unique_) -
               offsetof(Impl_, min_items_) +
               sizeof(Impl_::unique_));

  // @@protoc_insertion_point(copy_constructor:buf.validate.RepeatedRules)
}
inline PROTOBUF_NDEBUG_INLINE RepeatedRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0} {}

inline void RepeatedRules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, items_),
           0,
           offsetof(Impl_, unique_) -
               offsetof(Impl_, items_) +
               sizeof(Impl_::unique_));
}
RepeatedRules::~RepeatedRules() {
  // @@protoc_insertion_point(destructor:buf.validate.RepeatedRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RepeatedRules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.items_;
  _impl_.~Impl_();
}

const ::google::protobuf::MessageLite::ClassData*
RepeatedRules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              RepeatedRules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_._cached_size_),
              false,
          },
          &RepeatedRules::MergeImpl,
          &RepeatedRules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> RepeatedRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_._extensions_),
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RepeatedRules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::RepeatedRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.items_)}},
    // optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(RepeatedRules, _impl_.min_items_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.min_items_)}},
    // optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(RepeatedRules, _impl_.max_items_), 2>(),
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.max_items_)}},
    // optional bool unique = 3 [json_name = "unique", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(RepeatedRules, _impl_.unique_), 3>(),
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.unique_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.min_items_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.max_items_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool unique = 3 [json_name = "unique", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.unique_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.items_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::buf::validate::FieldConstraints>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void RepeatedRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.RepeatedRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.items_ != nullptr);
    _impl_.items_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.min_items_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.unique_) -
        reinterpret_cast<char*>(&_impl_.min_items_)) + sizeof(_impl_.unique_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* RepeatedRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.RepeatedRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_min_items(), target);
  }

  // optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_max_items(), target);
  }

  // optional bool unique = 3 [json_name = "unique", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_unique(), target);
  }

  // optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *_impl_.items_, _impl_.items_->GetCachedSize(), target, stream);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.RepeatedRules)
  return target;
}

::size_t RepeatedRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.RepeatedRules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.items_);
    }

    // optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_min_items());
    }

    // optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_max_items());
    }

    // optional bool unique = 3 [json_name = "unique", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void RepeatedRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RepeatedRules*>(&to_msg);
  auto& from = static_cast<const RepeatedRules&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.RepeatedRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.items_ != nullptr);
      if (_this->_impl_.items_ == nullptr) {
        _this->_impl_.items_ =
            ::google::protobuf::Message::CopyConstruct<::buf::validate::FieldConstraints>(arena, *from._impl_.items_);
      } else {
        _this->_impl_.items_->MergeFrom(*from._impl_.items_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.min_items_ = from._impl_.min_items_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.max_items_ = from._impl_.max_items_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.unique_ = from._impl_.unique_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RepeatedRules::CopyFrom(const RepeatedRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.RepeatedRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RepeatedRules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const RepeatedRules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._impl_.items_->IsInitialized()) return false;
  }
  return true;
}

void RepeatedRules::InternalSwap(RepeatedRules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.unique_)
      + sizeof(RepeatedRules::_impl_.unique_)
      - PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.items_)>(
          reinterpret_cast<char*>(&_impl_.items_),
          reinterpret_cast<char*>(&other->_impl_.items_));
}

::google::protobuf::Metadata RepeatedRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MapRules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<MapRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MapRules, _impl_._has_bits_);
};

MapRules::MapRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.MapRules)
}
inline PROTOBUF_NDEBUG_INLINE MapRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::MapRules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0} {}

MapRules::MapRules(
    ::google::protobuf::Arena* arena,
    const MapRules& from)
    : ::google::protobuf::Message(arena) {
  MapRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.keys_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::buf::validate::FieldConstraints>(
                              arena, *from._impl_.keys_)
                        : nullptr;
  _impl_.values_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::buf::validate::FieldConstraints>(
                              arena, *from._impl_.values_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, min_pairs_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, min_pairs_),
           offsetof(Impl_, max_pairs_) -
               offsetof(Impl_, min_pairs_) +
               sizeof(Impl_::max_pairs_));

  // @@protoc_insertion_point(copy_constructor:buf.validate.MapRules)
}
inline PROTOBUF_NDEBUG_INLINE MapRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0} {}

inline void MapRules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, keys_),
           0,
           offsetof(Impl_, max_pairs_) -
               offsetof(Impl_, keys_) +
               sizeof(Impl_::max_pairs_));
}
MapRules::~MapRules() {
  // @@protoc_insertion_point(destructor:buf.validate.MapRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MapRules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.keys_;
  delete _impl_.values_;
  _impl_.~Impl_();
}

const ::google::protobuf::MessageLite::ClassData*
MapRules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              MapRules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(MapRules, _impl_._cached_size_),
              false,
          },
          &MapRules::MergeImpl,
          &MapRules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 2, 0, 2> MapRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MapRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(MapRules, _impl_._extensions_),
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967268,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_MapRules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::MapRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(MapRules, _impl_.min_pairs_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.min_pairs_)}},
    // optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.predefined) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(MapRules, _impl_.max_pairs_), 3>(),
     {16, 3, 0, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.max_pairs_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.keys_)}},
    // optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
    {::_pbi::TcParser::FastMtS1,
     {42, 1, 1, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.values_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.min_pairs_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.max_pairs_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.keys_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.values_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::buf::validate::FieldConstraints>()},
    {::_pbi::TcParser::GetTable<::buf::validate::FieldConstraints>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void MapRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.MapRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.keys_ != nullptr);
      _impl_.keys_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.values_ != nullptr);
      _impl_.values_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.min_pairs_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_pairs_) -
        reinterpret_cast<char*>(&_impl_.min_pairs_)) + sizeof(_impl_.max_pairs_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* MapRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.MapRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_min_pairs(), target);
  }

  // optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_max_pairs(), target);
  }

  // optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *_impl_.keys_, _impl_.keys_->GetCachedSize(), target, stream);
  }

  // optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *_impl_.values_, _impl_.values_->GetCachedSize(), target, stream);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.MapRules)
  return target;
}

::size_t MapRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.MapRules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.keys_);
    }

    // optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.values_);
    }

    // optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_min_pairs());
    }

    // optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_max_pairs());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void MapRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MapRules*>(&to_msg);
  auto& from = static_cast<const MapRules&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.MapRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.keys_ != nullptr);
      if (_this->_impl_.keys_ == nullptr) {
        _this->_impl_.keys_ =
            ::google::protobuf::Message::CopyConstruct<::buf::validate::FieldConstraints>(arena, *from._impl_.keys_);
      } else {
        _this->_impl_.keys_->MergeFrom(*from._impl_.keys_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.values_ != nullptr);
      if (_this->_impl_.values_ == nullptr) {
        _this->_impl_.values_ =
            ::google::protobuf::Message::CopyConstruct<::buf::validate::FieldConstraints>(arena, *from._impl_.values_);
      } else {
        _this->_impl_.values_->MergeFrom(*from._impl_.values_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.min_pairs_ = from._impl_.min_pairs_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.max_pairs_ = from._impl_.max_pairs_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MapRules::CopyFrom(const MapRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.MapRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool MapRules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const MapRules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._impl_.keys_->IsInitialized()) return false;
  }
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!this_._impl_.values_->IsInitialized()) return false;
  }
  return true;
}

void MapRules::InternalSwap(MapRules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapRules, _impl_.max_pairs_)
      + sizeof(MapRules::_impl_.max_pairs_)
      - PROTOBUF_FIELD_OFFSET(MapRules, _impl_.keys_)>(
          reinterpret_cast<char*>(&_impl_.keys_),
          reinterpret_cast<char*>(&other->_impl_.keys_));
}

::google::protobuf::Metadata MapRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AnyRules::_Internal {
 public:
};

AnyRules::AnyRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.AnyRules)
}
inline PROTOBUF_NDEBUG_INLINE AnyRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::AnyRules& from_msg)
      : in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        _cached_size_{0} {}

AnyRules::AnyRules(
    ::google::protobuf::Arena* arena,
    const AnyRules& from)
    : ::google::protobuf::Message(arena) {
  AnyRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:buf.validate.AnyRules)
}
inline PROTOBUF_NDEBUG_INLINE AnyRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : in_{visibility, arena},
        not_in_{visibility, arena},
        _cached_size_{0} {}

inline void AnyRules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
AnyRules::~AnyRules() {
  // @@protoc_insertion_point(destructor:buf.validate.AnyRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AnyRules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

const ::google::protobuf::MessageLite::ClassData*
AnyRules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              nullptr,  // IsInitialized
              PROTOBUF_FIELD_OFFSET(AnyRules, _impl_._cached_size_),
              false,
          },
          &AnyRules::MergeImpl,
          &AnyRules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 38, 2> AnyRules::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967289,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AnyRules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::AnyRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated string in = 2 [json_name = "in"];
    {::_pbi::TcParser::FastSR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.in_)}},
    // repeated string not_in = 3 [json_name = "notIn"];
    {::_pbi::TcParser::FastSR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated string in = 2 [json_name = "in"];
    {PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.in_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
    // repeated string not_in = 3 [json_name = "notIn"];
    {PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.not_in_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kRawString | ::_fl::kRepSString)},
  }},
  // no aux_entries
  {{
    "\25\2\6\0\0\0\0\0"
    "buf.validate.AnyRules"
    "in"
    "not_in"
  }},
};

PROTOBUF_NOINLINE void AnyRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.AnyRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* AnyRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.AnyRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated string in = 2 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    const auto& s = this->_internal_in().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.AnyRules.in");
    target = stream->WriteString(2, s, target);
  }

  // repeated string not_in = 3 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    const auto& s = this->_internal_not_in().Get(i);
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.AnyRules.not_in");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.AnyRules)
  return target;
}

::size_t AnyRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.AnyRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated string in = 2 [json_name = "in"];
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_in().size());
  for (int i = 0, n = _internal_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_in().Get(i));
  }
  // repeated string not_in = 3 [json_name = "notIn"];
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_not_in().size());
  for (int i = 0, n = _internal_not_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_not_in().Get(i));
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void AnyRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AnyRules*>(&to_msg);
  auto& from = static_cast<const AnyRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.AnyRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AnyRules::CopyFrom(const AnyRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.AnyRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AnyRules::InternalSwap(AnyRules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
}

::google::protobuf::Metadata AnyRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DurationRules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<DurationRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DurationRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_._oneof_case_);
};

void DurationRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.const__ != nullptr) _impl_.const__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void DurationRules::set_allocated_lt(::google::protobuf::Duration* lt) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_less_than();
  if (lt) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(lt)->GetArena();
    if (message_arena != submessage_arena) {
      lt = ::google::protobuf::internal::GetOwnedMessage(message_arena, lt, submessage_arena);
    }
    set_has_lt();
    _impl_.less_than_.lt_ = lt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.lt)
}
void DurationRules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    if (GetArena() == nullptr) {
      delete _impl_.less_than_.lt_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.less_than_.lt_);
    }
    clear_has_less_than();
  }
}
void DurationRules::set_allocated_lte(::google::protobuf::Duration* lte) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_less_than();
  if (lte) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(lte)->GetArena();
    if (message_arena != submessage_arena) {
      lte = ::google::protobuf::internal::GetOwnedMessage(message_arena, lte, submessage_arena);
    }
    set_has_lte();
    _impl_.less_than_.lte_ = lte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.lte)
}
void DurationRules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    if (GetArena() == nullptr) {
      delete _impl_.less_than_.lte_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.less_than_.lte_);
    }
    clear_has_less_than();
  }
}
void DurationRules::set_allocated_gt(::google::protobuf::Duration* gt) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_greater_than();
  if (gt) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(gt)->GetArena();
    if (message_arena != submessage_arena) {
      gt = ::google::protobuf::internal::GetOwnedMessage(message_arena, gt, submessage_arena);
    }
    set_has_gt();
    _impl_.greater_than_.gt_ = gt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.gt)
}
void DurationRules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    if (GetArena() == nullptr) {
      delete _impl_.greater_than_.gt_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.greater_than_.gt_);
    }
    clear_has_greater_than();
  }
}
void DurationRules::set_allocated_gte(::google::protobuf::Duration* gte) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_greater_than();
  if (gte) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(gte)->GetArena();
    if (message_arena != submessage_arena) {
      gte = ::google::protobuf::internal::GetOwnedMessage(message_arena, gte, submessage_arena);
    }
    set_has_gte();
    _impl_.greater_than_.gte_ = gte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.gte)
}
void DurationRules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    if (GetArena() == nullptr) {
      delete _impl_.greater_than_.gte_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.greater_than_.gte_);
    }
    clear_has_greater_than();
  }
}
void DurationRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
void DurationRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
void DurationRules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
DurationRules::DurationRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.DurationRules)
}
inline PROTOBUF_NDEBUG_INLINE DurationRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::DurationRules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        in_{visibility, arena, from.in_},
        not_in_{visibility, arena, from.not_in_},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

DurationRules::DurationRules(
    ::google::protobuf::Arena* arena,
    const DurationRules& from)
    : ::google::protobuf::Message(arena) {
  DurationRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.const__ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(
                              arena, *from._impl_.const__)
                        : nullptr;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(arena, *from._impl_.less_than_.lt_);
        break;
      case kLte:
        _impl_.less_than_.lte_ = ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(arena, *from._impl_.less_than_.lte_);
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(arena, *from._impl_.greater_than_.gt_);
        break;
      case kGte:
        _impl_.greater_than_.gte_ = ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(arena, *from._impl_.greater_than_.gte_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.DurationRules)
}
inline PROTOBUF_NDEBUG_INLINE DurationRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        in_{visibility, arena},
        not_in_{visibility, arena},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void DurationRules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.const__ = {};
}
DurationRules::~DurationRules() {
  // @@protoc_insertion_point(destructor:buf.validate.DurationRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void DurationRules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.const__;
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void DurationRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DurationRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      if (GetArena() == nullptr) {
        delete _impl_.less_than_.lt_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.less_than_.lt_);
      }
      break;
    }
    case kLte: {
      if (GetArena() == nullptr) {
        delete _impl_.less_than_.lte_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.less_than_.lte_);
      }
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void DurationRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DurationRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      if (GetArena() == nullptr) {
        delete _impl_.greater_than_.gt_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.greater_than_.gt_);
      }
      break;
    }
    case kGte: {
      if (GetArena() == nullptr) {
        delete _impl_.greater_than_.gte_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.greater_than_.gte_);
      }
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
DurationRules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              DurationRules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(DurationRules, _impl_._cached_size_),
              false,
          },
          &DurationRules::MergeImpl,
          &DurationRules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 8, 0, 2> DurationRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DurationRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(DurationRules, _impl_._extensions_),
    9, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966785,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    8,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_DurationRules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::DurationRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastMtR1,
     {66, 63, 6, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.not_in_)}},
    // repeated .google.protobuf.Duration example = 9 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastMtR1,
     {74, 63, 7, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.example_)}},
    // optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.const__)}},
    // repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastMtR1,
     {58, 63, 5, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Duration lt = 3 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Duration lte = 4 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Duration gt = 5 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Duration gte = 6 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.in_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.not_in_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Duration example = 9 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.example_), -1, 7,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void DurationRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.DurationRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.in_.Clear();
  _impl_.not_in_.Clear();
  _impl_.example_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.const__ != nullptr);
    _impl_.const__->Clear();
  }
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* DurationRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.DurationRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *_impl_.const__, _impl_.const__->GetCachedSize(), target, stream);
  }

  switch (less_than_case()) {
    case kLt: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, *_impl_.less_than_.lt_, _impl_.less_than_.lt_->GetCachedSize(), target, stream);
      break;
    }
    case kLte: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *_impl_.less_than_.lte_, _impl_.less_than_.lte_->GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *_impl_.greater_than_.gt_, _impl_.greater_than_.gt_->GetCachedSize(), target, stream);
      break;
    }
    case kGte: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *_impl_.greater_than_.gte_, _impl_.greater_than_.gte_->GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.predefined) = {
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this->_internal_in_size());
       i < n; i++) {
    const auto& repfield = this->_internal_in().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            7, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.predefined) = {
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this->_internal_not_in_size());
       i < n; i++) {
    const auto& repfield = this->_internal_not_in().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            8, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  // repeated .google.protobuf.Duration example = 9 [json_name = "example", (.buf.validate.predefined) = {
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this->_internal_example_size());
       i < n; i++) {
    const auto& repfield = this->_internal_example().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            9, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.DurationRules)
  return target;
}

::size_t DurationRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.DurationRules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.predefined) = {
  total_size += 1UL * this->_internal_in_size();
  for (const auto& msg : this->_internal_in()) {
    total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.predefined) = {
  total_size += 1UL * this->_internal_not_in_size();
  for (const auto& msg : this->_internal_not_in()) {
    total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .google.protobuf.Duration example = 9 [json_name = "example", (.buf.validate.predefined) = {
  total_size += 1UL * this->_internal_example_size();
  for (const auto& msg : this->_internal_example()) {
    total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.predefined) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.const__);
  }

  switch (less_than_case()) {
    // .google.protobuf.Duration lt = 3 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.less_than_.lt_);
      break;
    }
    // .google.protobuf.Duration lte = 4 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.less_than_.lte_);
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // .google.protobuf.Duration gt = 5 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.greater_than_.gt_);
      break;
    }
    // .google.protobuf.Duration gte = 6 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.greater_than_.gte_);
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void DurationRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<DurationRules*>(&to_msg);
  auto& from = static_cast<const DurationRules&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.DurationRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(
      from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(
      from._internal_not_in());
  _this->_internal_mutable_example()->MergeFrom(
      from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.const__ != nullptr);
    if (_this->_impl_.const__ == nullptr) {
      _this->_impl_.const__ =
          ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(arena, *from._impl_.const__);
    } else {
      _this->_impl_.const__->MergeFrom(*from._impl_.const__);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        if (oneof_needs_init) {
          _this->_impl_.less_than_.lt_ =
              ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(arena, *from._impl_.less_than_.lt_);
        } else {
          _this->_impl_.less_than_.lt_->MergeFrom(from._internal_lt());
        }
        break;
      }
      case kLte: {
        if (oneof_needs_init) {
          _this->_impl_.less_than_.lte_ =
              ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(arena, *from._impl_.less_than_.lte_);
        } else {
          _this->_impl_.less_than_.lte_->MergeFrom(from._internal_lte());
        }
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        if (oneof_needs_init) {
          _this->_impl_.greater_than_.gt_ =
              ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(arena, *from._impl_.greater_than_.gt_);
        } else {
          _this->_impl_.greater_than_.gt_->MergeFrom(from._internal_gt());
        }
        break;
      }
      case kGte: {
        if (oneof_needs_init) {
          _this->_impl_.greater_than_.gte_ =
              ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(arena, *from._impl_.greater_than_.gte_);
        } else {
          _this->_impl_.greater_than_.gte_->MergeFrom(from._internal_gte());
        }
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DurationRules::CopyFrom(const DurationRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.DurationRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DurationRules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const DurationRules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void DurationRules::InternalSwap(DurationRules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
  swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata DurationRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class TimestampRules::_Internal {
 public:
  using HasBits =
      decltype(std::declval<TimestampRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_._oneof_case_);
};

void TimestampRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.const__ != nullptr) _impl_.const__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TimestampRules::set_allocated_lt(::google::protobuf::Timestamp* lt) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_less_than();
  if (lt) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(lt)->GetArena();
    if (message_arena != submessage_arena) {
      lt = ::google::protobuf::internal::GetOwnedMessage(message_arena, lt, submessage_arena);
    }
    set_has_lt();
    _impl_.less_than_.lt_ = lt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.lt)
}
void TimestampRules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    if (GetArena() == nullptr) {
      delete _impl_.less_than_.lt_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.less_than_.lt_);
    }
    clear_has_less_than();
  }
}
void TimestampRules::set_allocated_lte(::google::protobuf::Timestamp* lte) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_less_than();
  if (lte) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(lte)->GetArena();
    if (message_arena != submessage_arena) {
      lte = ::google::protobuf::internal::GetOwnedMessage(message_arena, lte, submessage_arena);
    }
    set_has_lte();
    _impl_.less_than_.lte_ = lte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.lte)
}
void TimestampRules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    if (GetArena() == nullptr) {
      delete _impl_.less_than_.lte_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.less_than_.lte_);
    }
    clear_has_less_than();
  }
}
void TimestampRules::set_allocated_gt(::google::protobuf::Timestamp* gt) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_greater_than();
  if (gt) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(gt)->GetArena();
    if (message_arena != submessage_arena) {
      gt = ::google::protobuf::internal::GetOwnedMessage(message_arena, gt, submessage_arena);
    }
    set_has_gt();
    _impl_.greater_than_.gt_ = gt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.gt)
}
void TimestampRules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    if (GetArena() == nullptr) {
      delete _impl_.greater_than_.gt_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.greater_than_.gt_);
    }
    clear_has_greater_than();
  }
}
void TimestampRules::set_allocated_gte(::google::protobuf::Timestamp* gte) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_greater_than();
  if (gte) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(gte)->GetArena();
    if (message_arena != submessage_arena) {
      gte = ::google::protobuf::internal::GetOwnedMessage(message_arena, gte, submessage_arena);
    }
    set_has_gte();
    _impl_.greater_than_.gte_ = gte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.gte)
}
void TimestampRules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    if (GetArena() == nullptr) {
      delete _impl_.greater_than_.gte_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.greater_than_.gte_);
    }
    clear_has_greater_than();
  }
}
void TimestampRules::clear_within() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.within_ != nullptr) _impl_.within_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TimestampRules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
TimestampRules::TimestampRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.TimestampRules)
}
inline PROTOBUF_NDEBUG_INLINE TimestampRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::TimestampRules& from_msg)
      : _extensions_{visibility, arena},
        _has_bits_{from._has_bits_},
        _cached_size_{0},
        example_{visibility, arena, from.example_},
        less_than_{},
        greater_than_{},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

TimestampRules::TimestampRules(
    ::google::protobuf::Arena* arena,
    const TimestampRules& from)
    : ::google::protobuf::Message(arena) {
  TimestampRules* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_._extensions_.MergeFrom(this, from._impl_._extensions_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.const__ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(
                              arena, *from._impl_.const__)
                        : nullptr;
  _impl_.within_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(
                              arena, *from._impl_.within_)
                        : nullptr;
  switch (less_than_case()) {
    case LESS_THAN_NOT_SET:
      break;
      case kLt:
        _impl_.less_than_.lt_ = ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.less_than_.lt_);
        break;
      case kLte:
        _impl_.less_than_.lte_ = ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.less_than_.lte_);
        break;
      case kLtNow:
        _impl_.less_than_.lt_now_ = from._impl_.less_than_.lt_now_;
        break;
  }
  switch (greater_than_case()) {
    case GREATER_THAN_NOT_SET:
      break;
      case kGt:
        _impl_.greater_than_.gt_ = ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.greater_than_.gt_);
        break;
      case kGte:
        _impl_.greater_than_.gte_ = ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.greater_than_.gte_);
        break;
      case kGtNow:
        _impl_.greater_than_.gt_now_ = from._impl_.greater_than_.gt_now_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.TimestampRules)
}
inline PROTOBUF_NDEBUG_INLINE TimestampRules::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _extensions_{visibility, arena},
        _cached_size_{0},
        example_{visibility, arena},
        less_than_{},
        greater_than_{},
        _oneof_case_{} {}

inline void TimestampRules::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, const__),
           0,
           offsetof(Impl_, within_) -
               offsetof(Impl_, const__) +
               sizeof(Impl_::within_));
}
TimestampRules::~TimestampRules() {
  // @@protoc_insertion_point(destructor:buf.validate.TimestampRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void TimestampRules::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.const__;
  delete _impl_.within_;
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
  _impl_.~Impl_();
}

void TimestampRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.TimestampRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (less_than_case()) {
    case kLt: {
      if (GetArena() == nullptr) {
        delete _impl_.less_than_.lt_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.less_than_.lt_);
      }
      break;
    }
    case kLte: {
      if (GetArena() == nullptr) {
        delete _impl_.less_than_.lte_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.less_than_.lte_);
      }
      break;
    }
    case kLtNow: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void TimestampRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.TimestampRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (greater_than_case()) {
    case kGt: {
      if (GetArena() == nullptr) {
        delete _impl_.greater_than_.gt_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.greater_than_.gt_);
      }
      break;
    }
    case kGte: {
      if (GetArena() == nullptr) {
        delete _impl_.greater_than_.gte_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.greater_than_.gte_);
      }
      break;
    }
    case kGtNow: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


const ::google::protobuf::MessageLite::ClassData*
TimestampRules::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              TimestampRules::IsInitializedImpl,
              PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_._cached_size_),
              false,
          },
          &TimestampRules::MergeImpl,
          &TimestampRules::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 7, 0, 2> TimestampRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_._extensions_),
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966273,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TimestampRules_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::TimestampRules>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.const__)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastMtS1,
     {74, 1, 5, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.within_)}},
    // repeated .google.protobuf.Timestamp example = 10 [json_name = "example", (.buf.validate.predefined) = {
    {::_pbi::TcParser::FastMtR1,
     {82, 63, 6, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.example_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Timestamp lt = 3 [json_name = "lt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Timestamp lte = 4 [json_name = "lte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Timestamp gt = 5 [json_name = "gt", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Timestamp gte = 6 [json_name = "gte", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool lt_now = 7 [json_name = "ltNow", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.less_than_.lt_now_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool gt_now = 8 [json_name = "gtNow", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.greater_than_.gt_now_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.within_), _Internal::kHasBitsOffset + 1, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Timestamp example = 10 [json_name = "example", (.buf.validate.predefined) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.example_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void TimestampRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.TimestampRules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.example_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.const__ != nullptr);
      _impl_.const__->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.within_ != nullptr);
      _impl_.within_->Clear();
    }
  }
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* TimestampRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.TimestampRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *_impl_.const__, _impl_.const__->GetCachedSize(), target, stream);
  }

  switch (less_than_case()) {
    case kLt: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, *_impl_.less_than_.lt_, _impl_.less_than_.lt_->GetCachedSize(), target, stream);
      break;
    }
    case kLte: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *_impl_.less_than_.lte_, _impl_.less_than_.lte_->GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *_impl_.greater_than_.gt_, _impl_.greater_than_.gt_->GetCachedSize(), target, stream);
      break;
    }
    case kGte: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *_impl_.greater_than_.gte_, _impl_.greater_than_.gte_->GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // bool lt_now = 7 [json_name = "ltNow", (.buf.validate.predefined) = {
  if (less_than_case() == kLtNow) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_lt_now(), target);
  }

  // bool gt_now = 8 [json_name = "gtNow", (.buf.validate.predefined) = {
  if (greater_than_case() == kGtNow) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_gt_now(), target);
  }

  // optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.predefined) = {
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        9, *_impl_.within_, _impl_.within_->GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Timestamp example = 10 [json_name = "example", (.buf.validate.predefined) = {
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this->_internal_example_size());
       i < n; i++) {
    const auto& repfield = this->_internal_example().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            10, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  // Extension range [1000, 536870912)
  target = _impl_._extensions_._InternalSerialize(
      internal_default_instance(), 1000, 536870912, target, stream);
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.TimestampRules)
  return target;
}

::size_t TimestampRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.TimestampRules)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated .google.protobuf.Timestamp example = 10 [json_name = "example", (.buf.validate.predefined) = {
  total_size += 1UL * this->_internal_example_size();
  for (const auto& msg : this->_internal_example()) {
    total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.const__);
    }

    // optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.predefined) = {
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.within_);
    }

  }
  switch (less_than_case()) {
    // .google.protobuf.Timestamp lt = 3 [json_name = "lt", (.buf.validate.predefined) = {
    case kLt: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.less_than_.lt_);
      break;
    }
    // .google.protobuf.Timestamp lte = 4 [json_name = "lte", (.buf.validate.predefined) = {
    case kLte: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.less_than_.lte_);
      break;
    }
    // bool lt_now = 7 [json_name = "ltNow", (.buf.validate.predefined) = {
    case kLtNow: {
      total_size += 2;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // .google.protobuf.Timestamp gt = 5 [json_name = "gt", (.buf.validate.predefined) = {
    case kGt: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.greater_than_.gt_);
      break;
    }
    // .google.protobuf.Timestamp gte = 6 [json_name = "gte", (.buf.validate.predefined) = {
    case kGte: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.greater_than_.gte_);
      break;
    }
    // bool gt_now = 8 [json_name = "gtNow", (.buf.validate.predefined) = {
    case kGtNow: {
      total_size += 2;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void TimestampRules::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<TimestampRules*>(&to_msg);
  auto& from = static_cast<const TimestampRules&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.TimestampRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_example()->MergeFrom(
      from._internal_example());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.const__ != nullptr);
      if (_this->_impl_.const__ == nullptr) {
        _this->_impl_.const__ =
            ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.const__);
      } else {
        _this->_impl_.const__->MergeFrom(*from._impl_.const__);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.within_ != nullptr);
      if (_this->_impl_.within_ == nullptr) {
        _this->_impl_.within_ =
            ::google::protobuf::Message::CopyConstruct<::google::protobuf::Duration>(arena, *from._impl_.within_);
      } else {
        _this->_impl_.within_->MergeFrom(*from._impl_.within_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_less_than();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kLt: {
        if (oneof_needs_init) {
          _this->_impl_.less_than_.lt_ =
              ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.less_than_.lt_);
        } else {
          _this->_impl_.less_than_.lt_->MergeFrom(from._internal_lt());
        }
        break;
      }
      case kLte: {
        if (oneof_needs_init) {
          _this->_impl_.less_than_.lte_ =
              ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.less_than_.lte_);
        } else {
          _this->_impl_.less_than_.lte_->MergeFrom(from._internal_lte());
        }
        break;
      }
      case kLtNow: {
        _this->_impl_.less_than_.lt_now_ = from._impl_.less_than_.lt_now_;
        break;
      }
      case LESS_THAN_NOT_SET:
        break;
    }
  }
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[1]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[1];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_greater_than();
      }
      _this->_impl_._oneof_case_[1] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kGt: {
        if (oneof_needs_init) {
          _this->_impl_.greater_than_.gt_ =
              ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.greater_than_.gt_);
        } else {
          _this->_impl_.greater_than_.gt_->MergeFrom(from._internal_gt());
        }
        break;
      }
      case kGte: {
        if (oneof_needs_init) {
          _this->_impl_.greater_than_.gte_ =
              ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.greater_than_.gte_);
        } else {
          _this->_impl_.greater_than_.gte_->MergeFrom(from._internal_gte());
        }
        break;
      }
      case kGtNow: {
        _this->_impl_.greater_than_.gt_now_ = from._impl_.greater_than_.gt_now_;
        break;
      }
      case GREATER_THAN_NOT_SET:
        break;
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TimestampRules::CopyFrom(const TimestampRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.TimestampRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TimestampRules::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const TimestampRules&>(msg);
  if (!this_._impl_._extensions_.IsInitialized(
          internal_default_instance())) {
    return false;
  }
  return true;
}

void TimestampRules::InternalSwap(TimestampRules* PROTOBUF_RESTRICT other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.example_.InternalSwap(&other->_impl_.example_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.within_)
      + sizeof(TimestampRules::_impl_.within_)
      - PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata TimestampRules::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Violations::_Internal {
 public:
};

Violations::Violations(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Violations)
}
inline PROTOBUF_NDEBUG_INLINE Violations::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::Violations& from_msg)
      : violations_{visibility, arena, from.violations_},
        _cached_size_{0} {}

Violations::Violations(
    ::google::protobuf::Arena* arena,
    const Violations& from)
    : ::google::protobuf::Message(arena) {
  Violations* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:buf.validate.Violations)
}
inline PROTOBUF_NDEBUG_INLINE Violations::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : violations_{visibility, arena},
        _cached_size_{0} {}

inline void Violations::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
Violations::~Violations() {
  // @@protoc_insertion_point(destructor:buf.validate.Violations)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Violations::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

const ::google::protobuf::MessageLite::ClassData*
Violations::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              nullptr,  // IsInitialized
              PROTOBUF_FIELD_OFFSET(Violations, _impl_._cached_size_),
              false,
          },
          &Violations::MergeImpl,
          &Violations::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> Violations::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Violations_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::Violations>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .buf.validate.Violation violations = 1 [json_name = "violations"];
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Violations, _impl_.violations_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .buf.validate.Violation violations = 1 [json_name = "violations"];
    {PROTOBUF_FIELD_OFFSET(Violations, _impl_.violations_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::buf::validate::Violation>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Violations::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Violations)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.violations_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* Violations::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Violations)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .buf.validate.Violation violations = 1 [json_name = "violations"];
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this->_internal_violations_size());
       i < n; i++) {
    const auto& repfield = this->_internal_violations().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            1, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Violations)
  return target;
}

::size_t Violations::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Violations)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  // repeated .buf.validate.Violation violations = 1 [json_name = "violations"];
  total_size += 1UL * this->_internal_violations_size();
  for (const auto& msg : this->_internal_violations()) {
    total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void Violations::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Violations*>(&to_msg);
  auto& from = static_cast<const Violations&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Violations)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_violations()->MergeFrom(
      from._internal_violations());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Violations::CopyFrom(const Violations& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Violations)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Violations::InternalSwap(Violations* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.violations_.InternalSwap(&other->_impl_.violations_);
}

::google::protobuf::Metadata Violations::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Violation::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Violation>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Violation, _impl_._has_bits_);
};

Violation::Violation(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Violation)
}
inline PROTOBUF_NDEBUG_INLINE Violation::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::buf::validate::Violation& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        field_path_(arena, from.field_path_),
        constraint_id_(arena, from.constraint_id_),
        message_(arena, from.message_) {}

Violation::Violation(
    ::google::protobuf::Arena* arena,
    const Violation& from)
    : ::google::protobuf::Message(arena) {
  Violation* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.for_key_ = from._impl_.for_key_;

  // @@protoc_insertion_point(copy_constructor:buf.validate.Violation)
}
inline PROTOBUF_NDEBUG_INLINE Violation::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        field_path_(arena),
        constraint_id_(arena),
        message_(arena) {}

inline void Violation::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.for_key_ = {};
}
Violation::~Violation() {
  // @@protoc_insertion_point(destructor:buf.validate.Violation)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Violation::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.field_path_.Destroy();
  _impl_.constraint_id_.Destroy();
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

const ::google::protobuf::MessageLite::ClassData*
Violation::GetClassData() const {
  PROTOBUF_CONSTINIT static const ::google::protobuf::MessageLite::
      ClassDataFull _data_ = {
          {
              &_table_.header,
              nullptr,  // OnDemandRegisterArenaDtor
              nullptr,  // IsInitialized
              PROTOBUF_FIELD_OFFSET(Violation, _impl_._cached_size_),
              false,
          },
          &Violation::MergeImpl,
          &Violation::kDescriptorMethods,
          &descriptor_table_buf_2fvalidate_2fvalidate_2eproto,
          nullptr,  // tracker
      };
  ::google::protobuf::internal::PrefetchToLocalCache(&_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_data_.tc_table);
  return _data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 61, 2> Violation::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Violation, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Violation_default_instance_._instance,
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::buf::validate::Violation>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool for_key = 4 [json_name = "forKey"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Violation, _impl_.for_key_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(Violation, _impl_.for_key_)}},
    // optional string field_path = 1 [json_name = "fieldPath"];
    {::_pbi::TcParser::FastSS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Violation, _impl_.field_path_)}},
    // optional string constraint_id = 2 [json_name = "constraintId"];
    {::_pbi::TcParser::FastSS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(Violation, _impl_.constraint_id_)}},
    // optional string message = 3 [json_name = "message"];
    {::_pbi::TcParser::FastSS1,
     {26, 2, 0, PROTOBUF_FIELD_OFFSET(Violation, _impl_.message_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string field_path = 1 [json_name = "fieldPath"];
    {PROTOBUF_FIELD_OFFSET(Violation, _impl_.field_path_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string constraint_id = 2 [json_name = "constraintId"];
    {PROTOBUF_FIELD_OFFSET(Violation, _impl_.constraint_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional string message = 3 [json_name = "message"];
    {PROTOBUF_FIELD_OFFSET(Violation, _impl_.message_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional bool for_key = 4 [json_name = "forKey"];
    {PROTOBUF_FIELD_OFFSET(Violation, _impl_.for_key_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\26\12\15\7\0\0\0\0"
    "buf.validate.Violation"
    "field_path"
    "constraint_id"
    "message"
  }},
};

PROTOBUF_NOINLINE void Violation::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Violation)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.field_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.constraint_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.for_key_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

::uint8_t* Violation::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Violation)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string field_path = 1 [json_name = "fieldPath"];
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_field_path();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.Violation.field_path");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string constraint_id = 2 [json_name = "constraintId"];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_constraint_id();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.Violation.constraint_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string message = 3 [json_name = "message"];
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_message();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "buf.validate.Violation.message");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional bool for_key = 4 [json_name = "forKey"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_for_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Violation)
  return target;
}

::size_t Violation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Violation)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(reinterpret_cast<const void*>(this));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string field_path = 1 [json_name = "fieldPath"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_field_path());
    }

    // optional string constraint_id = 2 [json_name = "constraintId"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_constraint_id());
    }

    // optional string message = 3 [json_name = "message"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_message());
    }

    // optional bool for_key = 4 [json_name = "forKey"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}


void Violation::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Violation*>(&to_msg);
  auto& from = static_cast<const Violation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Violation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_field_path(from._internal_field_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_constraint_id(from._internal_constraint_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.for_key_ = from._impl_.for_key_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Violation::CopyFrom(const Violation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Violation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Violation::InternalSwap(Violation* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.field_path_, &other->_impl_.field_path_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.constraint_id_, &other->_impl_.constraint_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
        swap(_impl_.for_key_, other->_impl_.for_key_);
}

::google::protobuf::Metadata Violation::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::_pbi::
        ExtensionIdentifier<::google::protobuf::MessageOptions, ::_pbi::MessageTypeTraits< ::buf::validate::MessageConstraints >,
                            11, false>
            message(kMessageFieldNumber, &::buf::validate::_MessageConstraints_default_instance_);
PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::_pbi::
        ExtensionIdentifier<::google::protobuf::OneofOptions, ::_pbi::MessageTypeTraits< ::buf::validate::OneofConstraints >,
                            11, false>
            oneof(kOneofFieldNumber, &::buf::validate::_OneofConstraints_default_instance_);
PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::_pbi::
        ExtensionIdentifier<::google::protobuf::FieldOptions, ::_pbi::MessageTypeTraits< ::buf::validate::FieldConstraints >,
                            11, false>
            field(kFieldFieldNumber, &::buf::validate::_FieldConstraints_default_instance_);
PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::_pbi::
        ExtensionIdentifier<::google::protobuf::FieldOptions, ::_pbi::MessageTypeTraits< ::buf::validate::PredefinedConstraints >,
                            11, false>
            predefined(kPredefinedFieldNumber, &::buf::validate::_PredefinedConstraints_default_instance_);
// @@protoc_insertion_point(namespace_scope)
}  // namespace validate
}  // namespace buf
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_buf_2fvalidate_2fvalidate_2eproto),
        ::_pbi::ExtensionSet::RegisterMessageExtension(
            &::google::protobuf::MessageOptions::default_instance(), 1159, 11,
            false, false, &::buf::validate::MessageConstraints::default_instance(),
            nullptr, ::_pbi::LazyAnnotation::kUndefined),
        ::_pbi::ExtensionSet::RegisterMessageExtension(
            &::google::protobuf::OneofOptions::default_instance(), 1159, 11,
            false, false, &::buf::validate::OneofConstraints::default_instance(),
            nullptr, ::_pbi::LazyAnnotation::kUndefined),
        ::_pbi::ExtensionSet::RegisterMessageExtension(
            &::google::protobuf::FieldOptions::default_instance(), 1159, 11,
            false, false, &::buf::validate::FieldConstraints::default_instance(),
            nullptr, ::_pbi::LazyAnnotation::kUndefined),
        ::_pbi::ExtensionSet::RegisterMessageExtension(
            &::google::protobuf::FieldOptions::default_instance(), 1160, 11,
            false, false, &::buf::validate::PredefinedConstraints::default_instance(),
            nullptr, ::_pbi::LazyAnnotation::kUndefined),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"

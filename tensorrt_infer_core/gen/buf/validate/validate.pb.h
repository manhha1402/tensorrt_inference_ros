// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: buf/validate/validate.proto
// Protobuf C++ Version: 5.27.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_buf_2fvalidate_2fvalidate_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_buf_2fvalidate_2fvalidate_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/descriptor.pb.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_buf_2fvalidate_2fvalidate_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_buf_2fvalidate_2fvalidate_2eproto;
namespace buf {
namespace validate {
class AnyRules;
struct AnyRulesDefaultTypeInternal;
extern AnyRulesDefaultTypeInternal _AnyRules_default_instance_;
class BoolRules;
struct BoolRulesDefaultTypeInternal;
extern BoolRulesDefaultTypeInternal _BoolRules_default_instance_;
class BytesRules;
struct BytesRulesDefaultTypeInternal;
extern BytesRulesDefaultTypeInternal _BytesRules_default_instance_;
class Constraint;
struct ConstraintDefaultTypeInternal;
extern ConstraintDefaultTypeInternal _Constraint_default_instance_;
class DoubleRules;
struct DoubleRulesDefaultTypeInternal;
extern DoubleRulesDefaultTypeInternal _DoubleRules_default_instance_;
class DurationRules;
struct DurationRulesDefaultTypeInternal;
extern DurationRulesDefaultTypeInternal _DurationRules_default_instance_;
class EnumRules;
struct EnumRulesDefaultTypeInternal;
extern EnumRulesDefaultTypeInternal _EnumRules_default_instance_;
class FieldConstraints;
struct FieldConstraintsDefaultTypeInternal;
extern FieldConstraintsDefaultTypeInternal _FieldConstraints_default_instance_;
class Fixed32Rules;
struct Fixed32RulesDefaultTypeInternal;
extern Fixed32RulesDefaultTypeInternal _Fixed32Rules_default_instance_;
class Fixed64Rules;
struct Fixed64RulesDefaultTypeInternal;
extern Fixed64RulesDefaultTypeInternal _Fixed64Rules_default_instance_;
class FloatRules;
struct FloatRulesDefaultTypeInternal;
extern FloatRulesDefaultTypeInternal _FloatRules_default_instance_;
class Int32Rules;
struct Int32RulesDefaultTypeInternal;
extern Int32RulesDefaultTypeInternal _Int32Rules_default_instance_;
class Int64Rules;
struct Int64RulesDefaultTypeInternal;
extern Int64RulesDefaultTypeInternal _Int64Rules_default_instance_;
class MapRules;
struct MapRulesDefaultTypeInternal;
extern MapRulesDefaultTypeInternal _MapRules_default_instance_;
class MessageConstraints;
struct MessageConstraintsDefaultTypeInternal;
extern MessageConstraintsDefaultTypeInternal _MessageConstraints_default_instance_;
class OneofConstraints;
struct OneofConstraintsDefaultTypeInternal;
extern OneofConstraintsDefaultTypeInternal _OneofConstraints_default_instance_;
class PredefinedConstraints;
struct PredefinedConstraintsDefaultTypeInternal;
extern PredefinedConstraintsDefaultTypeInternal _PredefinedConstraints_default_instance_;
class RepeatedRules;
struct RepeatedRulesDefaultTypeInternal;
extern RepeatedRulesDefaultTypeInternal _RepeatedRules_default_instance_;
class SFixed32Rules;
struct SFixed32RulesDefaultTypeInternal;
extern SFixed32RulesDefaultTypeInternal _SFixed32Rules_default_instance_;
class SFixed64Rules;
struct SFixed64RulesDefaultTypeInternal;
extern SFixed64RulesDefaultTypeInternal _SFixed64Rules_default_instance_;
class SInt32Rules;
struct SInt32RulesDefaultTypeInternal;
extern SInt32RulesDefaultTypeInternal _SInt32Rules_default_instance_;
class SInt64Rules;
struct SInt64RulesDefaultTypeInternal;
extern SInt64RulesDefaultTypeInternal _SInt64Rules_default_instance_;
class StringRules;
struct StringRulesDefaultTypeInternal;
extern StringRulesDefaultTypeInternal _StringRules_default_instance_;
class TimestampRules;
struct TimestampRulesDefaultTypeInternal;
extern TimestampRulesDefaultTypeInternal _TimestampRules_default_instance_;
class UInt32Rules;
struct UInt32RulesDefaultTypeInternal;
extern UInt32RulesDefaultTypeInternal _UInt32Rules_default_instance_;
class UInt64Rules;
struct UInt64RulesDefaultTypeInternal;
extern UInt64RulesDefaultTypeInternal _UInt64Rules_default_instance_;
class Violation;
struct ViolationDefaultTypeInternal;
extern ViolationDefaultTypeInternal _Violation_default_instance_;
class Violations;
struct ViolationsDefaultTypeInternal;
extern ViolationsDefaultTypeInternal _Violations_default_instance_;
}  // namespace validate
}  // namespace buf
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace buf {
namespace validate {
enum Ignore : int {
  IGNORE_UNSPECIFIED = 0,
  IGNORE_IF_UNPOPULATED = 1,
  IGNORE_IF_DEFAULT_VALUE = 2,
  IGNORE_ALWAYS = 3,
  IGNORE_EMPTY [[deprecated]] = 1,
  IGNORE_DEFAULT [[deprecated]] = 2,
};

bool Ignore_IsValid(int value);
extern const uint32_t Ignore_internal_data_[];
constexpr Ignore Ignore_MIN = static_cast<Ignore>(0);
constexpr Ignore Ignore_MAX = static_cast<Ignore>(3);
constexpr int Ignore_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Ignore_descriptor();
template <typename T>
const std::string& Ignore_Name(T value) {
  static_assert(std::is_same<T, Ignore>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Ignore_Name().");
  return Ignore_Name(static_cast<Ignore>(value));
}
template <>
inline const std::string& Ignore_Name(Ignore value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Ignore_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Ignore_Parse(absl::string_view name, Ignore* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ignore>(
      Ignore_descriptor(), name, value);
}
enum KnownRegex : int {
  KNOWN_REGEX_UNSPECIFIED = 0,
  KNOWN_REGEX_HTTP_HEADER_NAME = 1,
  KNOWN_REGEX_HTTP_HEADER_VALUE = 2,
};

bool KnownRegex_IsValid(int value);
extern const uint32_t KnownRegex_internal_data_[];
constexpr KnownRegex KnownRegex_MIN = static_cast<KnownRegex>(0);
constexpr KnownRegex KnownRegex_MAX = static_cast<KnownRegex>(2);
constexpr int KnownRegex_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
KnownRegex_descriptor();
template <typename T>
const std::string& KnownRegex_Name(T value) {
  static_assert(std::is_same<T, KnownRegex>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to KnownRegex_Name().");
  return KnownRegex_Name(static_cast<KnownRegex>(value));
}
template <>
inline const std::string& KnownRegex_Name(KnownRegex value) {
  return ::google::protobuf::internal::NameOfDenseEnum<KnownRegex_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool KnownRegex_Parse(absl::string_view name, KnownRegex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KnownRegex>(
      KnownRegex_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Violation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.Violation) */ {
 public:
  inline Violation() : Violation(nullptr) {}
  ~Violation() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Violation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Violation(const Violation& from) : Violation(nullptr, from) {}
  inline Violation(Violation&& from) noexcept
      : Violation(nullptr, std::move(from)) {}
  inline Violation& operator=(const Violation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Violation& operator=(Violation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Violation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Violation* internal_default_instance() {
    return reinterpret_cast<const Violation*>(
        &_Violation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(Violation& a, Violation& b) { a.Swap(&b); }
  inline void Swap(Violation* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Violation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Violation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Violation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Violation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Violation& from) { Violation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Violation* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.Violation"; }

 protected:
  explicit Violation(::google::protobuf::Arena* arena);
  Violation(::google::protobuf::Arena* arena, const Violation& from);
  Violation(::google::protobuf::Arena* arena, Violation&& from) noexcept
      : Violation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldPathFieldNumber = 1,
    kConstraintIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kForKeyFieldNumber = 4,
  };
  // optional string field_path = 1 [json_name = "fieldPath"];
  bool has_field_path() const;
  void clear_field_path() ;
  const std::string& field_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_field_path(Arg_&& arg, Args_... args);
  std::string* mutable_field_path();
  PROTOBUF_NODISCARD std::string* release_field_path();
  void set_allocated_field_path(std::string* value);

  private:
  const std::string& _internal_field_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_path(
      const std::string& value);
  std::string* _internal_mutable_field_path();

  public:
  // optional string constraint_id = 2 [json_name = "constraintId"];
  bool has_constraint_id() const;
  void clear_constraint_id() ;
  const std::string& constraint_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_constraint_id(Arg_&& arg, Args_... args);
  std::string* mutable_constraint_id();
  PROTOBUF_NODISCARD std::string* release_constraint_id();
  void set_allocated_constraint_id(std::string* value);

  private:
  const std::string& _internal_constraint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_constraint_id(
      const std::string& value);
  std::string* _internal_mutable_constraint_id();

  public:
  // optional string message = 3 [json_name = "message"];
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // optional bool for_key = 4 [json_name = "forKey"];
  bool has_for_key() const;
  void clear_for_key() ;
  bool for_key() const;
  void set_for_key(bool value);

  private:
  bool _internal_for_key() const;
  void _internal_set_for_key(bool value);

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.Violation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      61, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Violation_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Violation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr field_path_;
    ::google::protobuf::internal::ArenaStringPtr constraint_id_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool for_key_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class UInt64Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.UInt64Rules) */ {
 public:
  inline UInt64Rules() : UInt64Rules(nullptr) {}
  ~UInt64Rules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UInt64Rules(
      ::google::protobuf::internal::ConstantInitialized);

  inline UInt64Rules(const UInt64Rules& from) : UInt64Rules(nullptr, from) {}
  inline UInt64Rules(UInt64Rules&& from) noexcept
      : UInt64Rules(nullptr, std::move(from)) {}
  inline UInt64Rules& operator=(const UInt64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline UInt64Rules& operator=(UInt64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UInt64Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const UInt64Rules* internal_default_instance() {
    return reinterpret_cast<const UInt64Rules*>(
        &_UInt64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(UInt64Rules& a, UInt64Rules& b) { a.Swap(&b); }
  inline void Swap(UInt64Rules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UInt64Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UInt64Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UInt64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UInt64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UInt64Rules& from) { UInt64Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UInt64Rules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.UInt64Rules"; }

 protected:
  explicit UInt64Rules(::google::protobuf::Arena* arena);
  UInt64Rules(::google::protobuf::Arena* arena, const UInt64Rules& from);
  UInt64Rules(::google::protobuf::Arena* arena, UInt64Rules&& from) noexcept
      : UInt64Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 8,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated uint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint64_t in(int index) const;
  void set_in(int index, ::uint64_t value);
  void add_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_in();

  public:
  // repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint64_t not_in(int index) const;
  void set_not_in(int index, ::uint64_t value);
  void add_not_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_not_in();

  public:
  // repeated uint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::uint64_t example(int index) const;
  void set_example(int index, ::uint64_t value);
  void add_example(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& example() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_example() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_example();

  public:
  // optional uint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  ::uint64_t const_() const;
  void set_const_(::uint64_t value);

  private:
  ::uint64_t _internal_const_() const;
  void _internal_set_const_(::uint64_t value);

  public:
  // uint64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  ::uint64_t lt() const;
  void set_lt(::uint64_t value);

  private:
  ::uint64_t _internal_lt() const;
  void _internal_set_lt(::uint64_t value);

  public:
  // uint64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  ::uint64_t lte() const;
  void set_lte(::uint64_t value);

  private:
  ::uint64_t _internal_lte() const;
  void _internal_set_lte(::uint64_t value);

  public:
  // uint64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  ::uint64_t gt() const;
  void set_gt(::uint64_t value);

  private:
  ::uint64_t _internal_gt() const;
  void _internal_set_gt(::uint64_t value);

  public:
  // uint64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  ::uint64_t gte() const;
  void set_gte(::uint64_t value);

  private:
  ::uint64_t _internal_gte() const;
  void _internal_set_gte(::uint64_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.UInt64Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UInt64Rules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UInt64Rules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> in_;
    ::google::protobuf::RepeatedField<::uint64_t> not_in_;
    ::google::protobuf::RepeatedField<::uint64_t> example_;
    ::uint64_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t lt_;
      ::uint64_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t gt_;
      ::uint64_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class UInt32Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.UInt32Rules) */ {
 public:
  inline UInt32Rules() : UInt32Rules(nullptr) {}
  ~UInt32Rules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UInt32Rules(
      ::google::protobuf::internal::ConstantInitialized);

  inline UInt32Rules(const UInt32Rules& from) : UInt32Rules(nullptr, from) {}
  inline UInt32Rules(UInt32Rules&& from) noexcept
      : UInt32Rules(nullptr, std::move(from)) {}
  inline UInt32Rules& operator=(const UInt32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline UInt32Rules& operator=(UInt32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UInt32Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const UInt32Rules* internal_default_instance() {
    return reinterpret_cast<const UInt32Rules*>(
        &_UInt32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(UInt32Rules& a, UInt32Rules& b) { a.Swap(&b); }
  inline void Swap(UInt32Rules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UInt32Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UInt32Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UInt32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UInt32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UInt32Rules& from) { UInt32Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UInt32Rules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.UInt32Rules"; }

 protected:
  explicit UInt32Rules(::google::protobuf::Arena* arena);
  UInt32Rules(::google::protobuf::Arena* arena, const UInt32Rules& from);
  UInt32Rules(::google::protobuf::Arena* arena, UInt32Rules&& from) noexcept
      : UInt32Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 8,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated uint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint32_t in(int index) const;
  void set_in(int index, ::uint32_t value);
  void add_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_in();

  public:
  // repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint32_t not_in(int index) const;
  void set_not_in(int index, ::uint32_t value);
  void add_not_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_not_in();

  public:
  // repeated uint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::uint32_t example(int index) const;
  void set_example(int index, ::uint32_t value);
  void add_example(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& example() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_example() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_example();

  public:
  // optional uint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  ::uint32_t const_() const;
  void set_const_(::uint32_t value);

  private:
  ::uint32_t _internal_const_() const;
  void _internal_set_const_(::uint32_t value);

  public:
  // uint32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  ::uint32_t lt() const;
  void set_lt(::uint32_t value);

  private:
  ::uint32_t _internal_lt() const;
  void _internal_set_lt(::uint32_t value);

  public:
  // uint32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  ::uint32_t lte() const;
  void set_lte(::uint32_t value);

  private:
  ::uint32_t _internal_lte() const;
  void _internal_set_lte(::uint32_t value);

  public:
  // uint32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  ::uint32_t gt() const;
  void set_gt(::uint32_t value);

  private:
  ::uint32_t _internal_gt() const;
  void _internal_set_gt(::uint32_t value);

  public:
  // uint32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  ::uint32_t gte() const;
  void set_gte(::uint32_t value);

  private:
  ::uint32_t _internal_gte() const;
  void _internal_set_gte(::uint32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<UInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.UInt32Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UInt32Rules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UInt32Rules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> in_;
    ::google::protobuf::RepeatedField<::uint32_t> not_in_;
    ::google::protobuf::RepeatedField<::uint32_t> example_;
    ::uint32_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t lt_;
      ::uint32_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t gt_;
      ::uint32_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class StringRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.StringRules) */ {
 public:
  inline StringRules() : StringRules(nullptr) {}
  ~StringRules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StringRules(
      ::google::protobuf::internal::ConstantInitialized);

  inline StringRules(const StringRules& from) : StringRules(nullptr, from) {}
  inline StringRules(StringRules&& from) noexcept
      : StringRules(nullptr, std::move(from)) {}
  inline StringRules& operator=(const StringRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringRules& operator=(StringRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringRules& default_instance() {
    return *internal_default_instance();
  }
  enum WellKnownCase {
    kEmail = 12,
    kHostname = 13,
    kIp = 14,
    kIpv4 = 15,
    kIpv6 = 16,
    kUri = 17,
    kUriRef = 18,
    kAddress = 21,
    kUuid = 22,
    kTuuid = 33,
    kIpWithPrefixlen = 26,
    kIpv4WithPrefixlen = 27,
    kIpv6WithPrefixlen = 28,
    kIpPrefix = 29,
    kIpv4Prefix = 30,
    kIpv6Prefix = 31,
    kHostAndPort = 32,
    kWellKnownRegex = 24,
    WELL_KNOWN_NOT_SET = 0,
  };
  static inline const StringRules* internal_default_instance() {
    return reinterpret_cast<const StringRules*>(
        &_StringRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(StringRules& a, StringRules& b) { a.Swap(&b); }
  inline void Swap(StringRules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StringRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StringRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StringRules& from) { StringRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StringRules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.StringRules"; }

 protected:
  explicit StringRules(::google::protobuf::Arena* arena);
  StringRules(::google::protobuf::Arena* arena, const StringRules& from);
  StringRules(::google::protobuf::Arena* arena, StringRules&& from) noexcept
      : StringRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 10,
    kNotInFieldNumber = 11,
    kExampleFieldNumber = 34,
    kConstFieldNumber = 1,
    kPatternFieldNumber = 6,
    kPrefixFieldNumber = 7,
    kSuffixFieldNumber = 8,
    kContainsFieldNumber = 9,
    kNotContainsFieldNumber = 23,
    kMinLenFieldNumber = 2,
    kMaxLenFieldNumber = 3,
    kMinBytesFieldNumber = 4,
    kMaxBytesFieldNumber = 5,
    kLenFieldNumber = 19,
    kLenBytesFieldNumber = 20,
    kStrictFieldNumber = 25,
    kEmailFieldNumber = 12,
    kHostnameFieldNumber = 13,
    kIpFieldNumber = 14,
    kIpv4FieldNumber = 15,
    kIpv6FieldNumber = 16,
    kUriFieldNumber = 17,
    kUriRefFieldNumber = 18,
    kAddressFieldNumber = 21,
    kUuidFieldNumber = 22,
    kTuuidFieldNumber = 33,
    kIpWithPrefixlenFieldNumber = 26,
    kIpv4WithPrefixlenFieldNumber = 27,
    kIpv6WithPrefixlenFieldNumber = 28,
    kIpPrefixFieldNumber = 29,
    kIpv4PrefixFieldNumber = 30,
    kIpv6PrefixFieldNumber = 31,
    kHostAndPortFieldNumber = 32,
    kWellKnownRegexFieldNumber = 24,
  };
  // repeated string in = 10 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  const std::string& in(int index) const;
  std::string* mutable_in(int index);
  void set_in(int index, const std::string& value);
  void set_in(int index, std::string&& value);
  void set_in(int index, const char* value);
  void set_in(int index, const char* value, std::size_t size);
  void set_in(int index, absl::string_view value);
  std::string* add_in();
  void add_in(const std::string& value);
  void add_in(std::string&& value);
  void add_in(const char* value);
  void add_in(const char* value, std::size_t size);
  void add_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_in();

  public:
  // repeated string not_in = 11 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  const std::string& not_in(int index) const;
  std::string* mutable_not_in(int index);
  void set_not_in(int index, const std::string& value);
  void set_not_in(int index, std::string&& value);
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const char* value, std::size_t size);
  void set_not_in(int index, absl::string_view value);
  std::string* add_not_in();
  void add_not_in(const std::string& value);
  void add_not_in(std::string&& value);
  void add_not_in(const char* value);
  void add_not_in(const char* value, std::size_t size);
  void add_not_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_not_in();

  public:
  // repeated string example = 34 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  const std::string& example(int index) const;
  std::string* mutable_example(int index);
  void set_example(int index, const std::string& value);
  void set_example(int index, std::string&& value);
  void set_example(int index, const char* value);
  void set_example(int index, const char* value, std::size_t size);
  void set_example(int index, absl::string_view value);
  std::string* add_example();
  void add_example(const std::string& value);
  void add_example(std::string&& value);
  void add_example(const char* value);
  void add_example(const char* value, std::size_t size);
  void add_example(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& example() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_example();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_example() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_example();

  public:
  // optional string const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  const std::string& const_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_const_(Arg_&& arg, Args_... args);
  std::string* mutable_const_();
  PROTOBUF_NODISCARD std::string* release_const_();
  void set_allocated_const_(std::string* value);

  private:
  const std::string& _internal_const_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_const_(
      const std::string& value);
  std::string* _internal_mutable_const_();

  public:
  // optional string pattern = 6 [json_name = "pattern", (.buf.validate.predefined) = {
  bool has_pattern() const;
  void clear_pattern() ;
  const std::string& pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* value);

  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(
      const std::string& value);
  std::string* _internal_mutable_pattern();

  public:
  // optional string prefix = 7 [json_name = "prefix", (.buf.validate.predefined) = {
  bool has_prefix() const;
  void clear_prefix() ;
  const std::string& prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* value);

  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(
      const std::string& value);
  std::string* _internal_mutable_prefix();

  public:
  // optional string suffix = 8 [json_name = "suffix", (.buf.validate.predefined) = {
  bool has_suffix() const;
  void clear_suffix() ;
  const std::string& suffix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_suffix(Arg_&& arg, Args_... args);
  std::string* mutable_suffix();
  PROTOBUF_NODISCARD std::string* release_suffix();
  void set_allocated_suffix(std::string* value);

  private:
  const std::string& _internal_suffix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(
      const std::string& value);
  std::string* _internal_mutable_suffix();

  public:
  // optional string contains = 9 [json_name = "contains", (.buf.validate.predefined) = {
  bool has_contains() const;
  void clear_contains() ;
  const std::string& contains() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contains(Arg_&& arg, Args_... args);
  std::string* mutable_contains();
  PROTOBUF_NODISCARD std::string* release_contains();
  void set_allocated_contains(std::string* value);

  private:
  const std::string& _internal_contains() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contains(
      const std::string& value);
  std::string* _internal_mutable_contains();

  public:
  // optional string not_contains = 23 [json_name = "notContains", (.buf.validate.predefined) = {
  bool has_not_contains() const;
  void clear_not_contains() ;
  const std::string& not_contains() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_not_contains(Arg_&& arg, Args_... args);
  std::string* mutable_not_contains();
  PROTOBUF_NODISCARD std::string* release_not_contains();
  void set_allocated_not_contains(std::string* value);

  private:
  const std::string& _internal_not_contains() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_not_contains(
      const std::string& value);
  std::string* _internal_mutable_not_contains();

  public:
  // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
  bool has_min_len() const;
  void clear_min_len() ;
  ::uint64_t min_len() const;
  void set_min_len(::uint64_t value);

  private:
  ::uint64_t _internal_min_len() const;
  void _internal_set_min_len(::uint64_t value);

  public:
  // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
  bool has_max_len() const;
  void clear_max_len() ;
  ::uint64_t max_len() const;
  void set_max_len(::uint64_t value);

  private:
  ::uint64_t _internal_max_len() const;
  void _internal_set_max_len(::uint64_t value);

  public:
  // optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.predefined) = {
  bool has_min_bytes() const;
  void clear_min_bytes() ;
  ::uint64_t min_bytes() const;
  void set_min_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_min_bytes() const;
  void _internal_set_min_bytes(::uint64_t value);

  public:
  // optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.predefined) = {
  bool has_max_bytes() const;
  void clear_max_bytes() ;
  ::uint64_t max_bytes() const;
  void set_max_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_max_bytes() const;
  void _internal_set_max_bytes(::uint64_t value);

  public:
  // optional uint64 len = 19 [json_name = "len", (.buf.validate.predefined) = {
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.predefined) = {
  bool has_len_bytes() const;
  void clear_len_bytes() ;
  ::uint64_t len_bytes() const;
  void set_len_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_len_bytes() const;
  void _internal_set_len_bytes(::uint64_t value);

  public:
  // optional bool strict = 25 [json_name = "strict"];
  bool has_strict() const;
  void clear_strict() ;
  bool strict() const;
  void set_strict(bool value);

  private:
  bool _internal_strict() const;
  void _internal_set_strict(bool value);

  public:
  // bool email = 12 [json_name = "email", (.buf.validate.predefined) = {
  bool has_email() const;
  void clear_email() ;
  bool email() const;
  void set_email(bool value);

  private:
  bool _internal_email() const;
  void _internal_set_email(bool value);

  public:
  // bool hostname = 13 [json_name = "hostname", (.buf.validate.predefined) = {
  bool has_hostname() const;
  void clear_hostname() ;
  bool hostname() const;
  void set_hostname(bool value);

  private:
  bool _internal_hostname() const;
  void _internal_set_hostname(bool value);

  public:
  // bool ip = 14 [json_name = "ip", (.buf.validate.predefined) = {
  bool has_ip() const;
  void clear_ip() ;
  bool ip() const;
  void set_ip(bool value);

  private:
  bool _internal_ip() const;
  void _internal_set_ip(bool value);

  public:
  // bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.predefined) = {
  bool has_ipv4() const;
  void clear_ipv4() ;
  bool ipv4() const;
  void set_ipv4(bool value);

  private:
  bool _internal_ipv4() const;
  void _internal_set_ipv4(bool value);

  public:
  // bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.predefined) = {
  bool has_ipv6() const;
  void clear_ipv6() ;
  bool ipv6() const;
  void set_ipv6(bool value);

  private:
  bool _internal_ipv6() const;
  void _internal_set_ipv6(bool value);

  public:
  // bool uri = 17 [json_name = "uri", (.buf.validate.predefined) = {
  bool has_uri() const;
  void clear_uri() ;
  bool uri() const;
  void set_uri(bool value);

  private:
  bool _internal_uri() const;
  void _internal_set_uri(bool value);

  public:
  // bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.predefined) = {
  bool has_uri_ref() const;
  void clear_uri_ref() ;
  bool uri_ref() const;
  void set_uri_ref(bool value);

  private:
  bool _internal_uri_ref() const;
  void _internal_set_uri_ref(bool value);

  public:
  // bool address = 21 [json_name = "address", (.buf.validate.predefined) = {
  bool has_address() const;
  void clear_address() ;
  bool address() const;
  void set_address(bool value);

  private:
  bool _internal_address() const;
  void _internal_set_address(bool value);

  public:
  // bool uuid = 22 [json_name = "uuid", (.buf.validate.predefined) = {
  bool has_uuid() const;
  void clear_uuid() ;
  bool uuid() const;
  void set_uuid(bool value);

  private:
  bool _internal_uuid() const;
  void _internal_set_uuid(bool value);

  public:
  // bool tuuid = 33 [json_name = "tuuid", (.buf.validate.predefined) = {
  bool has_tuuid() const;
  void clear_tuuid() ;
  bool tuuid() const;
  void set_tuuid(bool value);

  private:
  bool _internal_tuuid() const;
  void _internal_set_tuuid(bool value);

  public:
  // bool ip_with_prefixlen = 26 [json_name = "ipWithPrefixlen", (.buf.validate.predefined) = {
  bool has_ip_with_prefixlen() const;
  void clear_ip_with_prefixlen() ;
  bool ip_with_prefixlen() const;
  void set_ip_with_prefixlen(bool value);

  private:
  bool _internal_ip_with_prefixlen() const;
  void _internal_set_ip_with_prefixlen(bool value);

  public:
  // bool ipv4_with_prefixlen = 27 [json_name = "ipv4WithPrefixlen", (.buf.validate.predefined) = {
  bool has_ipv4_with_prefixlen() const;
  void clear_ipv4_with_prefixlen() ;
  bool ipv4_with_prefixlen() const;
  void set_ipv4_with_prefixlen(bool value);

  private:
  bool _internal_ipv4_with_prefixlen() const;
  void _internal_set_ipv4_with_prefixlen(bool value);

  public:
  // bool ipv6_with_prefixlen = 28 [json_name = "ipv6WithPrefixlen", (.buf.validate.predefined) = {
  bool has_ipv6_with_prefixlen() const;
  void clear_ipv6_with_prefixlen() ;
  bool ipv6_with_prefixlen() const;
  void set_ipv6_with_prefixlen(bool value);

  private:
  bool _internal_ipv6_with_prefixlen() const;
  void _internal_set_ipv6_with_prefixlen(bool value);

  public:
  // bool ip_prefix = 29 [json_name = "ipPrefix", (.buf.validate.predefined) = {
  bool has_ip_prefix() const;
  void clear_ip_prefix() ;
  bool ip_prefix() const;
  void set_ip_prefix(bool value);

  private:
  bool _internal_ip_prefix() const;
  void _internal_set_ip_prefix(bool value);

  public:
  // bool ipv4_prefix = 30 [json_name = "ipv4Prefix", (.buf.validate.predefined) = {
  bool has_ipv4_prefix() const;
  void clear_ipv4_prefix() ;
  bool ipv4_prefix() const;
  void set_ipv4_prefix(bool value);

  private:
  bool _internal_ipv4_prefix() const;
  void _internal_set_ipv4_prefix(bool value);

  public:
  // bool ipv6_prefix = 31 [json_name = "ipv6Prefix", (.buf.validate.predefined) = {
  bool has_ipv6_prefix() const;
  void clear_ipv6_prefix() ;
  bool ipv6_prefix() const;
  void set_ipv6_prefix(bool value);

  private:
  bool _internal_ipv6_prefix() const;
  void _internal_set_ipv6_prefix(bool value);

  public:
  // bool host_and_port = 32 [json_name = "hostAndPort", (.buf.validate.predefined) = {
  bool has_host_and_port() const;
  void clear_host_and_port() ;
  bool host_and_port() const;
  void set_host_and_port(bool value);

  private:
  bool _internal_host_and_port() const;
  void _internal_set_host_and_port(bool value);

  public:
  // .buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.predefined) = {
  bool has_well_known_regex() const;
  void clear_well_known_regex() ;
  ::buf::validate::KnownRegex well_known_regex() const;
  void set_well_known_regex(::buf::validate::KnownRegex value);

  private:
  ::buf::validate::KnownRegex _internal_well_known_regex() const;
  void _internal_set_well_known_regex(::buf::validate::KnownRegex value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StringRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_well_known();
  WellKnownCase well_known_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.StringRules)
 private:
  class _Internal;
  void set_has_email();
  void set_has_hostname();
  void set_has_ip();
  void set_has_ipv4();
  void set_has_ipv6();
  void set_has_uri();
  void set_has_uri_ref();
  void set_has_address();
  void set_has_uuid();
  void set_has_tuuid();
  void set_has_ip_with_prefixlen();
  void set_has_ipv4_with_prefixlen();
  void set_has_ipv6_with_prefixlen();
  void set_has_ip_prefix();
  void set_has_ipv4_prefix();
  void set_has_ipv6_prefix();
  void set_has_host_and_port();
  void set_has_well_known_regex();
  inline bool has_well_known() const;
  inline void clear_has_well_known();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 34, 1,
      124, 7>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StringRules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StringRules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> in_;
    ::google::protobuf::RepeatedPtrField<std::string> not_in_;
    ::google::protobuf::RepeatedPtrField<std::string> example_;
    ::google::protobuf::internal::ArenaStringPtr const__;
    ::google::protobuf::internal::ArenaStringPtr pattern_;
    ::google::protobuf::internal::ArenaStringPtr prefix_;
    ::google::protobuf::internal::ArenaStringPtr suffix_;
    ::google::protobuf::internal::ArenaStringPtr contains_;
    ::google::protobuf::internal::ArenaStringPtr not_contains_;
    ::uint64_t min_len_;
    ::uint64_t max_len_;
    ::uint64_t min_bytes_;
    ::uint64_t max_bytes_;
    ::uint64_t len_;
    ::uint64_t len_bytes_;
    bool strict_;
    union WellKnownUnion {
      constexpr WellKnownUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool email_;
      bool hostname_;
      bool ip_;
      bool ipv4_;
      bool ipv6_;
      bool uri_;
      bool uri_ref_;
      bool address_;
      bool uuid_;
      bool tuuid_;
      bool ip_with_prefixlen_;
      bool ipv4_with_prefixlen_;
      bool ipv6_with_prefixlen_;
      bool ip_prefix_;
      bool ipv4_prefix_;
      bool ipv6_prefix_;
      bool host_and_port_;
      int well_known_regex_;
    } well_known_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class SInt64Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.SInt64Rules) */ {
 public:
  inline SInt64Rules() : SInt64Rules(nullptr) {}
  ~SInt64Rules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SInt64Rules(
      ::google::protobuf::internal::ConstantInitialized);

  inline SInt64Rules(const SInt64Rules& from) : SInt64Rules(nullptr, from) {}
  inline SInt64Rules(SInt64Rules&& from) noexcept
      : SInt64Rules(nullptr, std::move(from)) {}
  inline SInt64Rules& operator=(const SInt64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SInt64Rules& operator=(SInt64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SInt64Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const SInt64Rules* internal_default_instance() {
    return reinterpret_cast<const SInt64Rules*>(
        &_SInt64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SInt64Rules& a, SInt64Rules& b) { a.Swap(&b); }
  inline void Swap(SInt64Rules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SInt64Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SInt64Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SInt64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SInt64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SInt64Rules& from) { SInt64Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SInt64Rules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.SInt64Rules"; }

 protected:
  explicit SInt64Rules(::google::protobuf::Arena* arena);
  SInt64Rules(::google::protobuf::Arena* arena, const SInt64Rules& from);
  SInt64Rules(::google::protobuf::Arena* arena, SInt64Rules&& from) noexcept
      : SInt64Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 8,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated sint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int64_t in(int index) const;
  void set_in(int index, ::int64_t value);
  void add_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_in();

  public:
  // repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int64_t not_in(int index) const;
  void set_not_in(int index, ::int64_t value);
  void add_not_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_not_in();

  public:
  // repeated sint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::int64_t example(int index) const;
  void set_example(int index, ::int64_t value);
  void add_example(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& example() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_example() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_example();

  public:
  // optional sint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int64_t const_() const;
  void set_const_(::int64_t value);

  private:
  ::int64_t _internal_const_() const;
  void _internal_set_const_(::int64_t value);

  public:
  // sint64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int64_t lt() const;
  void set_lt(::int64_t value);

  private:
  ::int64_t _internal_lt() const;
  void _internal_set_lt(::int64_t value);

  public:
  // sint64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int64_t lte() const;
  void set_lte(::int64_t value);

  private:
  ::int64_t _internal_lte() const;
  void _internal_set_lte(::int64_t value);

  public:
  // sint64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int64_t gt() const;
  void set_gt(::int64_t value);

  private:
  ::int64_t _internal_gt() const;
  void _internal_set_gt(::int64_t value);

  public:
  // sint64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int64_t gte() const;
  void set_gte(::int64_t value);

  private:
  ::int64_t _internal_gte() const;
  void _internal_set_gte(::int64_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.SInt64Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SInt64Rules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SInt64Rules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> in_;
    ::google::protobuf::RepeatedField<::int64_t> not_in_;
    ::google::protobuf::RepeatedField<::int64_t> example_;
    ::int64_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t lt_;
      ::int64_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t gt_;
      ::int64_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class SInt32Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.SInt32Rules) */ {
 public:
  inline SInt32Rules() : SInt32Rules(nullptr) {}
  ~SInt32Rules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SInt32Rules(
      ::google::protobuf::internal::ConstantInitialized);

  inline SInt32Rules(const SInt32Rules& from) : SInt32Rules(nullptr, from) {}
  inline SInt32Rules(SInt32Rules&& from) noexcept
      : SInt32Rules(nullptr, std::move(from)) {}
  inline SInt32Rules& operator=(const SInt32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SInt32Rules& operator=(SInt32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SInt32Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const SInt32Rules* internal_default_instance() {
    return reinterpret_cast<const SInt32Rules*>(
        &_SInt32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SInt32Rules& a, SInt32Rules& b) { a.Swap(&b); }
  inline void Swap(SInt32Rules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SInt32Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SInt32Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SInt32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SInt32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SInt32Rules& from) { SInt32Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SInt32Rules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.SInt32Rules"; }

 protected:
  explicit SInt32Rules(::google::protobuf::Arena* arena);
  SInt32Rules(::google::protobuf::Arena* arena, const SInt32Rules& from);
  SInt32Rules(::google::protobuf::Arena* arena, SInt32Rules&& from) noexcept
      : SInt32Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 8,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated sint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_in();

  public:
  // repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_not_in();

  public:
  // repeated sint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::int32_t example(int index) const;
  void set_example(int index, ::int32_t value);
  void add_example(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& example() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_example() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_example();

  public:
  // optional sint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // sint32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int32_t lt() const;
  void set_lt(::int32_t value);

  private:
  ::int32_t _internal_lt() const;
  void _internal_set_lt(::int32_t value);

  public:
  // sint32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int32_t lte() const;
  void set_lte(::int32_t value);

  private:
  ::int32_t _internal_lte() const;
  void _internal_set_lte(::int32_t value);

  public:
  // sint32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int32_t gt() const;
  void set_gt(::int32_t value);

  private:
  ::int32_t _internal_gt() const;
  void _internal_set_gt(::int32_t value);

  public:
  // sint32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int32_t gte() const;
  void set_gte(::int32_t value);

  private:
  ::int32_t _internal_gte() const;
  void _internal_set_gte(::int32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SInt32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.SInt32Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SInt32Rules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SInt32Rules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    ::google::protobuf::RepeatedField<::int32_t> example_;
    ::int32_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t lt_;
      ::int32_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t gt_;
      ::int32_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class SFixed64Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.SFixed64Rules) */ {
 public:
  inline SFixed64Rules() : SFixed64Rules(nullptr) {}
  ~SFixed64Rules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SFixed64Rules(
      ::google::protobuf::internal::ConstantInitialized);

  inline SFixed64Rules(const SFixed64Rules& from) : SFixed64Rules(nullptr, from) {}
  inline SFixed64Rules(SFixed64Rules&& from) noexcept
      : SFixed64Rules(nullptr, std::move(from)) {}
  inline SFixed64Rules& operator=(const SFixed64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SFixed64Rules& operator=(SFixed64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SFixed64Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const SFixed64Rules* internal_default_instance() {
    return reinterpret_cast<const SFixed64Rules*>(
        &_SFixed64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(SFixed64Rules& a, SFixed64Rules& b) { a.Swap(&b); }
  inline void Swap(SFixed64Rules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SFixed64Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SFixed64Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SFixed64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SFixed64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SFixed64Rules& from) { SFixed64Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SFixed64Rules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.SFixed64Rules"; }

 protected:
  explicit SFixed64Rules(::google::protobuf::Arena* arena);
  SFixed64Rules(::google::protobuf::Arena* arena, const SFixed64Rules& from);
  SFixed64Rules(::google::protobuf::Arena* arena, SFixed64Rules&& from) noexcept
      : SFixed64Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 8,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int64_t in(int index) const;
  void set_in(int index, ::int64_t value);
  void add_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_in();

  public:
  // repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int64_t not_in(int index) const;
  void set_not_in(int index, ::int64_t value);
  void add_not_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_not_in();

  public:
  // repeated sfixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::int64_t example(int index) const;
  void set_example(int index, ::int64_t value);
  void add_example(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& example() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_example() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_example();

  public:
  // optional sfixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int64_t const_() const;
  void set_const_(::int64_t value);

  private:
  ::int64_t _internal_const_() const;
  void _internal_set_const_(::int64_t value);

  public:
  // sfixed64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int64_t lt() const;
  void set_lt(::int64_t value);

  private:
  ::int64_t _internal_lt() const;
  void _internal_set_lt(::int64_t value);

  public:
  // sfixed64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int64_t lte() const;
  void set_lte(::int64_t value);

  private:
  ::int64_t _internal_lte() const;
  void _internal_set_lte(::int64_t value);

  public:
  // sfixed64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int64_t gt() const;
  void set_gt(::int64_t value);

  private:
  ::int64_t _internal_gt() const;
  void _internal_set_gt(::int64_t value);

  public:
  // sfixed64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int64_t gte() const;
  void set_gte(::int64_t value);

  private:
  ::int64_t _internal_gte() const;
  void _internal_set_gte(::int64_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.SFixed64Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SFixed64Rules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SFixed64Rules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> in_;
    ::google::protobuf::RepeatedField<::int64_t> not_in_;
    ::google::protobuf::RepeatedField<::int64_t> example_;
    ::int64_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t lt_;
      ::int64_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t gt_;
      ::int64_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class SFixed32Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.SFixed32Rules) */ {
 public:
  inline SFixed32Rules() : SFixed32Rules(nullptr) {}
  ~SFixed32Rules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SFixed32Rules(
      ::google::protobuf::internal::ConstantInitialized);

  inline SFixed32Rules(const SFixed32Rules& from) : SFixed32Rules(nullptr, from) {}
  inline SFixed32Rules(SFixed32Rules&& from) noexcept
      : SFixed32Rules(nullptr, std::move(from)) {}
  inline SFixed32Rules& operator=(const SFixed32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SFixed32Rules& operator=(SFixed32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SFixed32Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const SFixed32Rules* internal_default_instance() {
    return reinterpret_cast<const SFixed32Rules*>(
        &_SFixed32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(SFixed32Rules& a, SFixed32Rules& b) { a.Swap(&b); }
  inline void Swap(SFixed32Rules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SFixed32Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SFixed32Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SFixed32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SFixed32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SFixed32Rules& from) { SFixed32Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SFixed32Rules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.SFixed32Rules"; }

 protected:
  explicit SFixed32Rules(::google::protobuf::Arena* arena);
  SFixed32Rules(::google::protobuf::Arena* arena, const SFixed32Rules& from);
  SFixed32Rules(::google::protobuf::Arena* arena, SFixed32Rules&& from) noexcept
      : SFixed32Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 8,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_in();

  public:
  // repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_not_in();

  public:
  // repeated sfixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::int32_t example(int index) const;
  void set_example(int index, ::int32_t value);
  void add_example(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& example() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_example() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_example();

  public:
  // optional sfixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // sfixed32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int32_t lt() const;
  void set_lt(::int32_t value);

  private:
  ::int32_t _internal_lt() const;
  void _internal_set_lt(::int32_t value);

  public:
  // sfixed32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int32_t lte() const;
  void set_lte(::int32_t value);

  private:
  ::int32_t _internal_lte() const;
  void _internal_set_lte(::int32_t value);

  public:
  // sfixed32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int32_t gt() const;
  void set_gt(::int32_t value);

  private:
  ::int32_t _internal_gt() const;
  void _internal_set_gt(::int32_t value);

  public:
  // sfixed32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int32_t gte() const;
  void set_gte(::int32_t value);

  private:
  ::int32_t _internal_gte() const;
  void _internal_set_gte(::int32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<SFixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.SFixed32Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SFixed32Rules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SFixed32Rules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    ::google::protobuf::RepeatedField<::int32_t> example_;
    ::int32_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t lt_;
      ::int32_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t gt_;
      ::int32_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class OneofConstraints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.OneofConstraints) */ {
 public:
  inline OneofConstraints() : OneofConstraints(nullptr) {}
  ~OneofConstraints() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OneofConstraints(
      ::google::protobuf::internal::ConstantInitialized);

  inline OneofConstraints(const OneofConstraints& from) : OneofConstraints(nullptr, from) {}
  inline OneofConstraints(OneofConstraints&& from) noexcept
      : OneofConstraints(nullptr, std::move(from)) {}
  inline OneofConstraints& operator=(const OneofConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneofConstraints& operator=(OneofConstraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneofConstraints& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneofConstraints* internal_default_instance() {
    return reinterpret_cast<const OneofConstraints*>(
        &_OneofConstraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(OneofConstraints& a, OneofConstraints& b) { a.Swap(&b); }
  inline void Swap(OneofConstraints* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneofConstraints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneofConstraints* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<OneofConstraints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OneofConstraints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OneofConstraints& from) { OneofConstraints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OneofConstraints* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.OneofConstraints"; }

 protected:
  explicit OneofConstraints(::google::protobuf::Arena* arena);
  OneofConstraints(::google::protobuf::Arena* arena, const OneofConstraints& from);
  OneofConstraints(::google::protobuf::Arena* arena, OneofConstraints&& from) noexcept
      : OneofConstraints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRequiredFieldNumber = 1,
  };
  // optional bool required = 1 [json_name = "required"];
  bool has_required() const;
  void clear_required() ;
  bool required() const;
  void set_required(bool value);

  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.OneofConstraints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_OneofConstraints_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OneofConstraints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool required_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class Int64Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.Int64Rules) */ {
 public:
  inline Int64Rules() : Int64Rules(nullptr) {}
  ~Int64Rules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Int64Rules(
      ::google::protobuf::internal::ConstantInitialized);

  inline Int64Rules(const Int64Rules& from) : Int64Rules(nullptr, from) {}
  inline Int64Rules(Int64Rules&& from) noexcept
      : Int64Rules(nullptr, std::move(from)) {}
  inline Int64Rules& operator=(const Int64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int64Rules& operator=(Int64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int64Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const Int64Rules* internal_default_instance() {
    return reinterpret_cast<const Int64Rules*>(
        &_Int64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Int64Rules& a, Int64Rules& b) { a.Swap(&b); }
  inline void Swap(Int64Rules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int64Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int64Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Int64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Int64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Int64Rules& from) { Int64Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Int64Rules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.Int64Rules"; }

 protected:
  explicit Int64Rules(::google::protobuf::Arena* arena);
  Int64Rules(::google::protobuf::Arena* arena, const Int64Rules& from);
  Int64Rules(::google::protobuf::Arena* arena, Int64Rules&& from) noexcept
      : Int64Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 9,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated int64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int64_t in(int index) const;
  void set_in(int index, ::int64_t value);
  void add_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_in();

  public:
  // repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int64_t not_in(int index) const;
  void set_not_in(int index, ::int64_t value);
  void add_not_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_not_in();

  public:
  // repeated int64 example = 9 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::int64_t example(int index) const;
  void set_example(int index, ::int64_t value);
  void add_example(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& example() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_example() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_example();

  public:
  // optional int64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int64_t const_() const;
  void set_const_(::int64_t value);

  private:
  ::int64_t _internal_const_() const;
  void _internal_set_const_(::int64_t value);

  public:
  // int64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int64_t lt() const;
  void set_lt(::int64_t value);

  private:
  ::int64_t _internal_lt() const;
  void _internal_set_lt(::int64_t value);

  public:
  // int64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int64_t lte() const;
  void set_lte(::int64_t value);

  private:
  ::int64_t _internal_lte() const;
  void _internal_set_lte(::int64_t value);

  public:
  // int64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int64_t gt() const;
  void set_gt(::int64_t value);

  private:
  ::int64_t _internal_gt() const;
  void _internal_set_gt(::int64_t value);

  public:
  // int64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int64_t gte() const;
  void set_gte(::int64_t value);

  private:
  ::int64_t _internal_gte() const;
  void _internal_set_gte(::int64_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.Int64Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Int64Rules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Int64Rules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> in_;
    ::google::protobuf::RepeatedField<::int64_t> not_in_;
    ::google::protobuf::RepeatedField<::int64_t> example_;
    ::int64_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t lt_;
      ::int64_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t gt_;
      ::int64_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class Int32Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.Int32Rules) */ {
 public:
  inline Int32Rules() : Int32Rules(nullptr) {}
  ~Int32Rules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Int32Rules(
      ::google::protobuf::internal::ConstantInitialized);

  inline Int32Rules(const Int32Rules& from) : Int32Rules(nullptr, from) {}
  inline Int32Rules(Int32Rules&& from) noexcept
      : Int32Rules(nullptr, std::move(from)) {}
  inline Int32Rules& operator=(const Int32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int32Rules& operator=(Int32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int32Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const Int32Rules* internal_default_instance() {
    return reinterpret_cast<const Int32Rules*>(
        &_Int32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Int32Rules& a, Int32Rules& b) { a.Swap(&b); }
  inline void Swap(Int32Rules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int32Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int32Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Int32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Int32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Int32Rules& from) { Int32Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Int32Rules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.Int32Rules"; }

 protected:
  explicit Int32Rules(::google::protobuf::Arena* arena);
  Int32Rules(::google::protobuf::Arena* arena, const Int32Rules& from);
  Int32Rules(::google::protobuf::Arena* arena, Int32Rules&& from) noexcept
      : Int32Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 8,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated int32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_in();

  public:
  // repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_not_in();

  public:
  // repeated int32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::int32_t example(int index) const;
  void set_example(int index, ::int32_t value);
  void add_example(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& example() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_example() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_example();

  public:
  // optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // int32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int32_t lt() const;
  void set_lt(::int32_t value);

  private:
  ::int32_t _internal_lt() const;
  void _internal_set_lt(::int32_t value);

  public:
  // int32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int32_t lte() const;
  void set_lte(::int32_t value);

  private:
  ::int32_t _internal_lte() const;
  void _internal_set_lte(::int32_t value);

  public:
  // int32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int32_t gt() const;
  void set_gt(::int32_t value);

  private:
  ::int32_t _internal_gt() const;
  void _internal_set_gt(::int32_t value);

  public:
  // int32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int32_t gte() const;
  void set_gte(::int32_t value);

  private:
  ::int32_t _internal_gte() const;
  void _internal_set_gte(::int32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Int32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.Int32Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Int32Rules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Int32Rules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    ::google::protobuf::RepeatedField<::int32_t> example_;
    ::int32_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t lt_;
      ::int32_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t gt_;
      ::int32_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class FloatRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.FloatRules) */ {
 public:
  inline FloatRules() : FloatRules(nullptr) {}
  ~FloatRules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FloatRules(
      ::google::protobuf::internal::ConstantInitialized);

  inline FloatRules(const FloatRules& from) : FloatRules(nullptr, from) {}
  inline FloatRules(FloatRules&& from) noexcept
      : FloatRules(nullptr, std::move(from)) {}
  inline FloatRules& operator=(const FloatRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatRules& operator=(FloatRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatRules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const FloatRules* internal_default_instance() {
    return reinterpret_cast<const FloatRules*>(
        &_FloatRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(FloatRules& a, FloatRules& b) { a.Swap(&b); }
  inline void Swap(FloatRules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FloatRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FloatRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FloatRules& from) { FloatRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FloatRules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.FloatRules"; }

 protected:
  explicit FloatRules(::google::protobuf::Arena* arena);
  FloatRules(::google::protobuf::Arena* arena, const FloatRules& from);
  FloatRules(::google::protobuf::Arena* arena, FloatRules&& from) noexcept
      : FloatRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 9,
    kConstFieldNumber = 1,
    kFiniteFieldNumber = 8,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated float in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  float in(int index) const;
  void set_in(int index, float value);
  void add_in(float value);
  const ::google::protobuf::RepeatedField<float>& in() const;
  ::google::protobuf::RepeatedField<float>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_in() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_in();

  public:
  // repeated float not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  float not_in(int index) const;
  void set_not_in(int index, float value);
  void add_not_in(float value);
  const ::google::protobuf::RepeatedField<float>& not_in() const;
  ::google::protobuf::RepeatedField<float>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_not_in();

  public:
  // repeated float example = 9 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  float example(int index) const;
  void set_example(int index, float value);
  void add_example(float value);
  const ::google::protobuf::RepeatedField<float>& example() const;
  ::google::protobuf::RepeatedField<float>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_example() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_example();

  public:
  // optional float const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  float const_() const;
  void set_const_(float value);

  private:
  float _internal_const_() const;
  void _internal_set_const_(float value);

  public:
  // optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
  bool has_finite() const;
  void clear_finite() ;
  bool finite() const;
  void set_finite(bool value);

  private:
  bool _internal_finite() const;
  void _internal_set_finite(bool value);

  public:
  // float lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  float lt() const;
  void set_lt(float value);

  private:
  float _internal_lt() const;
  void _internal_set_lt(float value);

  public:
  // float lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  float lte() const;
  void set_lte(float value);

  private:
  float _internal_lte() const;
  void _internal_set_lte(float value);

  public:
  // float gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  float gt() const;
  void set_gt(float value);

  private:
  float _internal_gt() const;
  void _internal_set_gt(float value);

  public:
  // float gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  float gte() const;
  void set_gte(float value);

  private:
  float _internal_gte() const;
  void _internal_set_gte(float value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FloatRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.FloatRules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FloatRules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FloatRules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> in_;
    ::google::protobuf::RepeatedField<float> not_in_;
    ::google::protobuf::RepeatedField<float> example_;
    float const__;
    bool finite_;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      float lt_;
      float lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      float gt_;
      float gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class Fixed64Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.Fixed64Rules) */ {
 public:
  inline Fixed64Rules() : Fixed64Rules(nullptr) {}
  ~Fixed64Rules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Fixed64Rules(
      ::google::protobuf::internal::ConstantInitialized);

  inline Fixed64Rules(const Fixed64Rules& from) : Fixed64Rules(nullptr, from) {}
  inline Fixed64Rules(Fixed64Rules&& from) noexcept
      : Fixed64Rules(nullptr, std::move(from)) {}
  inline Fixed64Rules& operator=(const Fixed64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fixed64Rules& operator=(Fixed64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fixed64Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const Fixed64Rules* internal_default_instance() {
    return reinterpret_cast<const Fixed64Rules*>(
        &_Fixed64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(Fixed64Rules& a, Fixed64Rules& b) { a.Swap(&b); }
  inline void Swap(Fixed64Rules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fixed64Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fixed64Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Fixed64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Fixed64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Fixed64Rules& from) { Fixed64Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Fixed64Rules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.Fixed64Rules"; }

 protected:
  explicit Fixed64Rules(::google::protobuf::Arena* arena);
  Fixed64Rules(::google::protobuf::Arena* arena, const Fixed64Rules& from);
  Fixed64Rules(::google::protobuf::Arena* arena, Fixed64Rules&& from) noexcept
      : Fixed64Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 8,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated fixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint64_t in(int index) const;
  void set_in(int index, ::uint64_t value);
  void add_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_in();

  public:
  // repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint64_t not_in(int index) const;
  void set_not_in(int index, ::uint64_t value);
  void add_not_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_not_in();

  public:
  // repeated fixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::uint64_t example(int index) const;
  void set_example(int index, ::uint64_t value);
  void add_example(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& example() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_example() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_example();

  public:
  // optional fixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  ::uint64_t const_() const;
  void set_const_(::uint64_t value);

  private:
  ::uint64_t _internal_const_() const;
  void _internal_set_const_(::uint64_t value);

  public:
  // fixed64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  ::uint64_t lt() const;
  void set_lt(::uint64_t value);

  private:
  ::uint64_t _internal_lt() const;
  void _internal_set_lt(::uint64_t value);

  public:
  // fixed64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  ::uint64_t lte() const;
  void set_lte(::uint64_t value);

  private:
  ::uint64_t _internal_lte() const;
  void _internal_set_lte(::uint64_t value);

  public:
  // fixed64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  ::uint64_t gt() const;
  void set_gt(::uint64_t value);

  private:
  ::uint64_t _internal_gt() const;
  void _internal_set_gt(::uint64_t value);

  public:
  // fixed64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  ::uint64_t gte() const;
  void set_gte(::uint64_t value);

  private:
  ::uint64_t _internal_gte() const;
  void _internal_set_gte(::uint64_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed64Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.Fixed64Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Fixed64Rules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Fixed64Rules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> in_;
    ::google::protobuf::RepeatedField<::uint64_t> not_in_;
    ::google::protobuf::RepeatedField<::uint64_t> example_;
    ::uint64_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t lt_;
      ::uint64_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t gt_;
      ::uint64_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class Fixed32Rules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.Fixed32Rules) */ {
 public:
  inline Fixed32Rules() : Fixed32Rules(nullptr) {}
  ~Fixed32Rules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Fixed32Rules(
      ::google::protobuf::internal::ConstantInitialized);

  inline Fixed32Rules(const Fixed32Rules& from) : Fixed32Rules(nullptr, from) {}
  inline Fixed32Rules(Fixed32Rules&& from) noexcept
      : Fixed32Rules(nullptr, std::move(from)) {}
  inline Fixed32Rules& operator=(const Fixed32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fixed32Rules& operator=(Fixed32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fixed32Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const Fixed32Rules* internal_default_instance() {
    return reinterpret_cast<const Fixed32Rules*>(
        &_Fixed32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Fixed32Rules& a, Fixed32Rules& b) { a.Swap(&b); }
  inline void Swap(Fixed32Rules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fixed32Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fixed32Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Fixed32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Fixed32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Fixed32Rules& from) { Fixed32Rules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Fixed32Rules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.Fixed32Rules"; }

 protected:
  explicit Fixed32Rules(::google::protobuf::Arena* arena);
  Fixed32Rules(::google::protobuf::Arena* arena, const Fixed32Rules& from);
  Fixed32Rules(::google::protobuf::Arena* arena, Fixed32Rules&& from) noexcept
      : Fixed32Rules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 8,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated fixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint32_t in(int index) const;
  void set_in(int index, ::uint32_t value);
  void add_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_in();

  public:
  // repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint32_t not_in(int index) const;
  void set_not_in(int index, ::uint32_t value);
  void add_not_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_not_in();

  public:
  // repeated fixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::uint32_t example(int index) const;
  void set_example(int index, ::uint32_t value);
  void add_example(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& example() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_example() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_example();

  public:
  // optional fixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  ::uint32_t const_() const;
  void set_const_(::uint32_t value);

  private:
  ::uint32_t _internal_const_() const;
  void _internal_set_const_(::uint32_t value);

  public:
  // fixed32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  ::uint32_t lt() const;
  void set_lt(::uint32_t value);

  private:
  ::uint32_t _internal_lt() const;
  void _internal_set_lt(::uint32_t value);

  public:
  // fixed32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  ::uint32_t lte() const;
  void set_lte(::uint32_t value);

  private:
  ::uint32_t _internal_lte() const;
  void _internal_set_lte(::uint32_t value);

  public:
  // fixed32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  ::uint32_t gt() const;
  void set_gt(::uint32_t value);

  private:
  ::uint32_t _internal_gt() const;
  void _internal_set_gt(::uint32_t value);

  public:
  // fixed32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  ::uint32_t gte() const;
  void set_gte(::uint32_t value);

  private:
  ::uint32_t _internal_gte() const;
  void _internal_set_gte(::uint32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Fixed32Rules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.Fixed32Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Fixed32Rules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Fixed32Rules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> in_;
    ::google::protobuf::RepeatedField<::uint32_t> not_in_;
    ::google::protobuf::RepeatedField<::uint32_t> example_;
    ::uint32_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t lt_;
      ::uint32_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t gt_;
      ::uint32_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class EnumRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.EnumRules) */ {
 public:
  inline EnumRules() : EnumRules(nullptr) {}
  ~EnumRules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EnumRules(
      ::google::protobuf::internal::ConstantInitialized);

  inline EnumRules(const EnumRules& from) : EnumRules(nullptr, from) {}
  inline EnumRules(EnumRules&& from) noexcept
      : EnumRules(nullptr, std::move(from)) {}
  inline EnumRules& operator=(const EnumRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumRules& operator=(EnumRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnumRules& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnumRules* internal_default_instance() {
    return reinterpret_cast<const EnumRules*>(
        &_EnumRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(EnumRules& a, EnumRules& b) { a.Swap(&b); }
  inline void Swap(EnumRules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnumRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnumRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EnumRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EnumRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EnumRules& from) { EnumRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EnumRules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.EnumRules"; }

 protected:
  explicit EnumRules(::google::protobuf::Arena* arena);
  EnumRules(::google::protobuf::Arena* arena, const EnumRules& from);
  EnumRules(::google::protobuf::Arena* arena, EnumRules&& from) noexcept
      : EnumRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 3,
    kNotInFieldNumber = 4,
    kExampleFieldNumber = 5,
    kConstFieldNumber = 1,
    kDefinedOnlyFieldNumber = 2,
  };
  // repeated int32 in = 3 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_in();

  public:
  // repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_not_in();

  public:
  // repeated int32 example = 5 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::int32_t example(int index) const;
  void set_example(int index, ::int32_t value);
  void add_example(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& example() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_example() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_example();

  public:
  // optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // optional bool defined_only = 2 [json_name = "definedOnly"];
  bool has_defined_only() const;
  void clear_defined_only() ;
  bool defined_only() const;
  void set_defined_only(bool value);

  private:
  bool _internal_defined_only() const;
  void _internal_set_defined_only(bool value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EnumRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:buf.validate.EnumRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EnumRules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EnumRules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    ::google::protobuf::RepeatedField<::int32_t> example_;
    ::int32_t const__;
    bool defined_only_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class DoubleRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.DoubleRules) */ {
 public:
  inline DoubleRules() : DoubleRules(nullptr) {}
  ~DoubleRules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DoubleRules(
      ::google::protobuf::internal::ConstantInitialized);

  inline DoubleRules(const DoubleRules& from) : DoubleRules(nullptr, from) {}
  inline DoubleRules(DoubleRules&& from) noexcept
      : DoubleRules(nullptr, std::move(from)) {}
  inline DoubleRules& operator=(const DoubleRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleRules& operator=(DoubleRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleRules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const DoubleRules* internal_default_instance() {
    return reinterpret_cast<const DoubleRules*>(
        &_DoubleRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(DoubleRules& a, DoubleRules& b) { a.Swap(&b); }
  inline void Swap(DoubleRules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DoubleRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoubleRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DoubleRules& from) { DoubleRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DoubleRules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.DoubleRules"; }

 protected:
  explicit DoubleRules(::google::protobuf::Arena* arena);
  DoubleRules(::google::protobuf::Arena* arena, const DoubleRules& from);
  DoubleRules(::google::protobuf::Arena* arena, DoubleRules&& from) noexcept
      : DoubleRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kExampleFieldNumber = 9,
    kConstFieldNumber = 1,
    kFiniteFieldNumber = 8,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated double in = 6 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  double in(int index) const;
  void set_in(int index, double value);
  void add_in(double value);
  const ::google::protobuf::RepeatedField<double>& in() const;
  ::google::protobuf::RepeatedField<double>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_in() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_in();

  public:
  // repeated double not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  double not_in(int index) const;
  void set_not_in(int index, double value);
  void add_not_in(double value);
  const ::google::protobuf::RepeatedField<double>& not_in() const;
  ::google::protobuf::RepeatedField<double>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_not_in();

  public:
  // repeated double example = 9 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  double example(int index) const;
  void set_example(int index, double value);
  void add_example(double value);
  const ::google::protobuf::RepeatedField<double>& example() const;
  ::google::protobuf::RepeatedField<double>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_example() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_example();

  public:
  // optional double const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  double const_() const;
  void set_const_(double value);

  private:
  double _internal_const_() const;
  void _internal_set_const_(double value);

  public:
  // optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
  bool has_finite() const;
  void clear_finite() ;
  bool finite() const;
  void set_finite(bool value);

  private:
  bool _internal_finite() const;
  void _internal_set_finite(bool value);

  public:
  // double lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  void clear_lt() ;
  double lt() const;
  void set_lt(double value);

  private:
  double _internal_lt() const;
  void _internal_set_lt(double value);

  public:
  // double lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  void clear_lte() ;
  double lte() const;
  void set_lte(double value);

  private:
  double _internal_lte() const;
  void _internal_set_lte(double value);

  public:
  // double gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  void clear_gt() ;
  double gt() const;
  void set_gt(double value);

  private:
  double _internal_gt() const;
  void _internal_set_gt(double value);

  public:
  // double gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  void clear_gte() ;
  double gte() const;
  void set_gte(double value);

  private:
  double _internal_gte() const;
  void _internal_set_gte(double value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DoubleRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.DoubleRules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DoubleRules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DoubleRules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> in_;
    ::google::protobuf::RepeatedField<double> not_in_;
    ::google::protobuf::RepeatedField<double> example_;
    double const__;
    bool finite_;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      double lt_;
      double lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      double gt_;
      double gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class Constraint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.Constraint) */ {
 public:
  inline Constraint() : Constraint(nullptr) {}
  ~Constraint() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Constraint(
      ::google::protobuf::internal::ConstantInitialized);

  inline Constraint(const Constraint& from) : Constraint(nullptr, from) {}
  inline Constraint(Constraint&& from) noexcept
      : Constraint(nullptr, std::move(from)) {}
  inline Constraint& operator=(const Constraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Constraint& operator=(Constraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Constraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Constraint* internal_default_instance() {
    return reinterpret_cast<const Constraint*>(
        &_Constraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Constraint& a, Constraint& b) { a.Swap(&b); }
  inline void Swap(Constraint* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Constraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Constraint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Constraint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Constraint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Constraint& from) { Constraint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Constraint* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.Constraint"; }

 protected:
  explicit Constraint(::google::protobuf::Arena* arena);
  Constraint(::google::protobuf::Arena* arena, const Constraint& from);
  Constraint(::google::protobuf::Arena* arena, Constraint&& from) noexcept
      : Constraint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kMessageFieldNumber = 2,
    kExpressionFieldNumber = 3,
  };
  // optional string id = 1 [json_name = "id"];
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string message = 2 [json_name = "message"];
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // optional string expression = 3 [json_name = "expression"];
  bool has_expression() const;
  void clear_expression() ;
  const std::string& expression() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_expression(Arg_&& arg, Args_... args);
  std::string* mutable_expression();
  PROTOBUF_NODISCARD std::string* release_expression();
  void set_allocated_expression(std::string* value);

  private:
  const std::string& _internal_expression() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expression(
      const std::string& value);
  std::string* _internal_mutable_expression();

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.Constraint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      51, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Constraint_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Constraint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr expression_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class BytesRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.BytesRules) */ {
 public:
  inline BytesRules() : BytesRules(nullptr) {}
  ~BytesRules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BytesRules(
      ::google::protobuf::internal::ConstantInitialized);

  inline BytesRules(const BytesRules& from) : BytesRules(nullptr, from) {}
  inline BytesRules(BytesRules&& from) noexcept
      : BytesRules(nullptr, std::move(from)) {}
  inline BytesRules& operator=(const BytesRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline BytesRules& operator=(BytesRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BytesRules& default_instance() {
    return *internal_default_instance();
  }
  enum WellKnownCase {
    kIp = 10,
    kIpv4 = 11,
    kIpv6 = 12,
    WELL_KNOWN_NOT_SET = 0,
  };
  static inline const BytesRules* internal_default_instance() {
    return reinterpret_cast<const BytesRules*>(
        &_BytesRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(BytesRules& a, BytesRules& b) { a.Swap(&b); }
  inline void Swap(BytesRules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BytesRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BytesRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BytesRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BytesRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BytesRules& from) { BytesRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BytesRules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.BytesRules"; }

 protected:
  explicit BytesRules(::google::protobuf::Arena* arena);
  BytesRules(::google::protobuf::Arena* arena, const BytesRules& from);
  BytesRules(::google::protobuf::Arena* arena, BytesRules&& from) noexcept
      : BytesRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 8,
    kNotInFieldNumber = 9,
    kExampleFieldNumber = 14,
    kConstFieldNumber = 1,
    kPatternFieldNumber = 4,
    kPrefixFieldNumber = 5,
    kSuffixFieldNumber = 6,
    kContainsFieldNumber = 7,
    kMinLenFieldNumber = 2,
    kMaxLenFieldNumber = 3,
    kLenFieldNumber = 13,
    kIpFieldNumber = 10,
    kIpv4FieldNumber = 11,
    kIpv6FieldNumber = 12,
  };
  // repeated bytes in = 8 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  const std::string& in(int index) const;
  std::string* mutable_in(int index);
  void set_in(int index, const std::string& value);
  void set_in(int index, std::string&& value);
  void set_in(int index, const char* value);
  void set_in(int index, const void* value, std::size_t size);
  void set_in(int index, absl::string_view value);
  std::string* add_in();
  void add_in(const std::string& value);
  void add_in(std::string&& value);
  void add_in(const char* value);
  void add_in(const void* value, std::size_t size);
  void add_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_in();

  public:
  // repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  const std::string& not_in(int index) const;
  std::string* mutable_not_in(int index);
  void set_not_in(int index, const std::string& value);
  void set_not_in(int index, std::string&& value);
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const void* value, std::size_t size);
  void set_not_in(int index, absl::string_view value);
  std::string* add_not_in();
  void add_not_in(const std::string& value);
  void add_not_in(std::string&& value);
  void add_not_in(const char* value);
  void add_not_in(const void* value, std::size_t size);
  void add_not_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_not_in();

  public:
  // repeated bytes example = 14 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  const std::string& example(int index) const;
  std::string* mutable_example(int index);
  void set_example(int index, const std::string& value);
  void set_example(int index, std::string&& value);
  void set_example(int index, const char* value);
  void set_example(int index, const void* value, std::size_t size);
  void set_example(int index, absl::string_view value);
  std::string* add_example();
  void add_example(const std::string& value);
  void add_example(std::string&& value);
  void add_example(const char* value);
  void add_example(const void* value, std::size_t size);
  void add_example(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& example() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_example();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_example() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_example();

  public:
  // optional bytes const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  const std::string& const_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_const_(Arg_&& arg, Args_... args);
  std::string* mutable_const_();
  PROTOBUF_NODISCARD std::string* release_const_();
  void set_allocated_const_(std::string* value);

  private:
  const std::string& _internal_const_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_const_(
      const std::string& value);
  std::string* _internal_mutable_const_();

  public:
  // optional string pattern = 4 [json_name = "pattern", (.buf.validate.predefined) = {
  bool has_pattern() const;
  void clear_pattern() ;
  const std::string& pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* value);

  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(
      const std::string& value);
  std::string* _internal_mutable_pattern();

  public:
  // optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.predefined) = {
  bool has_prefix() const;
  void clear_prefix() ;
  const std::string& prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* value);

  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(
      const std::string& value);
  std::string* _internal_mutable_prefix();

  public:
  // optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.predefined) = {
  bool has_suffix() const;
  void clear_suffix() ;
  const std::string& suffix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_suffix(Arg_&& arg, Args_... args);
  std::string* mutable_suffix();
  PROTOBUF_NODISCARD std::string* release_suffix();
  void set_allocated_suffix(std::string* value);

  private:
  const std::string& _internal_suffix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(
      const std::string& value);
  std::string* _internal_mutable_suffix();

  public:
  // optional bytes contains = 7 [json_name = "contains", (.buf.validate.predefined) = {
  bool has_contains() const;
  void clear_contains() ;
  const std::string& contains() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contains(Arg_&& arg, Args_... args);
  std::string* mutable_contains();
  PROTOBUF_NODISCARD std::string* release_contains();
  void set_allocated_contains(std::string* value);

  private:
  const std::string& _internal_contains() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contains(
      const std::string& value);
  std::string* _internal_mutable_contains();

  public:
  // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
  bool has_min_len() const;
  void clear_min_len() ;
  ::uint64_t min_len() const;
  void set_min_len(::uint64_t value);

  private:
  ::uint64_t _internal_min_len() const;
  void _internal_set_min_len(::uint64_t value);

  public:
  // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
  bool has_max_len() const;
  void clear_max_len() ;
  ::uint64_t max_len() const;
  void set_max_len(::uint64_t value);

  private:
  ::uint64_t _internal_max_len() const;
  void _internal_set_max_len(::uint64_t value);

  public:
  // optional uint64 len = 13 [json_name = "len", (.buf.validate.predefined) = {
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // bool ip = 10 [json_name = "ip", (.buf.validate.predefined) = {
  bool has_ip() const;
  void clear_ip() ;
  bool ip() const;
  void set_ip(bool value);

  private:
  bool _internal_ip() const;
  void _internal_set_ip(bool value);

  public:
  // bool ipv4 = 11 [json_name = "ipv4", (.buf.validate.predefined) = {
  bool has_ipv4() const;
  void clear_ipv4() ;
  bool ipv4() const;
  void set_ipv4(bool value);

  private:
  bool _internal_ipv4() const;
  void _internal_set_ipv4(bool value);

  public:
  // bool ipv6 = 12 [json_name = "ipv6", (.buf.validate.predefined) = {
  bool has_ipv6() const;
  void clear_ipv6() ;
  bool ipv6() const;
  void set_ipv6(bool value);

  private:
  bool _internal_ipv6() const;
  void _internal_set_ipv6(bool value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BytesRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_well_known();
  WellKnownCase well_known_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.BytesRules)
 private:
  class _Internal;
  void set_has_ip();
  void set_has_ipv4();
  void set_has_ipv6();
  inline bool has_well_known() const;
  inline void clear_has_well_known();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 0,
      47, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_BytesRules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BytesRules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> in_;
    ::google::protobuf::RepeatedPtrField<std::string> not_in_;
    ::google::protobuf::RepeatedPtrField<std::string> example_;
    ::google::protobuf::internal::ArenaStringPtr const__;
    ::google::protobuf::internal::ArenaStringPtr pattern_;
    ::google::protobuf::internal::ArenaStringPtr prefix_;
    ::google::protobuf::internal::ArenaStringPtr suffix_;
    ::google::protobuf::internal::ArenaStringPtr contains_;
    ::uint64_t min_len_;
    ::uint64_t max_len_;
    ::uint64_t len_;
    union WellKnownUnion {
      constexpr WellKnownUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool ip_;
      bool ipv4_;
      bool ipv6_;
    } well_known_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class BoolRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.BoolRules) */ {
 public:
  inline BoolRules() : BoolRules(nullptr) {}
  ~BoolRules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BoolRules(
      ::google::protobuf::internal::ConstantInitialized);

  inline BoolRules(const BoolRules& from) : BoolRules(nullptr, from) {}
  inline BoolRules(BoolRules&& from) noexcept
      : BoolRules(nullptr, std::move(from)) {}
  inline BoolRules& operator=(const BoolRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolRules& operator=(BoolRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolRules& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolRules* internal_default_instance() {
    return reinterpret_cast<const BoolRules*>(
        &_BoolRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(BoolRules& a, BoolRules& b) { a.Swap(&b); }
  inline void Swap(BoolRules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BoolRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BoolRules& from) { BoolRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BoolRules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.BoolRules"; }

 protected:
  explicit BoolRules(::google::protobuf::Arena* arena);
  BoolRules(::google::protobuf::Arena* arena, const BoolRules& from);
  BoolRules(::google::protobuf::Arena* arena, BoolRules&& from) noexcept
      : BoolRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExampleFieldNumber = 2,
    kConstFieldNumber = 1,
  };
  // repeated bool example = 2 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  bool example(int index) const;
  void set_example(int index, bool value);
  void add_example(bool value);
  const ::google::protobuf::RepeatedField<bool>& example() const;
  ::google::protobuf::RepeatedField<bool>* mutable_example();

  private:
  const ::google::protobuf::RepeatedField<bool>& _internal_example() const;
  ::google::protobuf::RepeatedField<bool>* _internal_mutable_example();

  public:
  // optional bool const = 1 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  bool const_() const;
  void set_const_(bool value);

  private:
  bool _internal_const_() const;
  void _internal_set_const_(bool value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<BoolRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:buf.validate.BoolRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_BoolRules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BoolRules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<bool> example_;
    bool const__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class AnyRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.AnyRules) */ {
 public:
  inline AnyRules() : AnyRules(nullptr) {}
  ~AnyRules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AnyRules(
      ::google::protobuf::internal::ConstantInitialized);

  inline AnyRules(const AnyRules& from) : AnyRules(nullptr, from) {}
  inline AnyRules(AnyRules&& from) noexcept
      : AnyRules(nullptr, std::move(from)) {}
  inline AnyRules& operator=(const AnyRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnyRules& operator=(AnyRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnyRules& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnyRules* internal_default_instance() {
    return reinterpret_cast<const AnyRules*>(
        &_AnyRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(AnyRules& a, AnyRules& b) { a.Swap(&b); }
  inline void Swap(AnyRules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnyRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnyRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AnyRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnyRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AnyRules& from) { AnyRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnyRules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.AnyRules"; }

 protected:
  explicit AnyRules(::google::protobuf::Arena* arena);
  AnyRules(::google::protobuf::Arena* arena, const AnyRules& from);
  AnyRules(::google::protobuf::Arena* arena, AnyRules&& from) noexcept
      : AnyRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 2,
    kNotInFieldNumber = 3,
  };
  // repeated string in = 2 [json_name = "in"];
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  const std::string& in(int index) const;
  std::string* mutable_in(int index);
  void set_in(int index, const std::string& value);
  void set_in(int index, std::string&& value);
  void set_in(int index, const char* value);
  void set_in(int index, const char* value, std::size_t size);
  void set_in(int index, absl::string_view value);
  std::string* add_in();
  void add_in(const std::string& value);
  void add_in(std::string&& value);
  void add_in(const char* value);
  void add_in(const char* value, std::size_t size);
  void add_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_in();

  public:
  // repeated string not_in = 3 [json_name = "notIn"];
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  const std::string& not_in(int index) const;
  std::string* mutable_not_in(int index);
  void set_not_in(int index, const std::string& value);
  void set_not_in(int index, std::string&& value);
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const char* value, std::size_t size);
  void set_not_in(int index, absl::string_view value);
  std::string* add_not_in();
  void add_not_in(const std::string& value);
  void add_not_in(std::string&& value);
  void add_not_in(const char* value);
  void add_not_in(const char* value, std::size_t size);
  void add_not_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_not_in();

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.AnyRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AnyRules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AnyRules& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> in_;
    ::google::protobuf::RepeatedPtrField<std::string> not_in_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class Violations final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.Violations) */ {
 public:
  inline Violations() : Violations(nullptr) {}
  ~Violations() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Violations(
      ::google::protobuf::internal::ConstantInitialized);

  inline Violations(const Violations& from) : Violations(nullptr, from) {}
  inline Violations(Violations&& from) noexcept
      : Violations(nullptr, std::move(from)) {}
  inline Violations& operator=(const Violations& from) {
    CopyFrom(from);
    return *this;
  }
  inline Violations& operator=(Violations&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Violations& default_instance() {
    return *internal_default_instance();
  }
  static inline const Violations* internal_default_instance() {
    return reinterpret_cast<const Violations*>(
        &_Violations_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(Violations& a, Violations& b) { a.Swap(&b); }
  inline void Swap(Violations* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Violations* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Violations* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Violations>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Violations& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Violations& from) { Violations::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Violations* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.Violations"; }

 protected:
  explicit Violations(::google::protobuf::Arena* arena);
  Violations(::google::protobuf::Arena* arena, const Violations& from);
  Violations(::google::protobuf::Arena* arena, Violations&& from) noexcept
      : Violations(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kViolationsFieldNumber = 1,
  };
  // repeated .buf.validate.Violation violations = 1 [json_name = "violations"];
  int violations_size() const;
  private:
  int _internal_violations_size() const;

  public:
  void clear_violations() ;
  ::buf::validate::Violation* mutable_violations(int index);
  ::google::protobuf::RepeatedPtrField<::buf::validate::Violation>* mutable_violations();

  private:
  const ::google::protobuf::RepeatedPtrField<::buf::validate::Violation>& _internal_violations() const;
  ::google::protobuf::RepeatedPtrField<::buf::validate::Violation>* _internal_mutable_violations();
  public:
  const ::buf::validate::Violation& violations(int index) const;
  ::buf::validate::Violation* add_violations();
  const ::google::protobuf::RepeatedPtrField<::buf::validate::Violation>& violations() const;
  // @@protoc_insertion_point(class_scope:buf.validate.Violations)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Violations_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Violations& from_msg);
    ::google::protobuf::RepeatedPtrField< ::buf::validate::Violation > violations_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class TimestampRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.TimestampRules) */ {
 public:
  inline TimestampRules() : TimestampRules(nullptr) {}
  ~TimestampRules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TimestampRules(
      ::google::protobuf::internal::ConstantInitialized);

  inline TimestampRules(const TimestampRules& from) : TimestampRules(nullptr, from) {}
  inline TimestampRules(TimestampRules&& from) noexcept
      : TimestampRules(nullptr, std::move(from)) {}
  inline TimestampRules& operator=(const TimestampRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimestampRules& operator=(TimestampRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimestampRules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 3,
    kLte = 4,
    kLtNow = 7,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 5,
    kGte = 6,
    kGtNow = 8,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const TimestampRules* internal_default_instance() {
    return reinterpret_cast<const TimestampRules*>(
        &_TimestampRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(TimestampRules& a, TimestampRules& b) { a.Swap(&b); }
  inline void Swap(TimestampRules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimestampRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimestampRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TimestampRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimestampRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TimestampRules& from) { TimestampRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TimestampRules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.TimestampRules"; }

 protected:
  explicit TimestampRules(::google::protobuf::Arena* arena);
  TimestampRules(::google::protobuf::Arena* arena, const TimestampRules& from);
  TimestampRules(::google::protobuf::Arena* arena, TimestampRules&& from) noexcept
      : TimestampRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExampleFieldNumber = 10,
    kConstFieldNumber = 2,
    kWithinFieldNumber = 9,
    kLtFieldNumber = 3,
    kLteFieldNumber = 4,
    kLtNowFieldNumber = 7,
    kGtFieldNumber = 5,
    kGteFieldNumber = 6,
    kGtNowFieldNumber = 8,
  };
  // repeated .google.protobuf.Timestamp example = 10 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::google::protobuf::Timestamp* mutable_example(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Timestamp>* mutable_example();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Timestamp>& _internal_example() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Timestamp>* _internal_mutable_example();
  public:
  const ::google::protobuf::Timestamp& example(int index) const;
  ::google::protobuf::Timestamp* add_example();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Timestamp>& example() const;
  // optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  const ::google::protobuf::Timestamp& const_() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_const_();
  ::google::protobuf::Timestamp* mutable_const_();
  void set_allocated_const_(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_const_(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_const_();

  private:
  const ::google::protobuf::Timestamp& _internal_const_() const;
  ::google::protobuf::Timestamp* _internal_mutable_const_();

  public:
  // optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.predefined) = {
  bool has_within() const;
  void clear_within() ;
  const ::google::protobuf::Duration& within() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_within();
  ::google::protobuf::Duration* mutable_within();
  void set_allocated_within(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_within(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_within();

  private:
  const ::google::protobuf::Duration& _internal_within() const;
  ::google::protobuf::Duration* _internal_mutable_within();

  public:
  // .google.protobuf.Timestamp lt = 3 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  private:
  bool _internal_has_lt() const;

  public:
  void clear_lt() ;
  const ::google::protobuf::Timestamp& lt() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_lt();
  ::google::protobuf::Timestamp* mutable_lt();
  void set_allocated_lt(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_lt(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_lt();

  private:
  const ::google::protobuf::Timestamp& _internal_lt() const;
  ::google::protobuf::Timestamp* _internal_mutable_lt();

  public:
  // .google.protobuf.Timestamp lte = 4 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  private:
  bool _internal_has_lte() const;

  public:
  void clear_lte() ;
  const ::google::protobuf::Timestamp& lte() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_lte();
  ::google::protobuf::Timestamp* mutable_lte();
  void set_allocated_lte(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_lte(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_lte();

  private:
  const ::google::protobuf::Timestamp& _internal_lte() const;
  ::google::protobuf::Timestamp* _internal_mutable_lte();

  public:
  // bool lt_now = 7 [json_name = "ltNow", (.buf.validate.predefined) = {
  bool has_lt_now() const;
  void clear_lt_now() ;
  bool lt_now() const;
  void set_lt_now(bool value);

  private:
  bool _internal_lt_now() const;
  void _internal_set_lt_now(bool value);

  public:
  // .google.protobuf.Timestamp gt = 5 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  private:
  bool _internal_has_gt() const;

  public:
  void clear_gt() ;
  const ::google::protobuf::Timestamp& gt() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_gt();
  ::google::protobuf::Timestamp* mutable_gt();
  void set_allocated_gt(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_gt(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_gt();

  private:
  const ::google::protobuf::Timestamp& _internal_gt() const;
  ::google::protobuf::Timestamp* _internal_mutable_gt();

  public:
  // .google.protobuf.Timestamp gte = 6 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  private:
  bool _internal_has_gte() const;

  public:
  void clear_gte() ;
  const ::google::protobuf::Timestamp& gte() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_gte();
  ::google::protobuf::Timestamp* mutable_gte();
  void set_allocated_gte(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_gte(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_gte();

  private:
  const ::google::protobuf::Timestamp& _internal_gte() const;
  ::google::protobuf::Timestamp* _internal_mutable_gte();

  public:
  // bool gt_now = 8 [json_name = "gtNow", (.buf.validate.predefined) = {
  bool has_gt_now() const;
  void clear_gt_now() ;
  bool gt_now() const;
  void set_gt_now(bool value);

  private:
  bool _internal_gt_now() const;
  void _internal_set_gt_now(bool value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimestampRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.TimestampRules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_lt_now();
  void set_has_gt();
  void set_has_gte();
  void set_has_gt_now();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 7,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TimestampRules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TimestampRules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Timestamp > example_;
    ::google::protobuf::Timestamp* const__;
    ::google::protobuf::Duration* within_;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Timestamp* lt_;
      ::google::protobuf::Timestamp* lte_;
      bool lt_now_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Timestamp* gt_;
      ::google::protobuf::Timestamp* gte_;
      bool gt_now_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class PredefinedConstraints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.PredefinedConstraints) */ {
 public:
  inline PredefinedConstraints() : PredefinedConstraints(nullptr) {}
  ~PredefinedConstraints() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PredefinedConstraints(
      ::google::protobuf::internal::ConstantInitialized);

  inline PredefinedConstraints(const PredefinedConstraints& from) : PredefinedConstraints(nullptr, from) {}
  inline PredefinedConstraints(PredefinedConstraints&& from) noexcept
      : PredefinedConstraints(nullptr, std::move(from)) {}
  inline PredefinedConstraints& operator=(const PredefinedConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredefinedConstraints& operator=(PredefinedConstraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PredefinedConstraints& default_instance() {
    return *internal_default_instance();
  }
  static inline const PredefinedConstraints* internal_default_instance() {
    return reinterpret_cast<const PredefinedConstraints*>(
        &_PredefinedConstraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(PredefinedConstraints& a, PredefinedConstraints& b) { a.Swap(&b); }
  inline void Swap(PredefinedConstraints* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredefinedConstraints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PredefinedConstraints* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PredefinedConstraints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PredefinedConstraints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PredefinedConstraints& from) { PredefinedConstraints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PredefinedConstraints* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.PredefinedConstraints"; }

 protected:
  explicit PredefinedConstraints(::google::protobuf::Arena* arena);
  PredefinedConstraints(::google::protobuf::Arena* arena, const PredefinedConstraints& from);
  PredefinedConstraints(::google::protobuf::Arena* arena, PredefinedConstraints&& from) noexcept
      : PredefinedConstraints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCelFieldNumber = 1,
  };
  // repeated .buf.validate.Constraint cel = 1 [json_name = "cel"];
  int cel_size() const;
  private:
  int _internal_cel_size() const;

  public:
  void clear_cel() ;
  ::buf::validate::Constraint* mutable_cel(int index);
  ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>* mutable_cel();

  private:
  const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>& _internal_cel() const;
  ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>* _internal_mutable_cel();
  public:
  const ::buf::validate::Constraint& cel(int index) const;
  ::buf::validate::Constraint* add_cel();
  const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>& cel() const;
  // @@protoc_insertion_point(class_scope:buf.validate.PredefinedConstraints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PredefinedConstraints_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PredefinedConstraints& from_msg);
    ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint > cel_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class MessageConstraints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.MessageConstraints) */ {
 public:
  inline MessageConstraints() : MessageConstraints(nullptr) {}
  ~MessageConstraints() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MessageConstraints(
      ::google::protobuf::internal::ConstantInitialized);

  inline MessageConstraints(const MessageConstraints& from) : MessageConstraints(nullptr, from) {}
  inline MessageConstraints(MessageConstraints&& from) noexcept
      : MessageConstraints(nullptr, std::move(from)) {}
  inline MessageConstraints& operator=(const MessageConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageConstraints& operator=(MessageConstraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageConstraints& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageConstraints* internal_default_instance() {
    return reinterpret_cast<const MessageConstraints*>(
        &_MessageConstraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(MessageConstraints& a, MessageConstraints& b) { a.Swap(&b); }
  inline void Swap(MessageConstraints* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageConstraints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageConstraints* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MessageConstraints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessageConstraints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MessageConstraints& from) { MessageConstraints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MessageConstraints* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.MessageConstraints"; }

 protected:
  explicit MessageConstraints(::google::protobuf::Arena* arena);
  MessageConstraints(::google::protobuf::Arena* arena, const MessageConstraints& from);
  MessageConstraints(::google::protobuf::Arena* arena, MessageConstraints&& from) noexcept
      : MessageConstraints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCelFieldNumber = 3,
    kDisabledFieldNumber = 1,
  };
  // repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
  int cel_size() const;
  private:
  int _internal_cel_size() const;

  public:
  void clear_cel() ;
  ::buf::validate::Constraint* mutable_cel(int index);
  ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>* mutable_cel();

  private:
  const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>& _internal_cel() const;
  ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>* _internal_mutable_cel();
  public:
  const ::buf::validate::Constraint& cel(int index) const;
  ::buf::validate::Constraint* add_cel();
  const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>& cel() const;
  // optional bool disabled = 1 [json_name = "disabled"];
  bool has_disabled() const;
  void clear_disabled() ;
  bool disabled() const;
  void set_disabled(bool value);

  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.MessageConstraints)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MessageConstraints_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MessageConstraints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint > cel_;
    bool disabled_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class DurationRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.DurationRules) */ {
 public:
  inline DurationRules() : DurationRules(nullptr) {}
  ~DurationRules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DurationRules(
      ::google::protobuf::internal::ConstantInitialized);

  inline DurationRules(const DurationRules& from) : DurationRules(nullptr, from) {}
  inline DurationRules(DurationRules&& from) noexcept
      : DurationRules(nullptr, std::move(from)) {}
  inline DurationRules& operator=(const DurationRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline DurationRules& operator=(DurationRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DurationRules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 3,
    kLte = 4,
    LESS_THAN_NOT_SET = 0,
  };
  enum GreaterThanCase {
    kGt = 5,
    kGte = 6,
    GREATER_THAN_NOT_SET = 0,
  };
  static inline const DurationRules* internal_default_instance() {
    return reinterpret_cast<const DurationRules*>(
        &_DurationRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(DurationRules& a, DurationRules& b) { a.Swap(&b); }
  inline void Swap(DurationRules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DurationRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DurationRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DurationRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DurationRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DurationRules& from) { DurationRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DurationRules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.DurationRules"; }

 protected:
  explicit DurationRules(::google::protobuf::Arena* arena);
  DurationRules(::google::protobuf::Arena* arena, const DurationRules& from);
  DurationRules(::google::protobuf::Arena* arena, DurationRules&& from) noexcept
      : DurationRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInFieldNumber = 7,
    kNotInFieldNumber = 8,
    kExampleFieldNumber = 9,
    kConstFieldNumber = 2,
    kLtFieldNumber = 3,
    kLteFieldNumber = 4,
    kGtFieldNumber = 5,
    kGteFieldNumber = 6,
  };
  // repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.predefined) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::google::protobuf::Duration* mutable_in(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* mutable_in();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* _internal_mutable_in();
  public:
  const ::google::protobuf::Duration& in(int index) const;
  ::google::protobuf::Duration* add_in();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& in() const;
  // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.predefined) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::google::protobuf::Duration* mutable_not_in(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* _internal_mutable_not_in();
  public:
  const ::google::protobuf::Duration& not_in(int index) const;
  ::google::protobuf::Duration* add_not_in();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& not_in() const;
  // repeated .google.protobuf.Duration example = 9 [json_name = "example", (.buf.validate.predefined) = {
  int example_size() const;
  private:
  int _internal_example_size() const;

  public:
  void clear_example() ;
  ::google::protobuf::Duration* mutable_example(int index);
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* mutable_example();

  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& _internal_example() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* _internal_mutable_example();
  public:
  const ::google::protobuf::Duration& example(int index) const;
  ::google::protobuf::Duration* add_example();
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& example() const;
  // optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.predefined) = {
  bool has_const_() const;
  void clear_const_() ;
  const ::google::protobuf::Duration& const_() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_const_();
  ::google::protobuf::Duration* mutable_const_();
  void set_allocated_const_(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_const_(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_const_();

  private:
  const ::google::protobuf::Duration& _internal_const_() const;
  ::google::protobuf::Duration* _internal_mutable_const_();

  public:
  // .google.protobuf.Duration lt = 3 [json_name = "lt", (.buf.validate.predefined) = {
  bool has_lt() const;
  private:
  bool _internal_has_lt() const;

  public:
  void clear_lt() ;
  const ::google::protobuf::Duration& lt() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_lt();
  ::google::protobuf::Duration* mutable_lt();
  void set_allocated_lt(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_lt(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_lt();

  private:
  const ::google::protobuf::Duration& _internal_lt() const;
  ::google::protobuf::Duration* _internal_mutable_lt();

  public:
  // .google.protobuf.Duration lte = 4 [json_name = "lte", (.buf.validate.predefined) = {
  bool has_lte() const;
  private:
  bool _internal_has_lte() const;

  public:
  void clear_lte() ;
  const ::google::protobuf::Duration& lte() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_lte();
  ::google::protobuf::Duration* mutable_lte();
  void set_allocated_lte(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_lte(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_lte();

  private:
  const ::google::protobuf::Duration& _internal_lte() const;
  ::google::protobuf::Duration* _internal_mutable_lte();

  public:
  // .google.protobuf.Duration gt = 5 [json_name = "gt", (.buf.validate.predefined) = {
  bool has_gt() const;
  private:
  bool _internal_has_gt() const;

  public:
  void clear_gt() ;
  const ::google::protobuf::Duration& gt() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_gt();
  ::google::protobuf::Duration* mutable_gt();
  void set_allocated_gt(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_gt(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_gt();

  private:
  const ::google::protobuf::Duration& _internal_gt() const;
  ::google::protobuf::Duration* _internal_mutable_gt();

  public:
  // .google.protobuf.Duration gte = 6 [json_name = "gte", (.buf.validate.predefined) = {
  bool has_gte() const;
  private:
  bool _internal_has_gte() const;

  public:
  void clear_gte() ;
  const ::google::protobuf::Duration& gte() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_gte();
  ::google::protobuf::Duration* mutable_gte();
  void set_allocated_gte(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_gte(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_gte();

  private:
  const ::google::protobuf::Duration& _internal_gte() const;
  ::google::protobuf::Duration* _internal_mutable_gte();

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<DurationRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.DurationRules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();
  inline bool has_less_than() const;
  inline void clear_has_less_than();
  inline bool has_greater_than() const;
  inline void clear_has_greater_than();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 8, 8,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DurationRules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DurationRules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration > in_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration > not_in_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration > example_;
    ::google::protobuf::Duration* const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Duration* lt_;
      ::google::protobuf::Duration* lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Duration* gt_;
      ::google::protobuf::Duration* gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class FieldConstraints final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.FieldConstraints) */ {
 public:
  inline FieldConstraints() : FieldConstraints(nullptr) {}
  ~FieldConstraints() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FieldConstraints(
      ::google::protobuf::internal::ConstantInitialized);

  inline FieldConstraints(const FieldConstraints& from) : FieldConstraints(nullptr, from) {}
  inline FieldConstraints(FieldConstraints&& from) noexcept
      : FieldConstraints(nullptr, std::move(from)) {}
  inline FieldConstraints& operator=(const FieldConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldConstraints& operator=(FieldConstraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldConstraints& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kFloat = 1,
    kDouble = 2,
    kInt32 = 3,
    kInt64 = 4,
    kUint32 = 5,
    kUint64 = 6,
    kSint32 = 7,
    kSint64 = 8,
    kFixed32 = 9,
    kFixed64 = 10,
    kSfixed32 = 11,
    kSfixed64 = 12,
    kBool = 13,
    kString = 14,
    kBytes = 15,
    kEnum = 16,
    kRepeated = 18,
    kMap = 19,
    kAny = 20,
    kDuration = 21,
    kTimestamp = 22,
    TYPE_NOT_SET = 0,
  };
  static inline const FieldConstraints* internal_default_instance() {
    return reinterpret_cast<const FieldConstraints*>(
        &_FieldConstraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(FieldConstraints& a, FieldConstraints& b) { a.Swap(&b); }
  inline void Swap(FieldConstraints* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldConstraints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldConstraints* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FieldConstraints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FieldConstraints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FieldConstraints& from) { FieldConstraints::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FieldConstraints* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.FieldConstraints"; }

 protected:
  explicit FieldConstraints(::google::protobuf::Arena* arena);
  FieldConstraints(::google::protobuf::Arena* arena, const FieldConstraints& from);
  FieldConstraints(::google::protobuf::Arena* arena, FieldConstraints&& from) noexcept
      : FieldConstraints(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCelFieldNumber = 23,
    kRequiredFieldNumber = 25,
    kSkippedFieldNumber = 24,
    kIgnoreEmptyFieldNumber = 26,
    kIgnoreFieldNumber = 27,
    kFloatFieldNumber = 1,
    kDoubleFieldNumber = 2,
    kInt32FieldNumber = 3,
    kInt64FieldNumber = 4,
    kUint32FieldNumber = 5,
    kUint64FieldNumber = 6,
    kSint32FieldNumber = 7,
    kSint64FieldNumber = 8,
    kFixed32FieldNumber = 9,
    kFixed64FieldNumber = 10,
    kSfixed32FieldNumber = 11,
    kSfixed64FieldNumber = 12,
    kBoolFieldNumber = 13,
    kStringFieldNumber = 14,
    kBytesFieldNumber = 15,
    kEnumFieldNumber = 16,
    kRepeatedFieldNumber = 18,
    kMapFieldNumber = 19,
    kAnyFieldNumber = 20,
    kDurationFieldNumber = 21,
    kTimestampFieldNumber = 22,
  };
  // repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
  int cel_size() const;
  private:
  int _internal_cel_size() const;

  public:
  void clear_cel() ;
  ::buf::validate::Constraint* mutable_cel(int index);
  ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>* mutable_cel();

  private:
  const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>& _internal_cel() const;
  ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>* _internal_mutable_cel();
  public:
  const ::buf::validate::Constraint& cel(int index) const;
  ::buf::validate::Constraint* add_cel();
  const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>& cel() const;
  // optional bool required = 25 [json_name = "required"];
  bool has_required() const;
  void clear_required() ;
  bool required() const;
  void set_required(bool value);

  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);

  public:
  // optional bool skipped = 24 [json_name = "skipped", deprecated = true];
  [[deprecated]]  bool has_skipped() const;
  [[deprecated]]  void clear_skipped() ;
  [[deprecated]] bool skipped() const;
  [[deprecated]] void set_skipped(bool value);

  private:
  bool _internal_skipped() const;
  void _internal_set_skipped(bool value);

  public:
  // optional bool ignore_empty = 26 [json_name = "ignoreEmpty", deprecated = true];
  [[deprecated]]  bool has_ignore_empty() const;
  [[deprecated]]  void clear_ignore_empty() ;
  [[deprecated]] bool ignore_empty() const;
  [[deprecated]] void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // optional .buf.validate.Ignore ignore = 27 [json_name = "ignore"];
  bool has_ignore() const;
  void clear_ignore() ;
  ::buf::validate::Ignore ignore() const;
  void set_ignore(::buf::validate::Ignore value);

  private:
  ::buf::validate::Ignore _internal_ignore() const;
  void _internal_set_ignore(::buf::validate::Ignore value);

  public:
  // .buf.validate.FloatRules float = 1 [json_name = "float"];
  bool has_float_() const;
  private:
  bool _internal_has_float_() const;

  public:
  void clear_float_() ;
  const ::buf::validate::FloatRules& float_() const;
  PROTOBUF_NODISCARD ::buf::validate::FloatRules* release_float_();
  ::buf::validate::FloatRules* mutable_float_();
  void set_allocated_float_(::buf::validate::FloatRules* value);
  void unsafe_arena_set_allocated_float_(::buf::validate::FloatRules* value);
  ::buf::validate::FloatRules* unsafe_arena_release_float_();

  private:
  const ::buf::validate::FloatRules& _internal_float_() const;
  ::buf::validate::FloatRules* _internal_mutable_float_();

  public:
  // .buf.validate.DoubleRules double = 2 [json_name = "double"];
  bool has_double_() const;
  private:
  bool _internal_has_double_() const;

  public:
  void clear_double_() ;
  const ::buf::validate::DoubleRules& double_() const;
  PROTOBUF_NODISCARD ::buf::validate::DoubleRules* release_double_();
  ::buf::validate::DoubleRules* mutable_double_();
  void set_allocated_double_(::buf::validate::DoubleRules* value);
  void unsafe_arena_set_allocated_double_(::buf::validate::DoubleRules* value);
  ::buf::validate::DoubleRules* unsafe_arena_release_double_();

  private:
  const ::buf::validate::DoubleRules& _internal_double_() const;
  ::buf::validate::DoubleRules* _internal_mutable_double_();

  public:
  // .buf.validate.Int32Rules int32 = 3 [json_name = "int32"];
  bool has_int32() const;
  private:
  bool _internal_has_int32() const;

  public:
  void clear_int32() ;
  const ::buf::validate::Int32Rules& int32() const;
  PROTOBUF_NODISCARD ::buf::validate::Int32Rules* release_int32();
  ::buf::validate::Int32Rules* mutable_int32();
  void set_allocated_int32(::buf::validate::Int32Rules* value);
  void unsafe_arena_set_allocated_int32(::buf::validate::Int32Rules* value);
  ::buf::validate::Int32Rules* unsafe_arena_release_int32();

  private:
  const ::buf::validate::Int32Rules& _internal_int32() const;
  ::buf::validate::Int32Rules* _internal_mutable_int32();

  public:
  // .buf.validate.Int64Rules int64 = 4 [json_name = "int64"];
  bool has_int64() const;
  private:
  bool _internal_has_int64() const;

  public:
  void clear_int64() ;
  const ::buf::validate::Int64Rules& int64() const;
  PROTOBUF_NODISCARD ::buf::validate::Int64Rules* release_int64();
  ::buf::validate::Int64Rules* mutable_int64();
  void set_allocated_int64(::buf::validate::Int64Rules* value);
  void unsafe_arena_set_allocated_int64(::buf::validate::Int64Rules* value);
  ::buf::validate::Int64Rules* unsafe_arena_release_int64();

  private:
  const ::buf::validate::Int64Rules& _internal_int64() const;
  ::buf::validate::Int64Rules* _internal_mutable_int64();

  public:
  // .buf.validate.UInt32Rules uint32 = 5 [json_name = "uint32"];
  bool has_uint32() const;
  private:
  bool _internal_has_uint32() const;

  public:
  void clear_uint32() ;
  const ::buf::validate::UInt32Rules& uint32() const;
  PROTOBUF_NODISCARD ::buf::validate::UInt32Rules* release_uint32();
  ::buf::validate::UInt32Rules* mutable_uint32();
  void set_allocated_uint32(::buf::validate::UInt32Rules* value);
  void unsafe_arena_set_allocated_uint32(::buf::validate::UInt32Rules* value);
  ::buf::validate::UInt32Rules* unsafe_arena_release_uint32();

  private:
  const ::buf::validate::UInt32Rules& _internal_uint32() const;
  ::buf::validate::UInt32Rules* _internal_mutable_uint32();

  public:
  // .buf.validate.UInt64Rules uint64 = 6 [json_name = "uint64"];
  bool has_uint64() const;
  private:
  bool _internal_has_uint64() const;

  public:
  void clear_uint64() ;
  const ::buf::validate::UInt64Rules& uint64() const;
  PROTOBUF_NODISCARD ::buf::validate::UInt64Rules* release_uint64();
  ::buf::validate::UInt64Rules* mutable_uint64();
  void set_allocated_uint64(::buf::validate::UInt64Rules* value);
  void unsafe_arena_set_allocated_uint64(::buf::validate::UInt64Rules* value);
  ::buf::validate::UInt64Rules* unsafe_arena_release_uint64();

  private:
  const ::buf::validate::UInt64Rules& _internal_uint64() const;
  ::buf::validate::UInt64Rules* _internal_mutable_uint64();

  public:
  // .buf.validate.SInt32Rules sint32 = 7 [json_name = "sint32"];
  bool has_sint32() const;
  private:
  bool _internal_has_sint32() const;

  public:
  void clear_sint32() ;
  const ::buf::validate::SInt32Rules& sint32() const;
  PROTOBUF_NODISCARD ::buf::validate::SInt32Rules* release_sint32();
  ::buf::validate::SInt32Rules* mutable_sint32();
  void set_allocated_sint32(::buf::validate::SInt32Rules* value);
  void unsafe_arena_set_allocated_sint32(::buf::validate::SInt32Rules* value);
  ::buf::validate::SInt32Rules* unsafe_arena_release_sint32();

  private:
  const ::buf::validate::SInt32Rules& _internal_sint32() const;
  ::buf::validate::SInt32Rules* _internal_mutable_sint32();

  public:
  // .buf.validate.SInt64Rules sint64 = 8 [json_name = "sint64"];
  bool has_sint64() const;
  private:
  bool _internal_has_sint64() const;

  public:
  void clear_sint64() ;
  const ::buf::validate::SInt64Rules& sint64() const;
  PROTOBUF_NODISCARD ::buf::validate::SInt64Rules* release_sint64();
  ::buf::validate::SInt64Rules* mutable_sint64();
  void set_allocated_sint64(::buf::validate::SInt64Rules* value);
  void unsafe_arena_set_allocated_sint64(::buf::validate::SInt64Rules* value);
  ::buf::validate::SInt64Rules* unsafe_arena_release_sint64();

  private:
  const ::buf::validate::SInt64Rules& _internal_sint64() const;
  ::buf::validate::SInt64Rules* _internal_mutable_sint64();

  public:
  // .buf.validate.Fixed32Rules fixed32 = 9 [json_name = "fixed32"];
  bool has_fixed32() const;
  private:
  bool _internal_has_fixed32() const;

  public:
  void clear_fixed32() ;
  const ::buf::validate::Fixed32Rules& fixed32() const;
  PROTOBUF_NODISCARD ::buf::validate::Fixed32Rules* release_fixed32();
  ::buf::validate::Fixed32Rules* mutable_fixed32();
  void set_allocated_fixed32(::buf::validate::Fixed32Rules* value);
  void unsafe_arena_set_allocated_fixed32(::buf::validate::Fixed32Rules* value);
  ::buf::validate::Fixed32Rules* unsafe_arena_release_fixed32();

  private:
  const ::buf::validate::Fixed32Rules& _internal_fixed32() const;
  ::buf::validate::Fixed32Rules* _internal_mutable_fixed32();

  public:
  // .buf.validate.Fixed64Rules fixed64 = 10 [json_name = "fixed64"];
  bool has_fixed64() const;
  private:
  bool _internal_has_fixed64() const;

  public:
  void clear_fixed64() ;
  const ::buf::validate::Fixed64Rules& fixed64() const;
  PROTOBUF_NODISCARD ::buf::validate::Fixed64Rules* release_fixed64();
  ::buf::validate::Fixed64Rules* mutable_fixed64();
  void set_allocated_fixed64(::buf::validate::Fixed64Rules* value);
  void unsafe_arena_set_allocated_fixed64(::buf::validate::Fixed64Rules* value);
  ::buf::validate::Fixed64Rules* unsafe_arena_release_fixed64();

  private:
  const ::buf::validate::Fixed64Rules& _internal_fixed64() const;
  ::buf::validate::Fixed64Rules* _internal_mutable_fixed64();

  public:
  // .buf.validate.SFixed32Rules sfixed32 = 11 [json_name = "sfixed32"];
  bool has_sfixed32() const;
  private:
  bool _internal_has_sfixed32() const;

  public:
  void clear_sfixed32() ;
  const ::buf::validate::SFixed32Rules& sfixed32() const;
  PROTOBUF_NODISCARD ::buf::validate::SFixed32Rules* release_sfixed32();
  ::buf::validate::SFixed32Rules* mutable_sfixed32();
  void set_allocated_sfixed32(::buf::validate::SFixed32Rules* value);
  void unsafe_arena_set_allocated_sfixed32(::buf::validate::SFixed32Rules* value);
  ::buf::validate::SFixed32Rules* unsafe_arena_release_sfixed32();

  private:
  const ::buf::validate::SFixed32Rules& _internal_sfixed32() const;
  ::buf::validate::SFixed32Rules* _internal_mutable_sfixed32();

  public:
  // .buf.validate.SFixed64Rules sfixed64 = 12 [json_name = "sfixed64"];
  bool has_sfixed64() const;
  private:
  bool _internal_has_sfixed64() const;

  public:
  void clear_sfixed64() ;
  const ::buf::validate::SFixed64Rules& sfixed64() const;
  PROTOBUF_NODISCARD ::buf::validate::SFixed64Rules* release_sfixed64();
  ::buf::validate::SFixed64Rules* mutable_sfixed64();
  void set_allocated_sfixed64(::buf::validate::SFixed64Rules* value);
  void unsafe_arena_set_allocated_sfixed64(::buf::validate::SFixed64Rules* value);
  ::buf::validate::SFixed64Rules* unsafe_arena_release_sfixed64();

  private:
  const ::buf::validate::SFixed64Rules& _internal_sfixed64() const;
  ::buf::validate::SFixed64Rules* _internal_mutable_sfixed64();

  public:
  // .buf.validate.BoolRules bool = 13 [json_name = "bool"];
  bool has_bool_() const;
  private:
  bool _internal_has_bool_() const;

  public:
  void clear_bool_() ;
  const ::buf::validate::BoolRules& bool_() const;
  PROTOBUF_NODISCARD ::buf::validate::BoolRules* release_bool_();
  ::buf::validate::BoolRules* mutable_bool_();
  void set_allocated_bool_(::buf::validate::BoolRules* value);
  void unsafe_arena_set_allocated_bool_(::buf::validate::BoolRules* value);
  ::buf::validate::BoolRules* unsafe_arena_release_bool_();

  private:
  const ::buf::validate::BoolRules& _internal_bool_() const;
  ::buf::validate::BoolRules* _internal_mutable_bool_();

  public:
  // .buf.validate.StringRules string = 14 [json_name = "string"];
  bool has_string() const;
  private:
  bool _internal_has_string() const;

  public:
  void clear_string() ;
  const ::buf::validate::StringRules& string() const;
  PROTOBUF_NODISCARD ::buf::validate::StringRules* release_string();
  ::buf::validate::StringRules* mutable_string();
  void set_allocated_string(::buf::validate::StringRules* value);
  void unsafe_arena_set_allocated_string(::buf::validate::StringRules* value);
  ::buf::validate::StringRules* unsafe_arena_release_string();

  private:
  const ::buf::validate::StringRules& _internal_string() const;
  ::buf::validate::StringRules* _internal_mutable_string();

  public:
  // .buf.validate.BytesRules bytes = 15 [json_name = "bytes"];
  bool has_bytes() const;
  private:
  bool _internal_has_bytes() const;

  public:
  void clear_bytes() ;
  const ::buf::validate::BytesRules& bytes() const;
  PROTOBUF_NODISCARD ::buf::validate::BytesRules* release_bytes();
  ::buf::validate::BytesRules* mutable_bytes();
  void set_allocated_bytes(::buf::validate::BytesRules* value);
  void unsafe_arena_set_allocated_bytes(::buf::validate::BytesRules* value);
  ::buf::validate::BytesRules* unsafe_arena_release_bytes();

  private:
  const ::buf::validate::BytesRules& _internal_bytes() const;
  ::buf::validate::BytesRules* _internal_mutable_bytes();

  public:
  // .buf.validate.EnumRules enum = 16 [json_name = "enum"];
  bool has_enum_() const;
  private:
  bool _internal_has_enum_() const;

  public:
  void clear_enum_() ;
  const ::buf::validate::EnumRules& enum_() const;
  PROTOBUF_NODISCARD ::buf::validate::EnumRules* release_enum_();
  ::buf::validate::EnumRules* mutable_enum_();
  void set_allocated_enum_(::buf::validate::EnumRules* value);
  void unsafe_arena_set_allocated_enum_(::buf::validate::EnumRules* value);
  ::buf::validate::EnumRules* unsafe_arena_release_enum_();

  private:
  const ::buf::validate::EnumRules& _internal_enum_() const;
  ::buf::validate::EnumRules* _internal_mutable_enum_();

  public:
  // .buf.validate.RepeatedRules repeated = 18 [json_name = "repeated"];
  bool has_repeated() const;
  private:
  bool _internal_has_repeated() const;

  public:
  void clear_repeated() ;
  const ::buf::validate::RepeatedRules& repeated() const;
  PROTOBUF_NODISCARD ::buf::validate::RepeatedRules* release_repeated();
  ::buf::validate::RepeatedRules* mutable_repeated();
  void set_allocated_repeated(::buf::validate::RepeatedRules* value);
  void unsafe_arena_set_allocated_repeated(::buf::validate::RepeatedRules* value);
  ::buf::validate::RepeatedRules* unsafe_arena_release_repeated();

  private:
  const ::buf::validate::RepeatedRules& _internal_repeated() const;
  ::buf::validate::RepeatedRules* _internal_mutable_repeated();

  public:
  // .buf.validate.MapRules map = 19 [json_name = "map"];
  bool has_map() const;
  private:
  bool _internal_has_map() const;

  public:
  void clear_map() ;
  const ::buf::validate::MapRules& map() const;
  PROTOBUF_NODISCARD ::buf::validate::MapRules* release_map();
  ::buf::validate::MapRules* mutable_map();
  void set_allocated_map(::buf::validate::MapRules* value);
  void unsafe_arena_set_allocated_map(::buf::validate::MapRules* value);
  ::buf::validate::MapRules* unsafe_arena_release_map();

  private:
  const ::buf::validate::MapRules& _internal_map() const;
  ::buf::validate::MapRules* _internal_mutable_map();

  public:
  // .buf.validate.AnyRules any = 20 [json_name = "any"];
  bool has_any() const;
  private:
  bool _internal_has_any() const;

  public:
  void clear_any() ;
  const ::buf::validate::AnyRules& any() const;
  PROTOBUF_NODISCARD ::buf::validate::AnyRules* release_any();
  ::buf::validate::AnyRules* mutable_any();
  void set_allocated_any(::buf::validate::AnyRules* value);
  void unsafe_arena_set_allocated_any(::buf::validate::AnyRules* value);
  ::buf::validate::AnyRules* unsafe_arena_release_any();

  private:
  const ::buf::validate::AnyRules& _internal_any() const;
  ::buf::validate::AnyRules* _internal_mutable_any();

  public:
  // .buf.validate.DurationRules duration = 21 [json_name = "duration"];
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;

  public:
  void clear_duration() ;
  const ::buf::validate::DurationRules& duration() const;
  PROTOBUF_NODISCARD ::buf::validate::DurationRules* release_duration();
  ::buf::validate::DurationRules* mutable_duration();
  void set_allocated_duration(::buf::validate::DurationRules* value);
  void unsafe_arena_set_allocated_duration(::buf::validate::DurationRules* value);
  ::buf::validate::DurationRules* unsafe_arena_release_duration();

  private:
  const ::buf::validate::DurationRules& _internal_duration() const;
  ::buf::validate::DurationRules* _internal_mutable_duration();

  public:
  // .buf.validate.TimestampRules timestamp = 22 [json_name = "timestamp"];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;

  public:
  void clear_timestamp() ;
  const ::buf::validate::TimestampRules& timestamp() const;
  PROTOBUF_NODISCARD ::buf::validate::TimestampRules* release_timestamp();
  ::buf::validate::TimestampRules* mutable_timestamp();
  void set_allocated_timestamp(::buf::validate::TimestampRules* value);
  void unsafe_arena_set_allocated_timestamp(::buf::validate::TimestampRules* value);
  ::buf::validate::TimestampRules* unsafe_arena_release_timestamp();

  private:
  const ::buf::validate::TimestampRules& _internal_timestamp() const;
  ::buf::validate::TimestampRules* _internal_mutable_timestamp();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.FieldConstraints)
 private:
  class _Internal;
  void set_has_float_();
  void set_has_double_();
  void set_has_int32();
  void set_has_int64();
  void set_has_uint32();
  void set_has_uint64();
  void set_has_sint32();
  void set_has_sint64();
  void set_has_fixed32();
  void set_has_fixed64();
  void set_has_sfixed32();
  void set_has_sfixed64();
  void set_has_bool_();
  void set_has_string();
  void set_has_bytes();
  void set_has_enum_();
  void set_has_repeated();
  void set_has_map();
  void set_has_any();
  void set_has_duration();
  void set_has_timestamp();
  inline bool has_type() const;
  inline void clear_has_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 26, 23,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FieldConstraints_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FieldConstraints& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint > cel_;
    bool required_;
    bool skipped_;
    bool ignore_empty_;
    int ignore_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::buf::validate::FloatRules* float__;
      ::buf::validate::DoubleRules* double__;
      ::buf::validate::Int32Rules* int32_;
      ::buf::validate::Int64Rules* int64_;
      ::buf::validate::UInt32Rules* uint32_;
      ::buf::validate::UInt64Rules* uint64_;
      ::buf::validate::SInt32Rules* sint32_;
      ::buf::validate::SInt64Rules* sint64_;
      ::buf::validate::Fixed32Rules* fixed32_;
      ::buf::validate::Fixed64Rules* fixed64_;
      ::buf::validate::SFixed32Rules* sfixed32_;
      ::buf::validate::SFixed64Rules* sfixed64_;
      ::buf::validate::BoolRules* bool__;
      ::buf::validate::StringRules* string_;
      ::buf::validate::BytesRules* bytes_;
      ::buf::validate::EnumRules* enum__;
      ::buf::validate::RepeatedRules* repeated_;
      ::buf::validate::MapRules* map_;
      ::buf::validate::AnyRules* any_;
      ::buf::validate::DurationRules* duration_;
      ::buf::validate::TimestampRules* timestamp_;
    } type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class MapRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.MapRules) */ {
 public:
  inline MapRules() : MapRules(nullptr) {}
  ~MapRules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MapRules(
      ::google::protobuf::internal::ConstantInitialized);

  inline MapRules(const MapRules& from) : MapRules(nullptr, from) {}
  inline MapRules(MapRules&& from) noexcept
      : MapRules(nullptr, std::move(from)) {}
  inline MapRules& operator=(const MapRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapRules& operator=(MapRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapRules& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapRules* internal_default_instance() {
    return reinterpret_cast<const MapRules*>(
        &_MapRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(MapRules& a, MapRules& b) { a.Swap(&b); }
  inline void Swap(MapRules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MapRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MapRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MapRules& from) { MapRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MapRules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.MapRules"; }

 protected:
  explicit MapRules(::google::protobuf::Arena* arena);
  MapRules(::google::protobuf::Arena* arena, const MapRules& from);
  MapRules(::google::protobuf::Arena* arena, MapRules&& from) noexcept
      : MapRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeysFieldNumber = 4,
    kValuesFieldNumber = 5,
    kMinPairsFieldNumber = 1,
    kMaxPairsFieldNumber = 2,
  };
  // optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
  bool has_keys() const;
  void clear_keys() ;
  const ::buf::validate::FieldConstraints& keys() const;
  PROTOBUF_NODISCARD ::buf::validate::FieldConstraints* release_keys();
  ::buf::validate::FieldConstraints* mutable_keys();
  void set_allocated_keys(::buf::validate::FieldConstraints* value);
  void unsafe_arena_set_allocated_keys(::buf::validate::FieldConstraints* value);
  ::buf::validate::FieldConstraints* unsafe_arena_release_keys();

  private:
  const ::buf::validate::FieldConstraints& _internal_keys() const;
  ::buf::validate::FieldConstraints* _internal_mutable_keys();

  public:
  // optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
  bool has_values() const;
  void clear_values() ;
  const ::buf::validate::FieldConstraints& values() const;
  PROTOBUF_NODISCARD ::buf::validate::FieldConstraints* release_values();
  ::buf::validate::FieldConstraints* mutable_values();
  void set_allocated_values(::buf::validate::FieldConstraints* value);
  void unsafe_arena_set_allocated_values(::buf::validate::FieldConstraints* value);
  ::buf::validate::FieldConstraints* unsafe_arena_release_values();

  private:
  const ::buf::validate::FieldConstraints& _internal_values() const;
  ::buf::validate::FieldConstraints* _internal_mutable_values();

  public:
  // optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.predefined) = {
  bool has_min_pairs() const;
  void clear_min_pairs() ;
  ::uint64_t min_pairs() const;
  void set_min_pairs(::uint64_t value);

  private:
  ::uint64_t _internal_min_pairs() const;
  void _internal_set_min_pairs(::uint64_t value);

  public:
  // optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.predefined) = {
  bool has_max_pairs() const;
  void clear_max_pairs() ;
  ::uint64_t max_pairs() const;
  void set_max_pairs(::uint64_t value);

  private:
  ::uint64_t _internal_max_pairs() const;
  void _internal_set_max_pairs(::uint64_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<MapRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:buf.validate.MapRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MapRules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MapRules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::buf::validate::FieldConstraints* keys_;
    ::buf::validate::FieldConstraints* values_;
    ::uint64_t min_pairs_;
    ::uint64_t max_pairs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};
// -------------------------------------------------------------------

class RepeatedRules final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:buf.validate.RepeatedRules) */ {
 public:
  inline RepeatedRules() : RepeatedRules(nullptr) {}
  ~RepeatedRules() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RepeatedRules(
      ::google::protobuf::internal::ConstantInitialized);

  inline RepeatedRules(const RepeatedRules& from) : RepeatedRules(nullptr, from) {}
  inline RepeatedRules(RepeatedRules&& from) noexcept
      : RepeatedRules(nullptr, std::move(from)) {}
  inline RepeatedRules& operator=(const RepeatedRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepeatedRules& operator=(RepeatedRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepeatedRules& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepeatedRules* internal_default_instance() {
    return reinterpret_cast<const RepeatedRules*>(
        &_RepeatedRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(RepeatedRules& a, RepeatedRules& b) { a.Swap(&b); }
  inline void Swap(RepeatedRules* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepeatedRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepeatedRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RepeatedRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepeatedRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RepeatedRules& from) { RepeatedRules::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RepeatedRules* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "buf.validate.RepeatedRules"; }

 protected:
  explicit RepeatedRules(::google::protobuf::Arena* arena);
  RepeatedRules(::google::protobuf::Arena* arena, const RepeatedRules& from);
  RepeatedRules(::google::protobuf::Arena* arena, RepeatedRules&& from) noexcept
      : RepeatedRules(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 4,
    kMinItemsFieldNumber = 1,
    kMaxItemsFieldNumber = 2,
    kUniqueFieldNumber = 3,
  };
  // optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
  bool has_items() const;
  void clear_items() ;
  const ::buf::validate::FieldConstraints& items() const;
  PROTOBUF_NODISCARD ::buf::validate::FieldConstraints* release_items();
  ::buf::validate::FieldConstraints* mutable_items();
  void set_allocated_items(::buf::validate::FieldConstraints* value);
  void unsafe_arena_set_allocated_items(::buf::validate::FieldConstraints* value);
  ::buf::validate::FieldConstraints* unsafe_arena_release_items();

  private:
  const ::buf::validate::FieldConstraints& _internal_items() const;
  ::buf::validate::FieldConstraints* _internal_mutable_items();

  public:
  // optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.predefined) = {
  bool has_min_items() const;
  void clear_min_items() ;
  ::uint64_t min_items() const;
  void set_min_items(::uint64_t value);

  private:
  ::uint64_t _internal_min_items() const;
  void _internal_set_min_items(::uint64_t value);

  public:
  // optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.predefined) = {
  bool has_max_items() const;
  void clear_max_items() ;
  ::uint64_t max_items() const;
  void set_max_items(::uint64_t value);

  private:
  ::uint64_t _internal_max_items() const;
  void _internal_set_max_items(::uint64_t value);

  public:
  // optional bool unique = 3 [json_name = "unique", (.buf.validate.predefined) = {
  bool has_unique() const;
  void clear_unique() ;
  bool unique() const;
  void set_unique(bool value);

  private:
  bool _internal_unique() const;
  void _internal_set_unique(bool value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<RepeatedRules, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:buf.validate.RepeatedRules)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RepeatedRules_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RepeatedRules& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::buf::validate::FieldConstraints* items_;
    ::uint64_t min_items_;
    ::uint64_t max_items_;
    bool unique_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};

// ===================================================================



static const int kMessageFieldNumber = 1159;
extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::MessageOptions, ::google::protobuf::internal::MessageTypeTraits< ::buf::validate::MessageConstraints >, 11,
    false>
    message;
static const int kOneofFieldNumber = 1159;
extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::OneofOptions, ::google::protobuf::internal::MessageTypeTraits< ::buf::validate::OneofConstraints >, 11,
    false>
    oneof;
static const int kFieldFieldNumber = 1159;
extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::FieldOptions, ::google::protobuf::internal::MessageTypeTraits< ::buf::validate::FieldConstraints >, 11,
    false>
    field;
static const int kPredefinedFieldNumber = 1160;
extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::FieldOptions, ::google::protobuf::internal::MessageTypeTraits< ::buf::validate::PredefinedConstraints >, 11,
    false>
    predefined;

// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Constraint

// optional string id = 1 [json_name = "id"];
inline bool Constraint::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Constraint::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Constraint::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.Constraint.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Constraint::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.Constraint.id)
}
inline std::string* Constraint::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:buf.validate.Constraint.id)
  return _s;
}
inline const std::string& Constraint::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Constraint::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Constraint::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Constraint::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.Constraint.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Constraint::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.Constraint.id)
}

// optional string message = 2 [json_name = "message"];
inline bool Constraint::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Constraint::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Constraint::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.Constraint.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Constraint::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.Constraint.message)
}
inline std::string* Constraint::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:buf.validate.Constraint.message)
  return _s;
}
inline const std::string& Constraint::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void Constraint::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* Constraint::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* Constraint::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.Constraint.message)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Constraint::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.Constraint.message)
}

// optional string expression = 3 [json_name = "expression"];
inline bool Constraint::has_expression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Constraint::clear_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expression_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Constraint::expression() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.Constraint.expression)
  return _internal_expression();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Constraint::set_expression(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.expression_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.Constraint.expression)
}
inline std::string* Constraint::mutable_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:buf.validate.Constraint.expression)
  return _s;
}
inline const std::string& Constraint::_internal_expression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expression_.Get();
}
inline void Constraint::_internal_set_expression(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.expression_.Set(value, GetArena());
}
inline std::string* Constraint::_internal_mutable_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.expression_.Mutable( GetArena());
}
inline std::string* Constraint::release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.Constraint.expression)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.expression_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.expression_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Constraint::set_allocated_expression(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.expression_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.expression_.IsDefault()) {
          _impl_.expression_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.Constraint.expression)
}

// -------------------------------------------------------------------

// MessageConstraints

// optional bool disabled = 1 [json_name = "disabled"];
inline bool MessageConstraints::has_disabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MessageConstraints::clear_disabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool MessageConstraints::disabled() const {
  // @@protoc_insertion_point(field_get:buf.validate.MessageConstraints.disabled)
  return _internal_disabled();
}
inline void MessageConstraints::set_disabled(bool value) {
  _internal_set_disabled(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.MessageConstraints.disabled)
}
inline bool MessageConstraints::_internal_disabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disabled_;
}
inline void MessageConstraints::_internal_set_disabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disabled_ = value;
}

// repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
inline int MessageConstraints::_internal_cel_size() const {
  return _internal_cel().size();
}
inline int MessageConstraints::cel_size() const {
  return _internal_cel_size();
}
inline void MessageConstraints::clear_cel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cel_.Clear();
}
inline ::buf::validate::Constraint* MessageConstraints::mutable_cel(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.MessageConstraints.cel)
  return _internal_mutable_cel()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>* MessageConstraints::mutable_cel()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.MessageConstraints.cel)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cel();
}
inline const ::buf::validate::Constraint& MessageConstraints::cel(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.MessageConstraints.cel)
  return _internal_cel().Get(index);
}
inline ::buf::validate::Constraint* MessageConstraints::add_cel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::buf::validate::Constraint* _add = _internal_mutable_cel()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.MessageConstraints.cel)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>& MessageConstraints::cel() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.MessageConstraints.cel)
  return _internal_cel();
}
inline const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>&
MessageConstraints::_internal_cel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cel_;
}
inline ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>*
MessageConstraints::_internal_mutable_cel() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cel_;
}

// -------------------------------------------------------------------

// OneofConstraints

// optional bool required = 1 [json_name = "required"];
inline bool OneofConstraints::has_required() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void OneofConstraints::clear_required() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool OneofConstraints::required() const {
  // @@protoc_insertion_point(field_get:buf.validate.OneofConstraints.required)
  return _internal_required();
}
inline void OneofConstraints::set_required(bool value) {
  _internal_set_required(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.OneofConstraints.required)
}
inline bool OneofConstraints::_internal_required() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.required_;
}
inline void OneofConstraints::_internal_set_required(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = value;
}

// -------------------------------------------------------------------

// FieldConstraints

// repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
inline int FieldConstraints::_internal_cel_size() const {
  return _internal_cel().size();
}
inline int FieldConstraints::cel_size() const {
  return _internal_cel_size();
}
inline void FieldConstraints::clear_cel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cel_.Clear();
}
inline ::buf::validate::Constraint* FieldConstraints::mutable_cel(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.cel)
  return _internal_mutable_cel()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>* FieldConstraints::mutable_cel()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.FieldConstraints.cel)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cel();
}
inline const ::buf::validate::Constraint& FieldConstraints::cel(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.cel)
  return _internal_cel().Get(index);
}
inline ::buf::validate::Constraint* FieldConstraints::add_cel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::buf::validate::Constraint* _add = _internal_mutable_cel()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.FieldConstraints.cel)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>& FieldConstraints::cel() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.FieldConstraints.cel)
  return _internal_cel();
}
inline const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>&
FieldConstraints::_internal_cel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cel_;
}
inline ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>*
FieldConstraints::_internal_mutable_cel() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cel_;
}

// optional bool required = 25 [json_name = "required"];
inline bool FieldConstraints::has_required() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FieldConstraints::clear_required() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool FieldConstraints::required() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.required)
  return _internal_required();
}
inline void FieldConstraints::set_required(bool value) {
  _internal_set_required(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.FieldConstraints.required)
}
inline bool FieldConstraints::_internal_required() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.required_;
}
inline void FieldConstraints::_internal_set_required(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_ = value;
}

// optional .buf.validate.Ignore ignore = 27 [json_name = "ignore"];
inline bool FieldConstraints::has_ignore() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FieldConstraints::clear_ignore() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::buf::validate::Ignore FieldConstraints::ignore() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.ignore)
  return _internal_ignore();
}
inline void FieldConstraints::set_ignore(::buf::validate::Ignore value) {
  _internal_set_ignore(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:buf.validate.FieldConstraints.ignore)
}
inline ::buf::validate::Ignore FieldConstraints::_internal_ignore() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::buf::validate::Ignore>(_impl_.ignore_);
}
inline void FieldConstraints::_internal_set_ignore(::buf::validate::Ignore value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::buf::validate::Ignore_IsValid(value));
  _impl_.ignore_ = value;
}

// .buf.validate.FloatRules float = 1 [json_name = "float"];
inline bool FieldConstraints::has_float_() const {
  return type_case() == kFloat;
}
inline bool FieldConstraints::_internal_has_float_() const {
  return type_case() == kFloat;
}
inline void FieldConstraints::set_has_float_() {
  _impl_._oneof_case_[0] = kFloat;
}
inline void FieldConstraints::clear_float_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kFloat) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.float__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.float__);
    }
    clear_has_type();
  }
}
inline ::buf::validate::FloatRules* FieldConstraints::release_float_() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.float)
  if (type_case() == kFloat) {
    clear_has_type();
    auto* temp = _impl_.type_.float__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.float__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::FloatRules& FieldConstraints::_internal_float_() const {
  return type_case() == kFloat ? *_impl_.type_.float__ : reinterpret_cast<::buf::validate::FloatRules&>(::buf::validate::_FloatRules_default_instance_);
}
inline const ::buf::validate::FloatRules& FieldConstraints::float_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.float)
  return _internal_float_();
}
inline ::buf::validate::FloatRules* FieldConstraints::unsafe_arena_release_float_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.float)
  if (type_case() == kFloat) {
    clear_has_type();
    auto* temp = _impl_.type_.float__;
    _impl_.type_.float__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_float_(::buf::validate::FloatRules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_float_();
    _impl_.type_.float__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.float)
}
inline ::buf::validate::FloatRules* FieldConstraints::_internal_mutable_float_() {
  if (type_case() != kFloat) {
    clear_type();
    set_has_float_();
    _impl_.type_.float__ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::FloatRules>(GetArena());
  }
  return _impl_.type_.float__;
}
inline ::buf::validate::FloatRules* FieldConstraints::mutable_float_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::FloatRules* _msg = _internal_mutable_float_();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.float)
  return _msg;
}

// .buf.validate.DoubleRules double = 2 [json_name = "double"];
inline bool FieldConstraints::has_double_() const {
  return type_case() == kDouble;
}
inline bool FieldConstraints::_internal_has_double_() const {
  return type_case() == kDouble;
}
inline void FieldConstraints::set_has_double_() {
  _impl_._oneof_case_[0] = kDouble;
}
inline void FieldConstraints::clear_double_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kDouble) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.double__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.double__);
    }
    clear_has_type();
  }
}
inline ::buf::validate::DoubleRules* FieldConstraints::release_double_() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.double)
  if (type_case() == kDouble) {
    clear_has_type();
    auto* temp = _impl_.type_.double__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.double__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::DoubleRules& FieldConstraints::_internal_double_() const {
  return type_case() == kDouble ? *_impl_.type_.double__ : reinterpret_cast<::buf::validate::DoubleRules&>(::buf::validate::_DoubleRules_default_instance_);
}
inline const ::buf::validate::DoubleRules& FieldConstraints::double_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.double)
  return _internal_double_();
}
inline ::buf::validate::DoubleRules* FieldConstraints::unsafe_arena_release_double_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.double)
  if (type_case() == kDouble) {
    clear_has_type();
    auto* temp = _impl_.type_.double__;
    _impl_.type_.double__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_double_(::buf::validate::DoubleRules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_double_();
    _impl_.type_.double__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.double)
}
inline ::buf::validate::DoubleRules* FieldConstraints::_internal_mutable_double_() {
  if (type_case() != kDouble) {
    clear_type();
    set_has_double_();
    _impl_.type_.double__ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::DoubleRules>(GetArena());
  }
  return _impl_.type_.double__;
}
inline ::buf::validate::DoubleRules* FieldConstraints::mutable_double_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::DoubleRules* _msg = _internal_mutable_double_();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.double)
  return _msg;
}

// .buf.validate.Int32Rules int32 = 3 [json_name = "int32"];
inline bool FieldConstraints::has_int32() const {
  return type_case() == kInt32;
}
inline bool FieldConstraints::_internal_has_int32() const {
  return type_case() == kInt32;
}
inline void FieldConstraints::set_has_int32() {
  _impl_._oneof_case_[0] = kInt32;
}
inline void FieldConstraints::clear_int32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kInt32) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.int32_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.int32_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::Int32Rules* FieldConstraints::release_int32() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.int32)
  if (type_case() == kInt32) {
    clear_has_type();
    auto* temp = _impl_.type_.int32_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.int32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::Int32Rules& FieldConstraints::_internal_int32() const {
  return type_case() == kInt32 ? *_impl_.type_.int32_ : reinterpret_cast<::buf::validate::Int32Rules&>(::buf::validate::_Int32Rules_default_instance_);
}
inline const ::buf::validate::Int32Rules& FieldConstraints::int32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.int32)
  return _internal_int32();
}
inline ::buf::validate::Int32Rules* FieldConstraints::unsafe_arena_release_int32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.int32)
  if (type_case() == kInt32) {
    clear_has_type();
    auto* temp = _impl_.type_.int32_;
    _impl_.type_.int32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_int32(::buf::validate::Int32Rules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_int32();
    _impl_.type_.int32_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.int32)
}
inline ::buf::validate::Int32Rules* FieldConstraints::_internal_mutable_int32() {
  if (type_case() != kInt32) {
    clear_type();
    set_has_int32();
    _impl_.type_.int32_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::Int32Rules>(GetArena());
  }
  return _impl_.type_.int32_;
}
inline ::buf::validate::Int32Rules* FieldConstraints::mutable_int32() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::Int32Rules* _msg = _internal_mutable_int32();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.int32)
  return _msg;
}

// .buf.validate.Int64Rules int64 = 4 [json_name = "int64"];
inline bool FieldConstraints::has_int64() const {
  return type_case() == kInt64;
}
inline bool FieldConstraints::_internal_has_int64() const {
  return type_case() == kInt64;
}
inline void FieldConstraints::set_has_int64() {
  _impl_._oneof_case_[0] = kInt64;
}
inline void FieldConstraints::clear_int64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kInt64) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.int64_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.int64_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::Int64Rules* FieldConstraints::release_int64() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.int64)
  if (type_case() == kInt64) {
    clear_has_type();
    auto* temp = _impl_.type_.int64_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.int64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::Int64Rules& FieldConstraints::_internal_int64() const {
  return type_case() == kInt64 ? *_impl_.type_.int64_ : reinterpret_cast<::buf::validate::Int64Rules&>(::buf::validate::_Int64Rules_default_instance_);
}
inline const ::buf::validate::Int64Rules& FieldConstraints::int64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.int64)
  return _internal_int64();
}
inline ::buf::validate::Int64Rules* FieldConstraints::unsafe_arena_release_int64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.int64)
  if (type_case() == kInt64) {
    clear_has_type();
    auto* temp = _impl_.type_.int64_;
    _impl_.type_.int64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_int64(::buf::validate::Int64Rules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_int64();
    _impl_.type_.int64_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.int64)
}
inline ::buf::validate::Int64Rules* FieldConstraints::_internal_mutable_int64() {
  if (type_case() != kInt64) {
    clear_type();
    set_has_int64();
    _impl_.type_.int64_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::Int64Rules>(GetArena());
  }
  return _impl_.type_.int64_;
}
inline ::buf::validate::Int64Rules* FieldConstraints::mutable_int64() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::Int64Rules* _msg = _internal_mutable_int64();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.int64)
  return _msg;
}

// .buf.validate.UInt32Rules uint32 = 5 [json_name = "uint32"];
inline bool FieldConstraints::has_uint32() const {
  return type_case() == kUint32;
}
inline bool FieldConstraints::_internal_has_uint32() const {
  return type_case() == kUint32;
}
inline void FieldConstraints::set_has_uint32() {
  _impl_._oneof_case_[0] = kUint32;
}
inline void FieldConstraints::clear_uint32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kUint32) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.uint32_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.uint32_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::UInt32Rules* FieldConstraints::release_uint32() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.uint32)
  if (type_case() == kUint32) {
    clear_has_type();
    auto* temp = _impl_.type_.uint32_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.uint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::UInt32Rules& FieldConstraints::_internal_uint32() const {
  return type_case() == kUint32 ? *_impl_.type_.uint32_ : reinterpret_cast<::buf::validate::UInt32Rules&>(::buf::validate::_UInt32Rules_default_instance_);
}
inline const ::buf::validate::UInt32Rules& FieldConstraints::uint32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.uint32)
  return _internal_uint32();
}
inline ::buf::validate::UInt32Rules* FieldConstraints::unsafe_arena_release_uint32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.uint32)
  if (type_case() == kUint32) {
    clear_has_type();
    auto* temp = _impl_.type_.uint32_;
    _impl_.type_.uint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_uint32(::buf::validate::UInt32Rules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_uint32();
    _impl_.type_.uint32_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.uint32)
}
inline ::buf::validate::UInt32Rules* FieldConstraints::_internal_mutable_uint32() {
  if (type_case() != kUint32) {
    clear_type();
    set_has_uint32();
    _impl_.type_.uint32_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::UInt32Rules>(GetArena());
  }
  return _impl_.type_.uint32_;
}
inline ::buf::validate::UInt32Rules* FieldConstraints::mutable_uint32() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::UInt32Rules* _msg = _internal_mutable_uint32();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.uint32)
  return _msg;
}

// .buf.validate.UInt64Rules uint64 = 6 [json_name = "uint64"];
inline bool FieldConstraints::has_uint64() const {
  return type_case() == kUint64;
}
inline bool FieldConstraints::_internal_has_uint64() const {
  return type_case() == kUint64;
}
inline void FieldConstraints::set_has_uint64() {
  _impl_._oneof_case_[0] = kUint64;
}
inline void FieldConstraints::clear_uint64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kUint64) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.uint64_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.uint64_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::UInt64Rules* FieldConstraints::release_uint64() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.uint64)
  if (type_case() == kUint64) {
    clear_has_type();
    auto* temp = _impl_.type_.uint64_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.uint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::UInt64Rules& FieldConstraints::_internal_uint64() const {
  return type_case() == kUint64 ? *_impl_.type_.uint64_ : reinterpret_cast<::buf::validate::UInt64Rules&>(::buf::validate::_UInt64Rules_default_instance_);
}
inline const ::buf::validate::UInt64Rules& FieldConstraints::uint64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.uint64)
  return _internal_uint64();
}
inline ::buf::validate::UInt64Rules* FieldConstraints::unsafe_arena_release_uint64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.uint64)
  if (type_case() == kUint64) {
    clear_has_type();
    auto* temp = _impl_.type_.uint64_;
    _impl_.type_.uint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_uint64(::buf::validate::UInt64Rules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_uint64();
    _impl_.type_.uint64_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.uint64)
}
inline ::buf::validate::UInt64Rules* FieldConstraints::_internal_mutable_uint64() {
  if (type_case() != kUint64) {
    clear_type();
    set_has_uint64();
    _impl_.type_.uint64_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::UInt64Rules>(GetArena());
  }
  return _impl_.type_.uint64_;
}
inline ::buf::validate::UInt64Rules* FieldConstraints::mutable_uint64() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::UInt64Rules* _msg = _internal_mutable_uint64();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.uint64)
  return _msg;
}

// .buf.validate.SInt32Rules sint32 = 7 [json_name = "sint32"];
inline bool FieldConstraints::has_sint32() const {
  return type_case() == kSint32;
}
inline bool FieldConstraints::_internal_has_sint32() const {
  return type_case() == kSint32;
}
inline void FieldConstraints::set_has_sint32() {
  _impl_._oneof_case_[0] = kSint32;
}
inline void FieldConstraints::clear_sint32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kSint32) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sint32_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sint32_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::SInt32Rules* FieldConstraints::release_sint32() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.sint32)
  if (type_case() == kSint32) {
    clear_has_type();
    auto* temp = _impl_.type_.sint32_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::SInt32Rules& FieldConstraints::_internal_sint32() const {
  return type_case() == kSint32 ? *_impl_.type_.sint32_ : reinterpret_cast<::buf::validate::SInt32Rules&>(::buf::validate::_SInt32Rules_default_instance_);
}
inline const ::buf::validate::SInt32Rules& FieldConstraints::sint32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.sint32)
  return _internal_sint32();
}
inline ::buf::validate::SInt32Rules* FieldConstraints::unsafe_arena_release_sint32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.sint32)
  if (type_case() == kSint32) {
    clear_has_type();
    auto* temp = _impl_.type_.sint32_;
    _impl_.type_.sint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_sint32(::buf::validate::SInt32Rules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sint32();
    _impl_.type_.sint32_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.sint32)
}
inline ::buf::validate::SInt32Rules* FieldConstraints::_internal_mutable_sint32() {
  if (type_case() != kSint32) {
    clear_type();
    set_has_sint32();
    _impl_.type_.sint32_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::SInt32Rules>(GetArena());
  }
  return _impl_.type_.sint32_;
}
inline ::buf::validate::SInt32Rules* FieldConstraints::mutable_sint32() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::SInt32Rules* _msg = _internal_mutable_sint32();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.sint32)
  return _msg;
}

// .buf.validate.SInt64Rules sint64 = 8 [json_name = "sint64"];
inline bool FieldConstraints::has_sint64() const {
  return type_case() == kSint64;
}
inline bool FieldConstraints::_internal_has_sint64() const {
  return type_case() == kSint64;
}
inline void FieldConstraints::set_has_sint64() {
  _impl_._oneof_case_[0] = kSint64;
}
inline void FieldConstraints::clear_sint64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kSint64) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sint64_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sint64_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::SInt64Rules* FieldConstraints::release_sint64() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.sint64)
  if (type_case() == kSint64) {
    clear_has_type();
    auto* temp = _impl_.type_.sint64_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::SInt64Rules& FieldConstraints::_internal_sint64() const {
  return type_case() == kSint64 ? *_impl_.type_.sint64_ : reinterpret_cast<::buf::validate::SInt64Rules&>(::buf::validate::_SInt64Rules_default_instance_);
}
inline const ::buf::validate::SInt64Rules& FieldConstraints::sint64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.sint64)
  return _internal_sint64();
}
inline ::buf::validate::SInt64Rules* FieldConstraints::unsafe_arena_release_sint64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.sint64)
  if (type_case() == kSint64) {
    clear_has_type();
    auto* temp = _impl_.type_.sint64_;
    _impl_.type_.sint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_sint64(::buf::validate::SInt64Rules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sint64();
    _impl_.type_.sint64_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.sint64)
}
inline ::buf::validate::SInt64Rules* FieldConstraints::_internal_mutable_sint64() {
  if (type_case() != kSint64) {
    clear_type();
    set_has_sint64();
    _impl_.type_.sint64_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::SInt64Rules>(GetArena());
  }
  return _impl_.type_.sint64_;
}
inline ::buf::validate::SInt64Rules* FieldConstraints::mutable_sint64() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::SInt64Rules* _msg = _internal_mutable_sint64();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.sint64)
  return _msg;
}

// .buf.validate.Fixed32Rules fixed32 = 9 [json_name = "fixed32"];
inline bool FieldConstraints::has_fixed32() const {
  return type_case() == kFixed32;
}
inline bool FieldConstraints::_internal_has_fixed32() const {
  return type_case() == kFixed32;
}
inline void FieldConstraints::set_has_fixed32() {
  _impl_._oneof_case_[0] = kFixed32;
}
inline void FieldConstraints::clear_fixed32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kFixed32) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.fixed32_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.fixed32_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::Fixed32Rules* FieldConstraints::release_fixed32() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.fixed32)
  if (type_case() == kFixed32) {
    clear_has_type();
    auto* temp = _impl_.type_.fixed32_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.fixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::Fixed32Rules& FieldConstraints::_internal_fixed32() const {
  return type_case() == kFixed32 ? *_impl_.type_.fixed32_ : reinterpret_cast<::buf::validate::Fixed32Rules&>(::buf::validate::_Fixed32Rules_default_instance_);
}
inline const ::buf::validate::Fixed32Rules& FieldConstraints::fixed32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.fixed32)
  return _internal_fixed32();
}
inline ::buf::validate::Fixed32Rules* FieldConstraints::unsafe_arena_release_fixed32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.fixed32)
  if (type_case() == kFixed32) {
    clear_has_type();
    auto* temp = _impl_.type_.fixed32_;
    _impl_.type_.fixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_fixed32(::buf::validate::Fixed32Rules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_fixed32();
    _impl_.type_.fixed32_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.fixed32)
}
inline ::buf::validate::Fixed32Rules* FieldConstraints::_internal_mutable_fixed32() {
  if (type_case() != kFixed32) {
    clear_type();
    set_has_fixed32();
    _impl_.type_.fixed32_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::Fixed32Rules>(GetArena());
  }
  return _impl_.type_.fixed32_;
}
inline ::buf::validate::Fixed32Rules* FieldConstraints::mutable_fixed32() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::Fixed32Rules* _msg = _internal_mutable_fixed32();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.fixed32)
  return _msg;
}

// .buf.validate.Fixed64Rules fixed64 = 10 [json_name = "fixed64"];
inline bool FieldConstraints::has_fixed64() const {
  return type_case() == kFixed64;
}
inline bool FieldConstraints::_internal_has_fixed64() const {
  return type_case() == kFixed64;
}
inline void FieldConstraints::set_has_fixed64() {
  _impl_._oneof_case_[0] = kFixed64;
}
inline void FieldConstraints::clear_fixed64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kFixed64) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.fixed64_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.fixed64_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::Fixed64Rules* FieldConstraints::release_fixed64() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.fixed64)
  if (type_case() == kFixed64) {
    clear_has_type();
    auto* temp = _impl_.type_.fixed64_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.fixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::Fixed64Rules& FieldConstraints::_internal_fixed64() const {
  return type_case() == kFixed64 ? *_impl_.type_.fixed64_ : reinterpret_cast<::buf::validate::Fixed64Rules&>(::buf::validate::_Fixed64Rules_default_instance_);
}
inline const ::buf::validate::Fixed64Rules& FieldConstraints::fixed64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.fixed64)
  return _internal_fixed64();
}
inline ::buf::validate::Fixed64Rules* FieldConstraints::unsafe_arena_release_fixed64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.fixed64)
  if (type_case() == kFixed64) {
    clear_has_type();
    auto* temp = _impl_.type_.fixed64_;
    _impl_.type_.fixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_fixed64(::buf::validate::Fixed64Rules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_fixed64();
    _impl_.type_.fixed64_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.fixed64)
}
inline ::buf::validate::Fixed64Rules* FieldConstraints::_internal_mutable_fixed64() {
  if (type_case() != kFixed64) {
    clear_type();
    set_has_fixed64();
    _impl_.type_.fixed64_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::Fixed64Rules>(GetArena());
  }
  return _impl_.type_.fixed64_;
}
inline ::buf::validate::Fixed64Rules* FieldConstraints::mutable_fixed64() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::Fixed64Rules* _msg = _internal_mutable_fixed64();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.fixed64)
  return _msg;
}

// .buf.validate.SFixed32Rules sfixed32 = 11 [json_name = "sfixed32"];
inline bool FieldConstraints::has_sfixed32() const {
  return type_case() == kSfixed32;
}
inline bool FieldConstraints::_internal_has_sfixed32() const {
  return type_case() == kSfixed32;
}
inline void FieldConstraints::set_has_sfixed32() {
  _impl_._oneof_case_[0] = kSfixed32;
}
inline void FieldConstraints::clear_sfixed32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kSfixed32) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sfixed32_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sfixed32_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::SFixed32Rules* FieldConstraints::release_sfixed32() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.sfixed32)
  if (type_case() == kSfixed32) {
    clear_has_type();
    auto* temp = _impl_.type_.sfixed32_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sfixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::SFixed32Rules& FieldConstraints::_internal_sfixed32() const {
  return type_case() == kSfixed32 ? *_impl_.type_.sfixed32_ : reinterpret_cast<::buf::validate::SFixed32Rules&>(::buf::validate::_SFixed32Rules_default_instance_);
}
inline const ::buf::validate::SFixed32Rules& FieldConstraints::sfixed32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.sfixed32)
  return _internal_sfixed32();
}
inline ::buf::validate::SFixed32Rules* FieldConstraints::unsafe_arena_release_sfixed32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.sfixed32)
  if (type_case() == kSfixed32) {
    clear_has_type();
    auto* temp = _impl_.type_.sfixed32_;
    _impl_.type_.sfixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_sfixed32(::buf::validate::SFixed32Rules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sfixed32();
    _impl_.type_.sfixed32_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.sfixed32)
}
inline ::buf::validate::SFixed32Rules* FieldConstraints::_internal_mutable_sfixed32() {
  if (type_case() != kSfixed32) {
    clear_type();
    set_has_sfixed32();
    _impl_.type_.sfixed32_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::SFixed32Rules>(GetArena());
  }
  return _impl_.type_.sfixed32_;
}
inline ::buf::validate::SFixed32Rules* FieldConstraints::mutable_sfixed32() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::SFixed32Rules* _msg = _internal_mutable_sfixed32();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.sfixed32)
  return _msg;
}

// .buf.validate.SFixed64Rules sfixed64 = 12 [json_name = "sfixed64"];
inline bool FieldConstraints::has_sfixed64() const {
  return type_case() == kSfixed64;
}
inline bool FieldConstraints::_internal_has_sfixed64() const {
  return type_case() == kSfixed64;
}
inline void FieldConstraints::set_has_sfixed64() {
  _impl_._oneof_case_[0] = kSfixed64;
}
inline void FieldConstraints::clear_sfixed64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kSfixed64) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sfixed64_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.sfixed64_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::SFixed64Rules* FieldConstraints::release_sfixed64() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.sfixed64)
  if (type_case() == kSfixed64) {
    clear_has_type();
    auto* temp = _impl_.type_.sfixed64_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sfixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::SFixed64Rules& FieldConstraints::_internal_sfixed64() const {
  return type_case() == kSfixed64 ? *_impl_.type_.sfixed64_ : reinterpret_cast<::buf::validate::SFixed64Rules&>(::buf::validate::_SFixed64Rules_default_instance_);
}
inline const ::buf::validate::SFixed64Rules& FieldConstraints::sfixed64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.sfixed64)
  return _internal_sfixed64();
}
inline ::buf::validate::SFixed64Rules* FieldConstraints::unsafe_arena_release_sfixed64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.sfixed64)
  if (type_case() == kSfixed64) {
    clear_has_type();
    auto* temp = _impl_.type_.sfixed64_;
    _impl_.type_.sfixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_sfixed64(::buf::validate::SFixed64Rules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sfixed64();
    _impl_.type_.sfixed64_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.sfixed64)
}
inline ::buf::validate::SFixed64Rules* FieldConstraints::_internal_mutable_sfixed64() {
  if (type_case() != kSfixed64) {
    clear_type();
    set_has_sfixed64();
    _impl_.type_.sfixed64_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::SFixed64Rules>(GetArena());
  }
  return _impl_.type_.sfixed64_;
}
inline ::buf::validate::SFixed64Rules* FieldConstraints::mutable_sfixed64() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::SFixed64Rules* _msg = _internal_mutable_sfixed64();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.sfixed64)
  return _msg;
}

// .buf.validate.BoolRules bool = 13 [json_name = "bool"];
inline bool FieldConstraints::has_bool_() const {
  return type_case() == kBool;
}
inline bool FieldConstraints::_internal_has_bool_() const {
  return type_case() == kBool;
}
inline void FieldConstraints::set_has_bool_() {
  _impl_._oneof_case_[0] = kBool;
}
inline void FieldConstraints::clear_bool_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kBool) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.bool__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.bool__);
    }
    clear_has_type();
  }
}
inline ::buf::validate::BoolRules* FieldConstraints::release_bool_() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.bool)
  if (type_case() == kBool) {
    clear_has_type();
    auto* temp = _impl_.type_.bool__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::BoolRules& FieldConstraints::_internal_bool_() const {
  return type_case() == kBool ? *_impl_.type_.bool__ : reinterpret_cast<::buf::validate::BoolRules&>(::buf::validate::_BoolRules_default_instance_);
}
inline const ::buf::validate::BoolRules& FieldConstraints::bool_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.bool)
  return _internal_bool_();
}
inline ::buf::validate::BoolRules* FieldConstraints::unsafe_arena_release_bool_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.bool)
  if (type_case() == kBool) {
    clear_has_type();
    auto* temp = _impl_.type_.bool__;
    _impl_.type_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_bool_(::buf::validate::BoolRules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_bool_();
    _impl_.type_.bool__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.bool)
}
inline ::buf::validate::BoolRules* FieldConstraints::_internal_mutable_bool_() {
  if (type_case() != kBool) {
    clear_type();
    set_has_bool_();
    _impl_.type_.bool__ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::BoolRules>(GetArena());
  }
  return _impl_.type_.bool__;
}
inline ::buf::validate::BoolRules* FieldConstraints::mutable_bool_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::BoolRules* _msg = _internal_mutable_bool_();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.bool)
  return _msg;
}

// .buf.validate.StringRules string = 14 [json_name = "string"];
inline bool FieldConstraints::has_string() const {
  return type_case() == kString;
}
inline bool FieldConstraints::_internal_has_string() const {
  return type_case() == kString;
}
inline void FieldConstraints::set_has_string() {
  _impl_._oneof_case_[0] = kString;
}
inline void FieldConstraints::clear_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kString) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.string_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.string_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::StringRules* FieldConstraints::release_string() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.string)
  if (type_case() == kString) {
    clear_has_type();
    auto* temp = _impl_.type_.string_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::StringRules& FieldConstraints::_internal_string() const {
  return type_case() == kString ? *_impl_.type_.string_ : reinterpret_cast<::buf::validate::StringRules&>(::buf::validate::_StringRules_default_instance_);
}
inline const ::buf::validate::StringRules& FieldConstraints::string() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.string)
  return _internal_string();
}
inline ::buf::validate::StringRules* FieldConstraints::unsafe_arena_release_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.string)
  if (type_case() == kString) {
    clear_has_type();
    auto* temp = _impl_.type_.string_;
    _impl_.type_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_string(::buf::validate::StringRules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_string();
    _impl_.type_.string_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.string)
}
inline ::buf::validate::StringRules* FieldConstraints::_internal_mutable_string() {
  if (type_case() != kString) {
    clear_type();
    set_has_string();
    _impl_.type_.string_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::StringRules>(GetArena());
  }
  return _impl_.type_.string_;
}
inline ::buf::validate::StringRules* FieldConstraints::mutable_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::StringRules* _msg = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.string)
  return _msg;
}

// .buf.validate.BytesRules bytes = 15 [json_name = "bytes"];
inline bool FieldConstraints::has_bytes() const {
  return type_case() == kBytes;
}
inline bool FieldConstraints::_internal_has_bytes() const {
  return type_case() == kBytes;
}
inline void FieldConstraints::set_has_bytes() {
  _impl_._oneof_case_[0] = kBytes;
}
inline void FieldConstraints::clear_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kBytes) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.bytes_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.bytes_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::BytesRules* FieldConstraints::release_bytes() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.bytes)
  if (type_case() == kBytes) {
    clear_has_type();
    auto* temp = _impl_.type_.bytes_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::BytesRules& FieldConstraints::_internal_bytes() const {
  return type_case() == kBytes ? *_impl_.type_.bytes_ : reinterpret_cast<::buf::validate::BytesRules&>(::buf::validate::_BytesRules_default_instance_);
}
inline const ::buf::validate::BytesRules& FieldConstraints::bytes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.bytes)
  return _internal_bytes();
}
inline ::buf::validate::BytesRules* FieldConstraints::unsafe_arena_release_bytes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.bytes)
  if (type_case() == kBytes) {
    clear_has_type();
    auto* temp = _impl_.type_.bytes_;
    _impl_.type_.bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_bytes(::buf::validate::BytesRules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_bytes();
    _impl_.type_.bytes_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.bytes)
}
inline ::buf::validate::BytesRules* FieldConstraints::_internal_mutable_bytes() {
  if (type_case() != kBytes) {
    clear_type();
    set_has_bytes();
    _impl_.type_.bytes_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::BytesRules>(GetArena());
  }
  return _impl_.type_.bytes_;
}
inline ::buf::validate::BytesRules* FieldConstraints::mutable_bytes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::BytesRules* _msg = _internal_mutable_bytes();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.bytes)
  return _msg;
}

// .buf.validate.EnumRules enum = 16 [json_name = "enum"];
inline bool FieldConstraints::has_enum_() const {
  return type_case() == kEnum;
}
inline bool FieldConstraints::_internal_has_enum_() const {
  return type_case() == kEnum;
}
inline void FieldConstraints::set_has_enum_() {
  _impl_._oneof_case_[0] = kEnum;
}
inline void FieldConstraints::clear_enum_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kEnum) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.enum__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.enum__);
    }
    clear_has_type();
  }
}
inline ::buf::validate::EnumRules* FieldConstraints::release_enum_() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.enum)
  if (type_case() == kEnum) {
    clear_has_type();
    auto* temp = _impl_.type_.enum__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.enum__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::EnumRules& FieldConstraints::_internal_enum_() const {
  return type_case() == kEnum ? *_impl_.type_.enum__ : reinterpret_cast<::buf::validate::EnumRules&>(::buf::validate::_EnumRules_default_instance_);
}
inline const ::buf::validate::EnumRules& FieldConstraints::enum_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.enum)
  return _internal_enum_();
}
inline ::buf::validate::EnumRules* FieldConstraints::unsafe_arena_release_enum_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.enum)
  if (type_case() == kEnum) {
    clear_has_type();
    auto* temp = _impl_.type_.enum__;
    _impl_.type_.enum__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_enum_(::buf::validate::EnumRules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_enum_();
    _impl_.type_.enum__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.enum)
}
inline ::buf::validate::EnumRules* FieldConstraints::_internal_mutable_enum_() {
  if (type_case() != kEnum) {
    clear_type();
    set_has_enum_();
    _impl_.type_.enum__ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::EnumRules>(GetArena());
  }
  return _impl_.type_.enum__;
}
inline ::buf::validate::EnumRules* FieldConstraints::mutable_enum_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::EnumRules* _msg = _internal_mutable_enum_();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.enum)
  return _msg;
}

// .buf.validate.RepeatedRules repeated = 18 [json_name = "repeated"];
inline bool FieldConstraints::has_repeated() const {
  return type_case() == kRepeated;
}
inline bool FieldConstraints::_internal_has_repeated() const {
  return type_case() == kRepeated;
}
inline void FieldConstraints::set_has_repeated() {
  _impl_._oneof_case_[0] = kRepeated;
}
inline void FieldConstraints::clear_repeated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kRepeated) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.repeated_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.repeated_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::RepeatedRules* FieldConstraints::release_repeated() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.repeated)
  if (type_case() == kRepeated) {
    clear_has_type();
    auto* temp = _impl_.type_.repeated_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.repeated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::RepeatedRules& FieldConstraints::_internal_repeated() const {
  return type_case() == kRepeated ? *_impl_.type_.repeated_ : reinterpret_cast<::buf::validate::RepeatedRules&>(::buf::validate::_RepeatedRules_default_instance_);
}
inline const ::buf::validate::RepeatedRules& FieldConstraints::repeated() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.repeated)
  return _internal_repeated();
}
inline ::buf::validate::RepeatedRules* FieldConstraints::unsafe_arena_release_repeated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.repeated)
  if (type_case() == kRepeated) {
    clear_has_type();
    auto* temp = _impl_.type_.repeated_;
    _impl_.type_.repeated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_repeated(::buf::validate::RepeatedRules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_repeated();
    _impl_.type_.repeated_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.repeated)
}
inline ::buf::validate::RepeatedRules* FieldConstraints::_internal_mutable_repeated() {
  if (type_case() != kRepeated) {
    clear_type();
    set_has_repeated();
    _impl_.type_.repeated_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::RepeatedRules>(GetArena());
  }
  return _impl_.type_.repeated_;
}
inline ::buf::validate::RepeatedRules* FieldConstraints::mutable_repeated() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::RepeatedRules* _msg = _internal_mutable_repeated();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.repeated)
  return _msg;
}

// .buf.validate.MapRules map = 19 [json_name = "map"];
inline bool FieldConstraints::has_map() const {
  return type_case() == kMap;
}
inline bool FieldConstraints::_internal_has_map() const {
  return type_case() == kMap;
}
inline void FieldConstraints::set_has_map() {
  _impl_._oneof_case_[0] = kMap;
}
inline void FieldConstraints::clear_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kMap) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.map_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.map_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::MapRules* FieldConstraints::release_map() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.map)
  if (type_case() == kMap) {
    clear_has_type();
    auto* temp = _impl_.type_.map_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::MapRules& FieldConstraints::_internal_map() const {
  return type_case() == kMap ? *_impl_.type_.map_ : reinterpret_cast<::buf::validate::MapRules&>(::buf::validate::_MapRules_default_instance_);
}
inline const ::buf::validate::MapRules& FieldConstraints::map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.map)
  return _internal_map();
}
inline ::buf::validate::MapRules* FieldConstraints::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.map)
  if (type_case() == kMap) {
    clear_has_type();
    auto* temp = _impl_.type_.map_;
    _impl_.type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_map(::buf::validate::MapRules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_map();
    _impl_.type_.map_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.map)
}
inline ::buf::validate::MapRules* FieldConstraints::_internal_mutable_map() {
  if (type_case() != kMap) {
    clear_type();
    set_has_map();
    _impl_.type_.map_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::MapRules>(GetArena());
  }
  return _impl_.type_.map_;
}
inline ::buf::validate::MapRules* FieldConstraints::mutable_map() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::MapRules* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.map)
  return _msg;
}

// .buf.validate.AnyRules any = 20 [json_name = "any"];
inline bool FieldConstraints::has_any() const {
  return type_case() == kAny;
}
inline bool FieldConstraints::_internal_has_any() const {
  return type_case() == kAny;
}
inline void FieldConstraints::set_has_any() {
  _impl_._oneof_case_[0] = kAny;
}
inline void FieldConstraints::clear_any() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kAny) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.any_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.any_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::AnyRules* FieldConstraints::release_any() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.any)
  if (type_case() == kAny) {
    clear_has_type();
    auto* temp = _impl_.type_.any_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.any_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::AnyRules& FieldConstraints::_internal_any() const {
  return type_case() == kAny ? *_impl_.type_.any_ : reinterpret_cast<::buf::validate::AnyRules&>(::buf::validate::_AnyRules_default_instance_);
}
inline const ::buf::validate::AnyRules& FieldConstraints::any() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.any)
  return _internal_any();
}
inline ::buf::validate::AnyRules* FieldConstraints::unsafe_arena_release_any() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.any)
  if (type_case() == kAny) {
    clear_has_type();
    auto* temp = _impl_.type_.any_;
    _impl_.type_.any_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_any(::buf::validate::AnyRules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_any();
    _impl_.type_.any_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.any)
}
inline ::buf::validate::AnyRules* FieldConstraints::_internal_mutable_any() {
  if (type_case() != kAny) {
    clear_type();
    set_has_any();
    _impl_.type_.any_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::AnyRules>(GetArena());
  }
  return _impl_.type_.any_;
}
inline ::buf::validate::AnyRules* FieldConstraints::mutable_any() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::AnyRules* _msg = _internal_mutable_any();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.any)
  return _msg;
}

// .buf.validate.DurationRules duration = 21 [json_name = "duration"];
inline bool FieldConstraints::has_duration() const {
  return type_case() == kDuration;
}
inline bool FieldConstraints::_internal_has_duration() const {
  return type_case() == kDuration;
}
inline void FieldConstraints::set_has_duration() {
  _impl_._oneof_case_[0] = kDuration;
}
inline void FieldConstraints::clear_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kDuration) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.duration_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.duration_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::DurationRules* FieldConstraints::release_duration() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.duration)
  if (type_case() == kDuration) {
    clear_has_type();
    auto* temp = _impl_.type_.duration_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::DurationRules& FieldConstraints::_internal_duration() const {
  return type_case() == kDuration ? *_impl_.type_.duration_ : reinterpret_cast<::buf::validate::DurationRules&>(::buf::validate::_DurationRules_default_instance_);
}
inline const ::buf::validate::DurationRules& FieldConstraints::duration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.duration)
  return _internal_duration();
}
inline ::buf::validate::DurationRules* FieldConstraints::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.duration)
  if (type_case() == kDuration) {
    clear_has_type();
    auto* temp = _impl_.type_.duration_;
    _impl_.type_.duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_duration(::buf::validate::DurationRules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_duration();
    _impl_.type_.duration_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.duration)
}
inline ::buf::validate::DurationRules* FieldConstraints::_internal_mutable_duration() {
  if (type_case() != kDuration) {
    clear_type();
    set_has_duration();
    _impl_.type_.duration_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::DurationRules>(GetArena());
  }
  return _impl_.type_.duration_;
}
inline ::buf::validate::DurationRules* FieldConstraints::mutable_duration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::DurationRules* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.duration)
  return _msg;
}

// .buf.validate.TimestampRules timestamp = 22 [json_name = "timestamp"];
inline bool FieldConstraints::has_timestamp() const {
  return type_case() == kTimestamp;
}
inline bool FieldConstraints::_internal_has_timestamp() const {
  return type_case() == kTimestamp;
}
inline void FieldConstraints::set_has_timestamp() {
  _impl_._oneof_case_[0] = kTimestamp;
}
inline void FieldConstraints::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kTimestamp) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.timestamp_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.timestamp_);
    }
    clear_has_type();
  }
}
inline ::buf::validate::TimestampRules* FieldConstraints::release_timestamp() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.timestamp)
  if (type_case() == kTimestamp) {
    clear_has_type();
    auto* temp = _impl_.type_.timestamp_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::TimestampRules& FieldConstraints::_internal_timestamp() const {
  return type_case() == kTimestamp ? *_impl_.type_.timestamp_ : reinterpret_cast<::buf::validate::TimestampRules&>(::buf::validate::_TimestampRules_default_instance_);
}
inline const ::buf::validate::TimestampRules& FieldConstraints::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.timestamp)
  return _internal_timestamp();
}
inline ::buf::validate::TimestampRules* FieldConstraints::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.timestamp)
  if (type_case() == kTimestamp) {
    clear_has_type();
    auto* temp = _impl_.type_.timestamp_;
    _impl_.type_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_timestamp(::buf::validate::TimestampRules* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_timestamp();
    _impl_.type_.timestamp_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.timestamp)
}
inline ::buf::validate::TimestampRules* FieldConstraints::_internal_mutable_timestamp() {
  if (type_case() != kTimestamp) {
    clear_type();
    set_has_timestamp();
    _impl_.type_.timestamp_ =
        ::google::protobuf::Message::DefaultConstruct<::buf::validate::TimestampRules>(GetArena());
  }
  return _impl_.type_.timestamp_;
}
inline ::buf::validate::TimestampRules* FieldConstraints::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::buf::validate::TimestampRules* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.timestamp)
  return _msg;
}

// optional bool skipped = 24 [json_name = "skipped", deprecated = true];
inline bool FieldConstraints::has_skipped() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FieldConstraints::clear_skipped() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skipped_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool FieldConstraints::skipped() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.skipped)
  return _internal_skipped();
}
inline void FieldConstraints::set_skipped(bool value) {
  _internal_set_skipped(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:buf.validate.FieldConstraints.skipped)
}
inline bool FieldConstraints::_internal_skipped() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.skipped_;
}
inline void FieldConstraints::_internal_set_skipped(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.skipped_ = value;
}

// optional bool ignore_empty = 26 [json_name = "ignoreEmpty", deprecated = true];
inline bool FieldConstraints::has_ignore_empty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FieldConstraints::clear_ignore_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool FieldConstraints::ignore_empty() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.ignore_empty)
  return _internal_ignore_empty();
}
inline void FieldConstraints::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:buf.validate.FieldConstraints.ignore_empty)
}
inline bool FieldConstraints::_internal_ignore_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_empty_;
}
inline void FieldConstraints::_internal_set_ignore_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_empty_ = value;
}

inline bool FieldConstraints::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void FieldConstraints::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline FieldConstraints::TypeCase FieldConstraints::type_case() const {
  return FieldConstraints::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PredefinedConstraints

// repeated .buf.validate.Constraint cel = 1 [json_name = "cel"];
inline int PredefinedConstraints::_internal_cel_size() const {
  return _internal_cel().size();
}
inline int PredefinedConstraints::cel_size() const {
  return _internal_cel_size();
}
inline void PredefinedConstraints::clear_cel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cel_.Clear();
}
inline ::buf::validate::Constraint* PredefinedConstraints::mutable_cel(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.PredefinedConstraints.cel)
  return _internal_mutable_cel()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>* PredefinedConstraints::mutable_cel()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.PredefinedConstraints.cel)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cel();
}
inline const ::buf::validate::Constraint& PredefinedConstraints::cel(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.PredefinedConstraints.cel)
  return _internal_cel().Get(index);
}
inline ::buf::validate::Constraint* PredefinedConstraints::add_cel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::buf::validate::Constraint* _add = _internal_mutable_cel()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.PredefinedConstraints.cel)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>& PredefinedConstraints::cel() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.PredefinedConstraints.cel)
  return _internal_cel();
}
inline const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>&
PredefinedConstraints::_internal_cel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cel_;
}
inline ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>*
PredefinedConstraints::_internal_mutable_cel() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cel_;
}

// -------------------------------------------------------------------

// FloatRules

// optional float const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool FloatRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FloatRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float FloatRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.const)
  return _internal_const_();
}
inline void FloatRules::set_const_(float value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.const)
}
inline float FloatRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void FloatRules::_internal_set_const_(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// float lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool FloatRules::has_lt() const {
  return less_than_case() == kLt;
}
inline void FloatRules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void FloatRules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0;
    clear_has_less_than();
  }
}
inline float FloatRules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.lt)
  return _internal_lt();
}
inline void FloatRules::set_lt(float value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.lt)
}
inline float FloatRules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0;
}

// float lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool FloatRules::has_lte() const {
  return less_than_case() == kLte;
}
inline void FloatRules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void FloatRules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0;
    clear_has_less_than();
  }
}
inline float FloatRules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.lte)
  return _internal_lte();
}
inline void FloatRules::set_lte(float value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.lte)
}
inline float FloatRules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0;
}

// float gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool FloatRules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void FloatRules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void FloatRules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0;
    clear_has_greater_than();
  }
}
inline float FloatRules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.gt)
  return _internal_gt();
}
inline void FloatRules::set_gt(float value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.gt)
}
inline float FloatRules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0;
}

// float gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool FloatRules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void FloatRules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void FloatRules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0;
    clear_has_greater_than();
  }
}
inline float FloatRules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.gte)
  return _internal_gte();
}
inline void FloatRules::set_gte(float value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.gte)
}
inline float FloatRules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0;
}

// repeated float in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int FloatRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int FloatRules::in_size() const {
  return _internal_in_size();
}
inline void FloatRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline float FloatRules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.in)
  return _internal_in().Get(index);
}
inline void FloatRules::set_in(int index, float value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.in)
}
inline void FloatRules::add_in(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.FloatRules.in)
}
inline const ::google::protobuf::RepeatedField<float>& FloatRules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.FloatRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<float>* FloatRules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.FloatRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<float>&
FloatRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<float>* FloatRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated float not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int FloatRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int FloatRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void FloatRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline float FloatRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.not_in)
  return _internal_not_in().Get(index);
}
inline void FloatRules::set_not_in(int index, float value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.not_in)
}
inline void FloatRules::add_not_in(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.FloatRules.not_in)
}
inline const ::google::protobuf::RepeatedField<float>& FloatRules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.FloatRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<float>* FloatRules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.FloatRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<float>&
FloatRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<float>* FloatRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
inline bool FloatRules::has_finite() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FloatRules::clear_finite() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.finite_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool FloatRules::finite() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.finite)
  return _internal_finite();
}
inline void FloatRules::set_finite(bool value) {
  _internal_set_finite(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.finite)
}
inline bool FloatRules::_internal_finite() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.finite_;
}
inline void FloatRules::_internal_set_finite(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.finite_ = value;
}

// repeated float example = 9 [json_name = "example", (.buf.validate.predefined) = {
inline int FloatRules::_internal_example_size() const {
  return _internal_example().size();
}
inline int FloatRules::example_size() const {
  return _internal_example_size();
}
inline void FloatRules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline float FloatRules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.example)
  return _internal_example().Get(index);
}
inline void FloatRules::set_example(int index, float value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.example)
}
inline void FloatRules::add_example(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.FloatRules.example)
}
inline const ::google::protobuf::RepeatedField<float>& FloatRules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.FloatRules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<float>* FloatRules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.FloatRules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<float>&
FloatRules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<float>* FloatRules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool FloatRules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void FloatRules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool FloatRules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void FloatRules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline FloatRules::LessThanCase FloatRules::less_than_case() const {
  return FloatRules::LessThanCase(_impl_._oneof_case_[0]);
}
inline FloatRules::GreaterThanCase FloatRules::greater_than_case() const {
  return FloatRules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// DoubleRules

// optional double const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool DoubleRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DoubleRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double DoubleRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.const)
  return _internal_const_();
}
inline void DoubleRules::set_const_(double value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.const)
}
inline double DoubleRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void DoubleRules::_internal_set_const_(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// double lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool DoubleRules::has_lt() const {
  return less_than_case() == kLt;
}
inline void DoubleRules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void DoubleRules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0;
    clear_has_less_than();
  }
}
inline double DoubleRules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.lt)
  return _internal_lt();
}
inline void DoubleRules::set_lt(double value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.lt)
}
inline double DoubleRules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0;
}

// double lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool DoubleRules::has_lte() const {
  return less_than_case() == kLte;
}
inline void DoubleRules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void DoubleRules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0;
    clear_has_less_than();
  }
}
inline double DoubleRules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.lte)
  return _internal_lte();
}
inline void DoubleRules::set_lte(double value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.lte)
}
inline double DoubleRules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0;
}

// double gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool DoubleRules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void DoubleRules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void DoubleRules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0;
    clear_has_greater_than();
  }
}
inline double DoubleRules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.gt)
  return _internal_gt();
}
inline void DoubleRules::set_gt(double value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.gt)
}
inline double DoubleRules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0;
}

// double gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool DoubleRules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void DoubleRules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void DoubleRules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0;
    clear_has_greater_than();
  }
}
inline double DoubleRules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.gte)
  return _internal_gte();
}
inline void DoubleRules::set_gte(double value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.gte)
}
inline double DoubleRules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0;
}

// repeated double in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int DoubleRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int DoubleRules::in_size() const {
  return _internal_in_size();
}
inline void DoubleRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline double DoubleRules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.in)
  return _internal_in().Get(index);
}
inline void DoubleRules::set_in(int index, double value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.in)
}
inline void DoubleRules::add_in(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.DoubleRules.in)
}
inline const ::google::protobuf::RepeatedField<double>& DoubleRules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.DoubleRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<double>* DoubleRules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.DoubleRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<double>&
DoubleRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<double>* DoubleRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated double not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int DoubleRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int DoubleRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void DoubleRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline double DoubleRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.not_in)
  return _internal_not_in().Get(index);
}
inline void DoubleRules::set_not_in(int index, double value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.not_in)
}
inline void DoubleRules::add_not_in(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.DoubleRules.not_in)
}
inline const ::google::protobuf::RepeatedField<double>& DoubleRules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.DoubleRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<double>* DoubleRules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.DoubleRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<double>&
DoubleRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<double>* DoubleRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// optional bool finite = 8 [json_name = "finite", (.buf.validate.predefined) = {
inline bool DoubleRules::has_finite() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DoubleRules::clear_finite() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.finite_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DoubleRules::finite() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.finite)
  return _internal_finite();
}
inline void DoubleRules::set_finite(bool value) {
  _internal_set_finite(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.finite)
}
inline bool DoubleRules::_internal_finite() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.finite_;
}
inline void DoubleRules::_internal_set_finite(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.finite_ = value;
}

// repeated double example = 9 [json_name = "example", (.buf.validate.predefined) = {
inline int DoubleRules::_internal_example_size() const {
  return _internal_example().size();
}
inline int DoubleRules::example_size() const {
  return _internal_example_size();
}
inline void DoubleRules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline double DoubleRules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.example)
  return _internal_example().Get(index);
}
inline void DoubleRules::set_example(int index, double value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.example)
}
inline void DoubleRules::add_example(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.DoubleRules.example)
}
inline const ::google::protobuf::RepeatedField<double>& DoubleRules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.DoubleRules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<double>* DoubleRules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.DoubleRules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<double>&
DoubleRules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<double>* DoubleRules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool DoubleRules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void DoubleRules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool DoubleRules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void DoubleRules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline DoubleRules::LessThanCase DoubleRules::less_than_case() const {
  return DoubleRules::LessThanCase(_impl_._oneof_case_[0]);
}
inline DoubleRules::GreaterThanCase DoubleRules::greater_than_case() const {
  return DoubleRules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Int32Rules

// optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool Int32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Int32Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Int32Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.const)
  return _internal_const_();
}
inline void Int32Rules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.const)
}
inline ::int32_t Int32Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void Int32Rules::_internal_set_const_(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// int32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool Int32Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void Int32Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void Int32Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t Int32Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.lt)
  return _internal_lt();
}
inline void Int32Rules::set_lt(::int32_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.lt)
}
inline ::int32_t Int32Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0;
}

// int32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool Int32Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void Int32Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void Int32Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t Int32Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.lte)
  return _internal_lte();
}
inline void Int32Rules::set_lte(::int32_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.lte)
}
inline ::int32_t Int32Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0;
}

// int32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool Int32Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void Int32Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void Int32Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t Int32Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.gt)
  return _internal_gt();
}
inline void Int32Rules::set_gt(::int32_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.gt)
}
inline ::int32_t Int32Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0;
}

// int32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool Int32Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void Int32Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void Int32Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t Int32Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.gte)
  return _internal_gte();
}
inline void Int32Rules::set_gte(::int32_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.gte)
}
inline ::int32_t Int32Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0;
}

// repeated int32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int Int32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Int32Rules::in_size() const {
  return _internal_in_size();
}
inline void Int32Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int32_t Int32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.in)
  return _internal_in().Get(index);
}
inline void Int32Rules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.in)
}
inline void Int32Rules::add_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Int32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Int32Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Int32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Int32Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
Int32Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int Int32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Int32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Int32Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int32_t Int32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Int32Rules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.not_in)
}
inline void Int32Rules::add_not_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Int32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Int32Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Int32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Int32Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
Int32Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated int32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
inline int Int32Rules::_internal_example_size() const {
  return _internal_example().size();
}
inline int Int32Rules::example_size() const {
  return _internal_example_size();
}
inline void Int32Rules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline ::int32_t Int32Rules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.example)
  return _internal_example().Get(index);
}
inline void Int32Rules::set_example(int index, ::int32_t value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.example)
}
inline void Int32Rules::add_example(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Int32Rules.example)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Int32Rules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Int32Rules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Rules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Int32Rules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
Int32Rules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Rules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool Int32Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void Int32Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool Int32Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void Int32Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline Int32Rules::LessThanCase Int32Rules::less_than_case() const {
  return Int32Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline Int32Rules::GreaterThanCase Int32Rules::greater_than_case() const {
  return Int32Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Int64Rules

// optional int64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool Int64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Int64Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t Int64Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.const)
  return _internal_const_();
}
inline void Int64Rules::set_const_(::int64_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.const)
}
inline ::int64_t Int64Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void Int64Rules::_internal_set_const_(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// int64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool Int64Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void Int64Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void Int64Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t Int64Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.lt)
  return _internal_lt();
}
inline void Int64Rules::set_lt(::int64_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.lt)
}
inline ::int64_t Int64Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return ::int64_t{0};
}

// int64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool Int64Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void Int64Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void Int64Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t Int64Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.lte)
  return _internal_lte();
}
inline void Int64Rules::set_lte(::int64_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.lte)
}
inline ::int64_t Int64Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return ::int64_t{0};
}

// int64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool Int64Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void Int64Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void Int64Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t Int64Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.gt)
  return _internal_gt();
}
inline void Int64Rules::set_gt(::int64_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.gt)
}
inline ::int64_t Int64Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return ::int64_t{0};
}

// int64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool Int64Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void Int64Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void Int64Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t Int64Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.gte)
  return _internal_gte();
}
inline void Int64Rules::set_gte(::int64_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.gte)
}
inline ::int64_t Int64Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return ::int64_t{0};
}

// repeated int64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int Int64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Int64Rules::in_size() const {
  return _internal_in_size();
}
inline void Int64Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int64_t Int64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.in)
  return _internal_in().Get(index);
}
inline void Int64Rules::set_in(int index, ::int64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.in)
}
inline void Int64Rules::add_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Int64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Int64Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Int64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Int64Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
Int64Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int Int64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Int64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Int64Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int64_t Int64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Int64Rules::set_not_in(int index, ::int64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.not_in)
}
inline void Int64Rules::add_not_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Int64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Int64Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Int64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Int64Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
Int64Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated int64 example = 9 [json_name = "example", (.buf.validate.predefined) = {
inline int Int64Rules::_internal_example_size() const {
  return _internal_example().size();
}
inline int Int64Rules::example_size() const {
  return _internal_example_size();
}
inline void Int64Rules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline ::int64_t Int64Rules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.example)
  return _internal_example().Get(index);
}
inline void Int64Rules::set_example(int index, ::int64_t value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.example)
}
inline void Int64Rules::add_example(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Int64Rules.example)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Int64Rules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Int64Rules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Rules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Int64Rules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
Int64Rules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Rules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool Int64Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void Int64Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool Int64Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void Int64Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline Int64Rules::LessThanCase Int64Rules::less_than_case() const {
  return Int64Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline Int64Rules::GreaterThanCase Int64Rules::greater_than_case() const {
  return Int64Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// UInt32Rules

// optional uint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool UInt32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UInt32Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t UInt32Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.const)
  return _internal_const_();
}
inline void UInt32Rules::set_const_(::uint32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.const)
}
inline ::uint32_t UInt32Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void UInt32Rules::_internal_set_const_(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// uint32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool UInt32Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void UInt32Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void UInt32Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0u;
    clear_has_less_than();
  }
}
inline ::uint32_t UInt32Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.lt)
  return _internal_lt();
}
inline void UInt32Rules::set_lt(::uint32_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.lt)
}
inline ::uint32_t UInt32Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0u;
}

// uint32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool UInt32Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void UInt32Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void UInt32Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0u;
    clear_has_less_than();
  }
}
inline ::uint32_t UInt32Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.lte)
  return _internal_lte();
}
inline void UInt32Rules::set_lte(::uint32_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.lte)
}
inline ::uint32_t UInt32Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0u;
}

// uint32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool UInt32Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void UInt32Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void UInt32Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0u;
    clear_has_greater_than();
  }
}
inline ::uint32_t UInt32Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.gt)
  return _internal_gt();
}
inline void UInt32Rules::set_gt(::uint32_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.gt)
}
inline ::uint32_t UInt32Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0u;
}

// uint32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool UInt32Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void UInt32Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void UInt32Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0u;
    clear_has_greater_than();
  }
}
inline ::uint32_t UInt32Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.gte)
  return _internal_gte();
}
inline void UInt32Rules::set_gte(::uint32_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.gte)
}
inline ::uint32_t UInt32Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0u;
}

// repeated uint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int UInt32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int UInt32Rules::in_size() const {
  return _internal_in_size();
}
inline void UInt32Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::uint32_t UInt32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.in)
  return _internal_in().Get(index);
}
inline void UInt32Rules::set_in(int index, ::uint32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.in)
}
inline void UInt32Rules::add_in(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.UInt32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& UInt32Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.UInt32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* UInt32Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.UInt32Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
UInt32Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* UInt32Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int UInt32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int UInt32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void UInt32Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::uint32_t UInt32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void UInt32Rules::set_not_in(int index, ::uint32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.not_in)
}
inline void UInt32Rules::add_not_in(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.UInt32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& UInt32Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.UInt32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* UInt32Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.UInt32Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
UInt32Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* UInt32Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated uint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
inline int UInt32Rules::_internal_example_size() const {
  return _internal_example().size();
}
inline int UInt32Rules::example_size() const {
  return _internal_example_size();
}
inline void UInt32Rules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline ::uint32_t UInt32Rules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.example)
  return _internal_example().Get(index);
}
inline void UInt32Rules::set_example(int index, ::uint32_t value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.example)
}
inline void UInt32Rules::add_example(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.UInt32Rules.example)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& UInt32Rules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.UInt32Rules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* UInt32Rules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.UInt32Rules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
UInt32Rules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* UInt32Rules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool UInt32Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void UInt32Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool UInt32Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void UInt32Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline UInt32Rules::LessThanCase UInt32Rules::less_than_case() const {
  return UInt32Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline UInt32Rules::GreaterThanCase UInt32Rules::greater_than_case() const {
  return UInt32Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// UInt64Rules

// optional uint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool UInt64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UInt64Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t UInt64Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.const)
  return _internal_const_();
}
inline void UInt64Rules::set_const_(::uint64_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.const)
}
inline ::uint64_t UInt64Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void UInt64Rules::_internal_set_const_(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// uint64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool UInt64Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void UInt64Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void UInt64Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = ::uint64_t{0u};
    clear_has_less_than();
  }
}
inline ::uint64_t UInt64Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.lt)
  return _internal_lt();
}
inline void UInt64Rules::set_lt(::uint64_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.lt)
}
inline ::uint64_t UInt64Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return ::uint64_t{0u};
}

// uint64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool UInt64Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void UInt64Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void UInt64Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = ::uint64_t{0u};
    clear_has_less_than();
  }
}
inline ::uint64_t UInt64Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.lte)
  return _internal_lte();
}
inline void UInt64Rules::set_lte(::uint64_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.lte)
}
inline ::uint64_t UInt64Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return ::uint64_t{0u};
}

// uint64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool UInt64Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void UInt64Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void UInt64Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = ::uint64_t{0u};
    clear_has_greater_than();
  }
}
inline ::uint64_t UInt64Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.gt)
  return _internal_gt();
}
inline void UInt64Rules::set_gt(::uint64_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.gt)
}
inline ::uint64_t UInt64Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return ::uint64_t{0u};
}

// uint64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool UInt64Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void UInt64Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void UInt64Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = ::uint64_t{0u};
    clear_has_greater_than();
  }
}
inline ::uint64_t UInt64Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.gte)
  return _internal_gte();
}
inline void UInt64Rules::set_gte(::uint64_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.gte)
}
inline ::uint64_t UInt64Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return ::uint64_t{0u};
}

// repeated uint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int UInt64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int UInt64Rules::in_size() const {
  return _internal_in_size();
}
inline void UInt64Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::uint64_t UInt64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.in)
  return _internal_in().Get(index);
}
inline void UInt64Rules::set_in(int index, ::uint64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.in)
}
inline void UInt64Rules::add_in(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.UInt64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& UInt64Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.UInt64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* UInt64Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.UInt64Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
UInt64Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* UInt64Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int UInt64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int UInt64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void UInt64Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::uint64_t UInt64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void UInt64Rules::set_not_in(int index, ::uint64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.not_in)
}
inline void UInt64Rules::add_not_in(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.UInt64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& UInt64Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.UInt64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* UInt64Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.UInt64Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
UInt64Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* UInt64Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated uint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
inline int UInt64Rules::_internal_example_size() const {
  return _internal_example().size();
}
inline int UInt64Rules::example_size() const {
  return _internal_example_size();
}
inline void UInt64Rules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline ::uint64_t UInt64Rules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.example)
  return _internal_example().Get(index);
}
inline void UInt64Rules::set_example(int index, ::uint64_t value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.example)
}
inline void UInt64Rules::add_example(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.UInt64Rules.example)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& UInt64Rules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.UInt64Rules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* UInt64Rules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.UInt64Rules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
UInt64Rules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* UInt64Rules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool UInt64Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void UInt64Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool UInt64Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void UInt64Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline UInt64Rules::LessThanCase UInt64Rules::less_than_case() const {
  return UInt64Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline UInt64Rules::GreaterThanCase UInt64Rules::greater_than_case() const {
  return UInt64Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// SInt32Rules

// optional sint32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool SInt32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SInt32Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SInt32Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.const)
  return _internal_const_();
}
inline void SInt32Rules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.const)
}
inline ::int32_t SInt32Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void SInt32Rules::_internal_set_const_(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// sint32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool SInt32Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void SInt32Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void SInt32Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t SInt32Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.lt)
  return _internal_lt();
}
inline void SInt32Rules::set_lt(::int32_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.lt)
}
inline ::int32_t SInt32Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0;
}

// sint32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool SInt32Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void SInt32Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void SInt32Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t SInt32Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.lte)
  return _internal_lte();
}
inline void SInt32Rules::set_lte(::int32_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.lte)
}
inline ::int32_t SInt32Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0;
}

// sint32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool SInt32Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void SInt32Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void SInt32Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t SInt32Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.gt)
  return _internal_gt();
}
inline void SInt32Rules::set_gt(::int32_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.gt)
}
inline ::int32_t SInt32Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0;
}

// sint32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool SInt32Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void SInt32Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void SInt32Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t SInt32Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.gte)
  return _internal_gte();
}
inline void SInt32Rules::set_gte(::int32_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.gte)
}
inline ::int32_t SInt32Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0;
}

// repeated sint32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int SInt32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SInt32Rules::in_size() const {
  return _internal_in_size();
}
inline void SInt32Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int32_t SInt32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.in)
  return _internal_in().Get(index);
}
inline void SInt32Rules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.in)
}
inline void SInt32Rules::add_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SInt32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SInt32Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SInt32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SInt32Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SInt32Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SInt32Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SInt32Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int SInt32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SInt32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SInt32Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int32_t SInt32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SInt32Rules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.not_in)
}
inline void SInt32Rules::add_not_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SInt32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SInt32Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SInt32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SInt32Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SInt32Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SInt32Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SInt32Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated sint32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
inline int SInt32Rules::_internal_example_size() const {
  return _internal_example().size();
}
inline int SInt32Rules::example_size() const {
  return _internal_example_size();
}
inline void SInt32Rules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline ::int32_t SInt32Rules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.example)
  return _internal_example().Get(index);
}
inline void SInt32Rules::set_example(int index, ::int32_t value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.example)
}
inline void SInt32Rules::add_example(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SInt32Rules.example)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SInt32Rules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SInt32Rules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SInt32Rules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SInt32Rules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SInt32Rules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SInt32Rules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool SInt32Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void SInt32Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool SInt32Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void SInt32Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline SInt32Rules::LessThanCase SInt32Rules::less_than_case() const {
  return SInt32Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline SInt32Rules::GreaterThanCase SInt32Rules::greater_than_case() const {
  return SInt32Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// SInt64Rules

// optional sint64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool SInt64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SInt64Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t SInt64Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.const)
  return _internal_const_();
}
inline void SInt64Rules::set_const_(::int64_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.const)
}
inline ::int64_t SInt64Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void SInt64Rules::_internal_set_const_(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// sint64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool SInt64Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void SInt64Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void SInt64Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t SInt64Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.lt)
  return _internal_lt();
}
inline void SInt64Rules::set_lt(::int64_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.lt)
}
inline ::int64_t SInt64Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return ::int64_t{0};
}

// sint64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool SInt64Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void SInt64Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void SInt64Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t SInt64Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.lte)
  return _internal_lte();
}
inline void SInt64Rules::set_lte(::int64_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.lte)
}
inline ::int64_t SInt64Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return ::int64_t{0};
}

// sint64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool SInt64Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void SInt64Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void SInt64Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t SInt64Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.gt)
  return _internal_gt();
}
inline void SInt64Rules::set_gt(::int64_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.gt)
}
inline ::int64_t SInt64Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return ::int64_t{0};
}

// sint64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool SInt64Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void SInt64Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void SInt64Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t SInt64Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.gte)
  return _internal_gte();
}
inline void SInt64Rules::set_gte(::int64_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.gte)
}
inline ::int64_t SInt64Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return ::int64_t{0};
}

// repeated sint64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int SInt64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SInt64Rules::in_size() const {
  return _internal_in_size();
}
inline void SInt64Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int64_t SInt64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.in)
  return _internal_in().Get(index);
}
inline void SInt64Rules::set_in(int index, ::int64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.in)
}
inline void SInt64Rules::add_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SInt64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SInt64Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SInt64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* SInt64Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SInt64Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
SInt64Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* SInt64Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int SInt64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SInt64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SInt64Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int64_t SInt64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SInt64Rules::set_not_in(int index, ::int64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.not_in)
}
inline void SInt64Rules::add_not_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SInt64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SInt64Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SInt64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* SInt64Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SInt64Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
SInt64Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* SInt64Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated sint64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
inline int SInt64Rules::_internal_example_size() const {
  return _internal_example().size();
}
inline int SInt64Rules::example_size() const {
  return _internal_example_size();
}
inline void SInt64Rules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline ::int64_t SInt64Rules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.example)
  return _internal_example().Get(index);
}
inline void SInt64Rules::set_example(int index, ::int64_t value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.example)
}
inline void SInt64Rules::add_example(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SInt64Rules.example)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SInt64Rules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SInt64Rules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<::int64_t>* SInt64Rules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SInt64Rules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
SInt64Rules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* SInt64Rules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool SInt64Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void SInt64Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool SInt64Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void SInt64Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline SInt64Rules::LessThanCase SInt64Rules::less_than_case() const {
  return SInt64Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline SInt64Rules::GreaterThanCase SInt64Rules::greater_than_case() const {
  return SInt64Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Fixed32Rules

// optional fixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool Fixed32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Fixed32Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Fixed32Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.const)
  return _internal_const_();
}
inline void Fixed32Rules::set_const_(::uint32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.const)
}
inline ::uint32_t Fixed32Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void Fixed32Rules::_internal_set_const_(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// fixed32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool Fixed32Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void Fixed32Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void Fixed32Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0u;
    clear_has_less_than();
  }
}
inline ::uint32_t Fixed32Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.lt)
  return _internal_lt();
}
inline void Fixed32Rules::set_lt(::uint32_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.lt)
}
inline ::uint32_t Fixed32Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0u;
}

// fixed32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool Fixed32Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void Fixed32Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void Fixed32Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0u;
    clear_has_less_than();
  }
}
inline ::uint32_t Fixed32Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.lte)
  return _internal_lte();
}
inline void Fixed32Rules::set_lte(::uint32_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.lte)
}
inline ::uint32_t Fixed32Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0u;
}

// fixed32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool Fixed32Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void Fixed32Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void Fixed32Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0u;
    clear_has_greater_than();
  }
}
inline ::uint32_t Fixed32Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.gt)
  return _internal_gt();
}
inline void Fixed32Rules::set_gt(::uint32_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.gt)
}
inline ::uint32_t Fixed32Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0u;
}

// fixed32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool Fixed32Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void Fixed32Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void Fixed32Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0u;
    clear_has_greater_than();
  }
}
inline ::uint32_t Fixed32Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.gte)
  return _internal_gte();
}
inline void Fixed32Rules::set_gte(::uint32_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.gte)
}
inline ::uint32_t Fixed32Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0u;
}

// repeated fixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int Fixed32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Fixed32Rules::in_size() const {
  return _internal_in_size();
}
inline void Fixed32Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::uint32_t Fixed32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.in)
  return _internal_in().Get(index);
}
inline void Fixed32Rules::set_in(int index, ::uint32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.in)
}
inline void Fixed32Rules::add_in(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Fixed32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Fixed32Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Fixed32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Fixed32Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Fixed32Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int Fixed32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Fixed32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Fixed32Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::uint32_t Fixed32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Fixed32Rules::set_not_in(int index, ::uint32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.not_in)
}
inline void Fixed32Rules::add_not_in(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Fixed32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Fixed32Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Fixed32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Fixed32Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Fixed32Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated fixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
inline int Fixed32Rules::_internal_example_size() const {
  return _internal_example().size();
}
inline int Fixed32Rules::example_size() const {
  return _internal_example_size();
}
inline void Fixed32Rules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline ::uint32_t Fixed32Rules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.example)
  return _internal_example().Get(index);
}
inline void Fixed32Rules::set_example(int index, ::uint32_t value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.example)
}
inline void Fixed32Rules::add_example(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Fixed32Rules.example)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Fixed32Rules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Fixed32Rules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32Rules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Fixed32Rules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Fixed32Rules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32Rules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool Fixed32Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void Fixed32Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool Fixed32Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void Fixed32Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline Fixed32Rules::LessThanCase Fixed32Rules::less_than_case() const {
  return Fixed32Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline Fixed32Rules::GreaterThanCase Fixed32Rules::greater_than_case() const {
  return Fixed32Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Fixed64Rules

// optional fixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool Fixed64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Fixed64Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t Fixed64Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.const)
  return _internal_const_();
}
inline void Fixed64Rules::set_const_(::uint64_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.const)
}
inline ::uint64_t Fixed64Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void Fixed64Rules::_internal_set_const_(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// fixed64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool Fixed64Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void Fixed64Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void Fixed64Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = ::uint64_t{0u};
    clear_has_less_than();
  }
}
inline ::uint64_t Fixed64Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.lt)
  return _internal_lt();
}
inline void Fixed64Rules::set_lt(::uint64_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.lt)
}
inline ::uint64_t Fixed64Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return ::uint64_t{0u};
}

// fixed64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool Fixed64Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void Fixed64Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void Fixed64Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = ::uint64_t{0u};
    clear_has_less_than();
  }
}
inline ::uint64_t Fixed64Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.lte)
  return _internal_lte();
}
inline void Fixed64Rules::set_lte(::uint64_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.lte)
}
inline ::uint64_t Fixed64Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return ::uint64_t{0u};
}

// fixed64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool Fixed64Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void Fixed64Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void Fixed64Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = ::uint64_t{0u};
    clear_has_greater_than();
  }
}
inline ::uint64_t Fixed64Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.gt)
  return _internal_gt();
}
inline void Fixed64Rules::set_gt(::uint64_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.gt)
}
inline ::uint64_t Fixed64Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return ::uint64_t{0u};
}

// fixed64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool Fixed64Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void Fixed64Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void Fixed64Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = ::uint64_t{0u};
    clear_has_greater_than();
  }
}
inline ::uint64_t Fixed64Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.gte)
  return _internal_gte();
}
inline void Fixed64Rules::set_gte(::uint64_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.gte)
}
inline ::uint64_t Fixed64Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return ::uint64_t{0u};
}

// repeated fixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int Fixed64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Fixed64Rules::in_size() const {
  return _internal_in_size();
}
inline void Fixed64Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::uint64_t Fixed64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.in)
  return _internal_in().Get(index);
}
inline void Fixed64Rules::set_in(int index, ::uint64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.in)
}
inline void Fixed64Rules::add_in(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Fixed64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Fixed64Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Fixed64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Fixed64Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
Fixed64Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int Fixed64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Fixed64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Fixed64Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::uint64_t Fixed64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Fixed64Rules::set_not_in(int index, ::uint64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.not_in)
}
inline void Fixed64Rules::add_not_in(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Fixed64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Fixed64Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Fixed64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Fixed64Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
Fixed64Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated fixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
inline int Fixed64Rules::_internal_example_size() const {
  return _internal_example().size();
}
inline int Fixed64Rules::example_size() const {
  return _internal_example_size();
}
inline void Fixed64Rules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline ::uint64_t Fixed64Rules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.example)
  return _internal_example().Get(index);
}
inline void Fixed64Rules::set_example(int index, ::uint64_t value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.example)
}
inline void Fixed64Rules::add_example(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Fixed64Rules.example)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Fixed64Rules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Fixed64Rules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64Rules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Fixed64Rules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
Fixed64Rules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64Rules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool Fixed64Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void Fixed64Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool Fixed64Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void Fixed64Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline Fixed64Rules::LessThanCase Fixed64Rules::less_than_case() const {
  return Fixed64Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline Fixed64Rules::GreaterThanCase Fixed64Rules::greater_than_case() const {
  return Fixed64Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// SFixed32Rules

// optional sfixed32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool SFixed32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SFixed32Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SFixed32Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.const)
  return _internal_const_();
}
inline void SFixed32Rules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.const)
}
inline ::int32_t SFixed32Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void SFixed32Rules::_internal_set_const_(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// sfixed32 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool SFixed32Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void SFixed32Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void SFixed32Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t SFixed32Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.lt)
  return _internal_lt();
}
inline void SFixed32Rules::set_lt(::int32_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.lt)
}
inline ::int32_t SFixed32Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0;
}

// sfixed32 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool SFixed32Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void SFixed32Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void SFixed32Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t SFixed32Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.lte)
  return _internal_lte();
}
inline void SFixed32Rules::set_lte(::int32_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.lte)
}
inline ::int32_t SFixed32Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0;
}

// sfixed32 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool SFixed32Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void SFixed32Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void SFixed32Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t SFixed32Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.gt)
  return _internal_gt();
}
inline void SFixed32Rules::set_gt(::int32_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.gt)
}
inline ::int32_t SFixed32Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0;
}

// sfixed32 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool SFixed32Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void SFixed32Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void SFixed32Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t SFixed32Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.gte)
  return _internal_gte();
}
inline void SFixed32Rules::set_gte(::int32_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.gte)
}
inline ::int32_t SFixed32Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0;
}

// repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int SFixed32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SFixed32Rules::in_size() const {
  return _internal_in_size();
}
inline void SFixed32Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int32_t SFixed32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.in)
  return _internal_in().Get(index);
}
inline void SFixed32Rules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.in)
}
inline void SFixed32Rules::add_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SFixed32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SFixed32Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SFixed32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SFixed32Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SFixed32Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SFixed32Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SFixed32Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int SFixed32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SFixed32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SFixed32Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int32_t SFixed32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SFixed32Rules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.not_in)
}
inline void SFixed32Rules::add_not_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SFixed32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SFixed32Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SFixed32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SFixed32Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SFixed32Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SFixed32Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SFixed32Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated sfixed32 example = 8 [json_name = "example", (.buf.validate.predefined) = {
inline int SFixed32Rules::_internal_example_size() const {
  return _internal_example().size();
}
inline int SFixed32Rules::example_size() const {
  return _internal_example_size();
}
inline void SFixed32Rules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline ::int32_t SFixed32Rules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.example)
  return _internal_example().Get(index);
}
inline void SFixed32Rules::set_example(int index, ::int32_t value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.example)
}
inline void SFixed32Rules::add_example(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SFixed32Rules.example)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SFixed32Rules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SFixed32Rules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SFixed32Rules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SFixed32Rules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SFixed32Rules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SFixed32Rules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool SFixed32Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void SFixed32Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool SFixed32Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void SFixed32Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline SFixed32Rules::LessThanCase SFixed32Rules::less_than_case() const {
  return SFixed32Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline SFixed32Rules::GreaterThanCase SFixed32Rules::greater_than_case() const {
  return SFixed32Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// SFixed64Rules

// optional sfixed64 const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool SFixed64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SFixed64Rules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t SFixed64Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.const)
  return _internal_const_();
}
inline void SFixed64Rules::set_const_(::int64_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.const)
}
inline ::int64_t SFixed64Rules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void SFixed64Rules::_internal_set_const_(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// sfixed64 lt = 2 [json_name = "lt", (.buf.validate.predefined) = {
inline bool SFixed64Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void SFixed64Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void SFixed64Rules::clear_lt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t SFixed64Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.lt)
  return _internal_lt();
}
inline void SFixed64Rules::set_lt(::int64_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.lt)
}
inline ::int64_t SFixed64Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return ::int64_t{0};
}

// sfixed64 lte = 3 [json_name = "lte", (.buf.validate.predefined) = {
inline bool SFixed64Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void SFixed64Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void SFixed64Rules::clear_lte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t SFixed64Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.lte)
  return _internal_lte();
}
inline void SFixed64Rules::set_lte(::int64_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.lte)
}
inline ::int64_t SFixed64Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return ::int64_t{0};
}

// sfixed64 gt = 4 [json_name = "gt", (.buf.validate.predefined) = {
inline bool SFixed64Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void SFixed64Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void SFixed64Rules::clear_gt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t SFixed64Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.gt)
  return _internal_gt();
}
inline void SFixed64Rules::set_gt(::int64_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.gt)
}
inline ::int64_t SFixed64Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return ::int64_t{0};
}

// sfixed64 gte = 5 [json_name = "gte", (.buf.validate.predefined) = {
inline bool SFixed64Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void SFixed64Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void SFixed64Rules::clear_gte() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t SFixed64Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.gte)
  return _internal_gte();
}
inline void SFixed64Rules::set_gte(::int64_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.gte)
}
inline ::int64_t SFixed64Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return ::int64_t{0};
}

// repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.predefined) = {
inline int SFixed64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SFixed64Rules::in_size() const {
  return _internal_in_size();
}
inline void SFixed64Rules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int64_t SFixed64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.in)
  return _internal_in().Get(index);
}
inline void SFixed64Rules::set_in(int index, ::int64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.in)
}
inline void SFixed64Rules::add_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SFixed64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SFixed64Rules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SFixed64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* SFixed64Rules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SFixed64Rules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
SFixed64Rules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* SFixed64Rules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.predefined) = {
inline int SFixed64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SFixed64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SFixed64Rules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int64_t SFixed64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SFixed64Rules::set_not_in(int index, ::int64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.not_in)
}
inline void SFixed64Rules::add_not_in(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SFixed64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SFixed64Rules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SFixed64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* SFixed64Rules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SFixed64Rules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
SFixed64Rules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* SFixed64Rules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated sfixed64 example = 8 [json_name = "example", (.buf.validate.predefined) = {
inline int SFixed64Rules::_internal_example_size() const {
  return _internal_example().size();
}
inline int SFixed64Rules::example_size() const {
  return _internal_example_size();
}
inline void SFixed64Rules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline ::int64_t SFixed64Rules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.example)
  return _internal_example().Get(index);
}
inline void SFixed64Rules::set_example(int index, ::int64_t value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.example)
}
inline void SFixed64Rules::add_example(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SFixed64Rules.example)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SFixed64Rules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.SFixed64Rules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<::int64_t>* SFixed64Rules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SFixed64Rules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
SFixed64Rules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* SFixed64Rules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool SFixed64Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void SFixed64Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool SFixed64Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void SFixed64Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline SFixed64Rules::LessThanCase SFixed64Rules::less_than_case() const {
  return SFixed64Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline SFixed64Rules::GreaterThanCase SFixed64Rules::greater_than_case() const {
  return SFixed64Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// BoolRules

// optional bool const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool BoolRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BoolRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool BoolRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.BoolRules.const)
  return _internal_const_();
}
inline void BoolRules::set_const_(bool value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.BoolRules.const)
}
inline bool BoolRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void BoolRules::_internal_set_const_(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// repeated bool example = 2 [json_name = "example", (.buf.validate.predefined) = {
inline int BoolRules::_internal_example_size() const {
  return _internal_example().size();
}
inline int BoolRules::example_size() const {
  return _internal_example_size();
}
inline void BoolRules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline bool BoolRules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.BoolRules.example)
  return _internal_example().Get(index);
}
inline void BoolRules::set_example(int index, bool value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.BoolRules.example)
}
inline void BoolRules::add_example(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.BoolRules.example)
}
inline const ::google::protobuf::RepeatedField<bool>& BoolRules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.BoolRules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<bool>* BoolRules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.BoolRules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<bool>&
BoolRules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<bool>* BoolRules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

// -------------------------------------------------------------------

// StringRules

// optional string const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool StringRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StringRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StringRules::const_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.const)
  return _internal_const_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_const_(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.const)
}
inline std::string* StringRules::mutable_const_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.const)
  return _s;
}
inline const std::string& StringRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__.Get();
}
inline void StringRules::_internal_set_const_(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.Set(value, GetArena());
}
inline std::string* StringRules::_internal_mutable_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.const__.Mutable( GetArena());
}
inline std::string* StringRules::release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.const)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.const__.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.const__.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_const_(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.const__.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.const__.IsDefault()) {
          _impl_.const__.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.const)
}

// optional uint64 len = 19 [json_name = "len", (.buf.validate.predefined) = {
inline bool StringRules::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void StringRules::clear_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint64_t StringRules::len() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.len)
  return _internal_len();
}
inline void StringRules::set_len(::uint64_t value) {
  _internal_set_len(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.len)
}
inline ::uint64_t StringRules::_internal_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.len_;
}
inline void StringRules::_internal_set_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_ = value;
}

// optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
inline bool StringRules::has_min_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void StringRules::clear_min_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t StringRules::min_len() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.min_len)
  return _internal_min_len();
}
inline void StringRules::set_min_len(::uint64_t value) {
  _internal_set_min_len(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.min_len)
}
inline ::uint64_t StringRules::_internal_min_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_len_;
}
inline void StringRules::_internal_set_min_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_len_ = value;
}

// optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
inline bool StringRules::has_max_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void StringRules::clear_max_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t StringRules::max_len() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.max_len)
  return _internal_max_len();
}
inline void StringRules::set_max_len(::uint64_t value) {
  _internal_set_max_len(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.max_len)
}
inline ::uint64_t StringRules::_internal_max_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_len_;
}
inline void StringRules::_internal_set_max_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_len_ = value;
}

// optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.predefined) = {
inline bool StringRules::has_len_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void StringRules::clear_len_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint64_t StringRules::len_bytes() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.len_bytes)
  return _internal_len_bytes();
}
inline void StringRules::set_len_bytes(::uint64_t value) {
  _internal_set_len_bytes(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.len_bytes)
}
inline ::uint64_t StringRules::_internal_len_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.len_bytes_;
}
inline void StringRules::_internal_set_len_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_bytes_ = value;
}

// optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.predefined) = {
inline bool StringRules::has_min_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void StringRules::clear_min_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint64_t StringRules::min_bytes() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.min_bytes)
  return _internal_min_bytes();
}
inline void StringRules::set_min_bytes(::uint64_t value) {
  _internal_set_min_bytes(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.min_bytes)
}
inline ::uint64_t StringRules::_internal_min_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_bytes_;
}
inline void StringRules::_internal_set_min_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_bytes_ = value;
}

// optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.predefined) = {
inline bool StringRules::has_max_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void StringRules::clear_max_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint64_t StringRules::max_bytes() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.max_bytes)
  return _internal_max_bytes();
}
inline void StringRules::set_max_bytes(::uint64_t value) {
  _internal_set_max_bytes(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.max_bytes)
}
inline ::uint64_t StringRules::_internal_max_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_bytes_;
}
inline void StringRules::_internal_set_max_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_bytes_ = value;
}

// optional string pattern = 6 [json_name = "pattern", (.buf.validate.predefined) = {
inline bool StringRules::has_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StringRules::clear_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StringRules::pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.pattern)
  return _internal_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_pattern(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.pattern)
}
inline std::string* StringRules::mutable_pattern() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.pattern)
  return _s;
}
inline const std::string& StringRules::_internal_pattern() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pattern_.Get();
}
inline void StringRules::_internal_set_pattern(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(value, GetArena());
}
inline std::string* StringRules::_internal_mutable_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pattern_.Mutable( GetArena());
}
inline std::string* StringRules::release_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.pattern)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.pattern_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pattern_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_pattern(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pattern_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pattern_.IsDefault()) {
          _impl_.pattern_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.pattern)
}

// optional string prefix = 7 [json_name = "prefix", (.buf.validate.predefined) = {
inline bool StringRules::has_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StringRules::clear_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StringRules::prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_prefix(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.prefix)
}
inline std::string* StringRules::mutable_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.prefix)
  return _s;
}
inline const std::string& StringRules::_internal_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefix_.Get();
}
inline void StringRules::_internal_set_prefix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.Set(value, GetArena());
}
inline std::string* StringRules::_internal_mutable_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.prefix_.Mutable( GetArena());
}
inline std::string* StringRules::release_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.prefix)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.prefix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.prefix_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_prefix(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.prefix_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.prefix_.IsDefault()) {
          _impl_.prefix_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.prefix)
}

// optional string suffix = 8 [json_name = "suffix", (.buf.validate.predefined) = {
inline bool StringRules::has_suffix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void StringRules::clear_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suffix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StringRules::suffix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.suffix)
  return _internal_suffix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_suffix(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.suffix)
}
inline std::string* StringRules::mutable_suffix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_suffix();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.suffix)
  return _s;
}
inline const std::string& StringRules::_internal_suffix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.suffix_.Get();
}
inline void StringRules::_internal_set_suffix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.Set(value, GetArena());
}
inline std::string* StringRules::_internal_mutable_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.suffix_.Mutable( GetArena());
}
inline std::string* StringRules::release_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.suffix)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.suffix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.suffix_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_suffix(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.suffix_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.suffix_.IsDefault()) {
          _impl_.suffix_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.suffix)
}

// optional string contains = 9 [json_name = "contains", (.buf.validate.predefined) = {
inline bool StringRules::has_contains() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void StringRules::clear_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& StringRules::contains() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.contains)
  return _internal_contains();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_contains(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.contains)
}
inline std::string* StringRules::mutable_contains() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contains();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.contains)
  return _s;
}
inline const std::string& StringRules::_internal_contains() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contains_.Get();
}
inline void StringRules::_internal_set_contains(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.Set(value, GetArena());
}
inline std::string* StringRules::_internal_mutable_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.contains_.Mutable( GetArena());
}
inline std::string* StringRules::release_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.contains)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.contains_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contains_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_contains(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.contains_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contains_.IsDefault()) {
          _impl_.contains_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.contains)
}

// optional string not_contains = 23 [json_name = "notContains", (.buf.validate.predefined) = {
inline bool StringRules::has_not_contains() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void StringRules::clear_not_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_contains_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& StringRules::not_contains() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.not_contains)
  return _internal_not_contains();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_not_contains(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.not_contains_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.not_contains)
}
inline std::string* StringRules::mutable_not_contains() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_not_contains();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.not_contains)
  return _s;
}
inline const std::string& StringRules::_internal_not_contains() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_contains_.Get();
}
inline void StringRules::_internal_set_not_contains(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.not_contains_.Set(value, GetArena());
}
inline std::string* StringRules::_internal_mutable_not_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.not_contains_.Mutable( GetArena());
}
inline std::string* StringRules::release_not_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.not_contains)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.not_contains_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.not_contains_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_not_contains(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.not_contains_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.not_contains_.IsDefault()) {
          _impl_.not_contains_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.not_contains)
}

// repeated string in = 10 [json_name = "in", (.buf.validate.predefined) = {
inline int StringRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int StringRules::in_size() const {
  return _internal_in_size();
}
inline void StringRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline std::string* StringRules::add_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.StringRules.in)
  return _s;
}
inline const std::string& StringRules::in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.in)
  return _internal_in().Get(index);
}
inline std::string* StringRules::mutable_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.in)
  return _internal_mutable_in()->Mutable(index);
}
inline void StringRules::set_in(int index, const std::string& value) {
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.in)
}
inline void StringRules::set_in(int index, std::string&& value) {
  _internal_mutable_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.in)
}
inline void StringRules::set_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.StringRules.in)
}
inline void StringRules::set_in(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.StringRules.in)
}
inline void StringRules::set_in(int index, absl::string_view value) {
  _internal_mutable_in()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.StringRules.in)
}
inline void StringRules::add_in(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.StringRules.in)
}
inline void StringRules::add_in(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.StringRules.in)
}
inline void StringRules::add_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.StringRules.in)
}
inline void StringRules::add_in(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.StringRules.in)
}
inline void StringRules::add_in(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.StringRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringRules::in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.StringRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringRules::mutable_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.StringRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated string not_in = 11 [json_name = "notIn", (.buf.validate.predefined) = {
inline int StringRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int StringRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void StringRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline std::string* StringRules::add_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.StringRules.not_in)
  return _s;
}
inline const std::string& StringRules::not_in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.not_in)
  return _internal_not_in().Get(index);
}
inline std::string* StringRules::mutable_not_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
inline void StringRules::set_not_in(int index, const std::string& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.not_in)
}
inline void StringRules::set_not_in(int index, std::string&& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.not_in)
}
inline void StringRules::set_not_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.StringRules.not_in)
}
inline void StringRules::set_not_in(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_not_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.StringRules.not_in)
}
inline void StringRules::set_not_in(int index, absl::string_view value) {
  _internal_mutable_not_in()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.StringRules.not_in)
}
inline void StringRules::add_not_in(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.StringRules.not_in)
}
inline void StringRules::add_not_in(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.StringRules.not_in)
}
inline void StringRules::add_not_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.StringRules.not_in)
}
inline void StringRules::add_not_in(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.StringRules.not_in)
}
inline void StringRules::add_not_in(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.StringRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringRules::not_in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.StringRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringRules::mutable_not_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.StringRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// bool email = 12 [json_name = "email", (.buf.validate.predefined) = {
inline bool StringRules::has_email() const {
  return well_known_case() == kEmail;
}
inline void StringRules::set_has_email() {
  _impl_._oneof_case_[0] = kEmail;
}
inline void StringRules::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kEmail) {
    _impl_.well_known_.email_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::email() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.email)
  return _internal_email();
}
inline void StringRules::set_email(bool value) {
  if (well_known_case() != kEmail) {
    clear_well_known();
    set_has_email();
  }
  _impl_.well_known_.email_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.email)
}
inline bool StringRules::_internal_email() const {
  if (well_known_case() == kEmail) {
    return _impl_.well_known_.email_;
  }
  return false;
}

// bool hostname = 13 [json_name = "hostname", (.buf.validate.predefined) = {
inline bool StringRules::has_hostname() const {
  return well_known_case() == kHostname;
}
inline void StringRules::set_has_hostname() {
  _impl_._oneof_case_[0] = kHostname;
}
inline void StringRules::clear_hostname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kHostname) {
    _impl_.well_known_.hostname_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::hostname() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.hostname)
  return _internal_hostname();
}
inline void StringRules::set_hostname(bool value) {
  if (well_known_case() != kHostname) {
    clear_well_known();
    set_has_hostname();
  }
  _impl_.well_known_.hostname_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.hostname)
}
inline bool StringRules::_internal_hostname() const {
  if (well_known_case() == kHostname) {
    return _impl_.well_known_.hostname_;
  }
  return false;
}

// bool ip = 14 [json_name = "ip", (.buf.validate.predefined) = {
inline bool StringRules::has_ip() const {
  return well_known_case() == kIp;
}
inline void StringRules::set_has_ip() {
  _impl_._oneof_case_[0] = kIp;
}
inline void StringRules::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIp) {
    _impl_.well_known_.ip_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ip() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ip)
  return _internal_ip();
}
inline void StringRules::set_ip(bool value) {
  if (well_known_case() != kIp) {
    clear_well_known();
    set_has_ip();
  }
  _impl_.well_known_.ip_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ip)
}
inline bool StringRules::_internal_ip() const {
  if (well_known_case() == kIp) {
    return _impl_.well_known_.ip_;
  }
  return false;
}

// bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.predefined) = {
inline bool StringRules::has_ipv4() const {
  return well_known_case() == kIpv4;
}
inline void StringRules::set_has_ipv4() {
  _impl_._oneof_case_[0] = kIpv4;
}
inline void StringRules::clear_ipv4() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv4) {
    _impl_.well_known_.ipv4_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv4() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ipv4)
  return _internal_ipv4();
}
inline void StringRules::set_ipv4(bool value) {
  if (well_known_case() != kIpv4) {
    clear_well_known();
    set_has_ipv4();
  }
  _impl_.well_known_.ipv4_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ipv4)
}
inline bool StringRules::_internal_ipv4() const {
  if (well_known_case() == kIpv4) {
    return _impl_.well_known_.ipv4_;
  }
  return false;
}

// bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.predefined) = {
inline bool StringRules::has_ipv6() const {
  return well_known_case() == kIpv6;
}
inline void StringRules::set_has_ipv6() {
  _impl_._oneof_case_[0] = kIpv6;
}
inline void StringRules::clear_ipv6() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv6) {
    _impl_.well_known_.ipv6_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv6() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ipv6)
  return _internal_ipv6();
}
inline void StringRules::set_ipv6(bool value) {
  if (well_known_case() != kIpv6) {
    clear_well_known();
    set_has_ipv6();
  }
  _impl_.well_known_.ipv6_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ipv6)
}
inline bool StringRules::_internal_ipv6() const {
  if (well_known_case() == kIpv6) {
    return _impl_.well_known_.ipv6_;
  }
  return false;
}

// bool uri = 17 [json_name = "uri", (.buf.validate.predefined) = {
inline bool StringRules::has_uri() const {
  return well_known_case() == kUri;
}
inline void StringRules::set_has_uri() {
  _impl_._oneof_case_[0] = kUri;
}
inline void StringRules::clear_uri() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kUri) {
    _impl_.well_known_.uri_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uri() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.uri)
  return _internal_uri();
}
inline void StringRules::set_uri(bool value) {
  if (well_known_case() != kUri) {
    clear_well_known();
    set_has_uri();
  }
  _impl_.well_known_.uri_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.uri)
}
inline bool StringRules::_internal_uri() const {
  if (well_known_case() == kUri) {
    return _impl_.well_known_.uri_;
  }
  return false;
}

// bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.predefined) = {
inline bool StringRules::has_uri_ref() const {
  return well_known_case() == kUriRef;
}
inline void StringRules::set_has_uri_ref() {
  _impl_._oneof_case_[0] = kUriRef;
}
inline void StringRules::clear_uri_ref() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kUriRef) {
    _impl_.well_known_.uri_ref_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uri_ref() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.uri_ref)
  return _internal_uri_ref();
}
inline void StringRules::set_uri_ref(bool value) {
  if (well_known_case() != kUriRef) {
    clear_well_known();
    set_has_uri_ref();
  }
  _impl_.well_known_.uri_ref_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.uri_ref)
}
inline bool StringRules::_internal_uri_ref() const {
  if (well_known_case() == kUriRef) {
    return _impl_.well_known_.uri_ref_;
  }
  return false;
}

// bool address = 21 [json_name = "address", (.buf.validate.predefined) = {
inline bool StringRules::has_address() const {
  return well_known_case() == kAddress;
}
inline void StringRules::set_has_address() {
  _impl_._oneof_case_[0] = kAddress;
}
inline void StringRules::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kAddress) {
    _impl_.well_known_.address_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::address() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.address)
  return _internal_address();
}
inline void StringRules::set_address(bool value) {
  if (well_known_case() != kAddress) {
    clear_well_known();
    set_has_address();
  }
  _impl_.well_known_.address_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.address)
}
inline bool StringRules::_internal_address() const {
  if (well_known_case() == kAddress) {
    return _impl_.well_known_.address_;
  }
  return false;
}

// bool uuid = 22 [json_name = "uuid", (.buf.validate.predefined) = {
inline bool StringRules::has_uuid() const {
  return well_known_case() == kUuid;
}
inline void StringRules::set_has_uuid() {
  _impl_._oneof_case_[0] = kUuid;
}
inline void StringRules::clear_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kUuid) {
    _impl_.well_known_.uuid_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uuid() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.uuid)
  return _internal_uuid();
}
inline void StringRules::set_uuid(bool value) {
  if (well_known_case() != kUuid) {
    clear_well_known();
    set_has_uuid();
  }
  _impl_.well_known_.uuid_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.uuid)
}
inline bool StringRules::_internal_uuid() const {
  if (well_known_case() == kUuid) {
    return _impl_.well_known_.uuid_;
  }
  return false;
}

// bool tuuid = 33 [json_name = "tuuid", (.buf.validate.predefined) = {
inline bool StringRules::has_tuuid() const {
  return well_known_case() == kTuuid;
}
inline void StringRules::set_has_tuuid() {
  _impl_._oneof_case_[0] = kTuuid;
}
inline void StringRules::clear_tuuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kTuuid) {
    _impl_.well_known_.tuuid_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::tuuid() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.tuuid)
  return _internal_tuuid();
}
inline void StringRules::set_tuuid(bool value) {
  if (well_known_case() != kTuuid) {
    clear_well_known();
    set_has_tuuid();
  }
  _impl_.well_known_.tuuid_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.tuuid)
}
inline bool StringRules::_internal_tuuid() const {
  if (well_known_case() == kTuuid) {
    return _impl_.well_known_.tuuid_;
  }
  return false;
}

// bool ip_with_prefixlen = 26 [json_name = "ipWithPrefixlen", (.buf.validate.predefined) = {
inline bool StringRules::has_ip_with_prefixlen() const {
  return well_known_case() == kIpWithPrefixlen;
}
inline void StringRules::set_has_ip_with_prefixlen() {
  _impl_._oneof_case_[0] = kIpWithPrefixlen;
}
inline void StringRules::clear_ip_with_prefixlen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpWithPrefixlen) {
    _impl_.well_known_.ip_with_prefixlen_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ip_with_prefixlen() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ip_with_prefixlen)
  return _internal_ip_with_prefixlen();
}
inline void StringRules::set_ip_with_prefixlen(bool value) {
  if (well_known_case() != kIpWithPrefixlen) {
    clear_well_known();
    set_has_ip_with_prefixlen();
  }
  _impl_.well_known_.ip_with_prefixlen_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ip_with_prefixlen)
}
inline bool StringRules::_internal_ip_with_prefixlen() const {
  if (well_known_case() == kIpWithPrefixlen) {
    return _impl_.well_known_.ip_with_prefixlen_;
  }
  return false;
}

// bool ipv4_with_prefixlen = 27 [json_name = "ipv4WithPrefixlen", (.buf.validate.predefined) = {
inline bool StringRules::has_ipv4_with_prefixlen() const {
  return well_known_case() == kIpv4WithPrefixlen;
}
inline void StringRules::set_has_ipv4_with_prefixlen() {
  _impl_._oneof_case_[0] = kIpv4WithPrefixlen;
}
inline void StringRules::clear_ipv4_with_prefixlen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv4WithPrefixlen) {
    _impl_.well_known_.ipv4_with_prefixlen_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv4_with_prefixlen() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ipv4_with_prefixlen)
  return _internal_ipv4_with_prefixlen();
}
inline void StringRules::set_ipv4_with_prefixlen(bool value) {
  if (well_known_case() != kIpv4WithPrefixlen) {
    clear_well_known();
    set_has_ipv4_with_prefixlen();
  }
  _impl_.well_known_.ipv4_with_prefixlen_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ipv4_with_prefixlen)
}
inline bool StringRules::_internal_ipv4_with_prefixlen() const {
  if (well_known_case() == kIpv4WithPrefixlen) {
    return _impl_.well_known_.ipv4_with_prefixlen_;
  }
  return false;
}

// bool ipv6_with_prefixlen = 28 [json_name = "ipv6WithPrefixlen", (.buf.validate.predefined) = {
inline bool StringRules::has_ipv6_with_prefixlen() const {
  return well_known_case() == kIpv6WithPrefixlen;
}
inline void StringRules::set_has_ipv6_with_prefixlen() {
  _impl_._oneof_case_[0] = kIpv6WithPrefixlen;
}
inline void StringRules::clear_ipv6_with_prefixlen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv6WithPrefixlen) {
    _impl_.well_known_.ipv6_with_prefixlen_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv6_with_prefixlen() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ipv6_with_prefixlen)
  return _internal_ipv6_with_prefixlen();
}
inline void StringRules::set_ipv6_with_prefixlen(bool value) {
  if (well_known_case() != kIpv6WithPrefixlen) {
    clear_well_known();
    set_has_ipv6_with_prefixlen();
  }
  _impl_.well_known_.ipv6_with_prefixlen_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ipv6_with_prefixlen)
}
inline bool StringRules::_internal_ipv6_with_prefixlen() const {
  if (well_known_case() == kIpv6WithPrefixlen) {
    return _impl_.well_known_.ipv6_with_prefixlen_;
  }
  return false;
}

// bool ip_prefix = 29 [json_name = "ipPrefix", (.buf.validate.predefined) = {
inline bool StringRules::has_ip_prefix() const {
  return well_known_case() == kIpPrefix;
}
inline void StringRules::set_has_ip_prefix() {
  _impl_._oneof_case_[0] = kIpPrefix;
}
inline void StringRules::clear_ip_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpPrefix) {
    _impl_.well_known_.ip_prefix_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ip_prefix() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ip_prefix)
  return _internal_ip_prefix();
}
inline void StringRules::set_ip_prefix(bool value) {
  if (well_known_case() != kIpPrefix) {
    clear_well_known();
    set_has_ip_prefix();
  }
  _impl_.well_known_.ip_prefix_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ip_prefix)
}
inline bool StringRules::_internal_ip_prefix() const {
  if (well_known_case() == kIpPrefix) {
    return _impl_.well_known_.ip_prefix_;
  }
  return false;
}

// bool ipv4_prefix = 30 [json_name = "ipv4Prefix", (.buf.validate.predefined) = {
inline bool StringRules::has_ipv4_prefix() const {
  return well_known_case() == kIpv4Prefix;
}
inline void StringRules::set_has_ipv4_prefix() {
  _impl_._oneof_case_[0] = kIpv4Prefix;
}
inline void StringRules::clear_ipv4_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv4Prefix) {
    _impl_.well_known_.ipv4_prefix_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv4_prefix() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ipv4_prefix)
  return _internal_ipv4_prefix();
}
inline void StringRules::set_ipv4_prefix(bool value) {
  if (well_known_case() != kIpv4Prefix) {
    clear_well_known();
    set_has_ipv4_prefix();
  }
  _impl_.well_known_.ipv4_prefix_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ipv4_prefix)
}
inline bool StringRules::_internal_ipv4_prefix() const {
  if (well_known_case() == kIpv4Prefix) {
    return _impl_.well_known_.ipv4_prefix_;
  }
  return false;
}

// bool ipv6_prefix = 31 [json_name = "ipv6Prefix", (.buf.validate.predefined) = {
inline bool StringRules::has_ipv6_prefix() const {
  return well_known_case() == kIpv6Prefix;
}
inline void StringRules::set_has_ipv6_prefix() {
  _impl_._oneof_case_[0] = kIpv6Prefix;
}
inline void StringRules::clear_ipv6_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv6Prefix) {
    _impl_.well_known_.ipv6_prefix_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv6_prefix() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ipv6_prefix)
  return _internal_ipv6_prefix();
}
inline void StringRules::set_ipv6_prefix(bool value) {
  if (well_known_case() != kIpv6Prefix) {
    clear_well_known();
    set_has_ipv6_prefix();
  }
  _impl_.well_known_.ipv6_prefix_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ipv6_prefix)
}
inline bool StringRules::_internal_ipv6_prefix() const {
  if (well_known_case() == kIpv6Prefix) {
    return _impl_.well_known_.ipv6_prefix_;
  }
  return false;
}

// bool host_and_port = 32 [json_name = "hostAndPort", (.buf.validate.predefined) = {
inline bool StringRules::has_host_and_port() const {
  return well_known_case() == kHostAndPort;
}
inline void StringRules::set_has_host_and_port() {
  _impl_._oneof_case_[0] = kHostAndPort;
}
inline void StringRules::clear_host_and_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kHostAndPort) {
    _impl_.well_known_.host_and_port_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::host_and_port() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.host_and_port)
  return _internal_host_and_port();
}
inline void StringRules::set_host_and_port(bool value) {
  if (well_known_case() != kHostAndPort) {
    clear_well_known();
    set_has_host_and_port();
  }
  _impl_.well_known_.host_and_port_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.host_and_port)
}
inline bool StringRules::_internal_host_and_port() const {
  if (well_known_case() == kHostAndPort) {
    return _impl_.well_known_.host_and_port_;
  }
  return false;
}

// .buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.predefined) = {
inline bool StringRules::has_well_known_regex() const {
  return well_known_case() == kWellKnownRegex;
}
inline void StringRules::set_has_well_known_regex() {
  _impl_._oneof_case_[0] = kWellKnownRegex;
}
inline void StringRules::clear_well_known_regex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kWellKnownRegex) {
    _impl_.well_known_.well_known_regex_ = 0;
    clear_has_well_known();
  }
}
inline ::buf::validate::KnownRegex StringRules::well_known_regex() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.well_known_regex)
  return _internal_well_known_regex();
}
inline void StringRules::set_well_known_regex(::buf::validate::KnownRegex value) {
  assert(::buf::validate::KnownRegex_IsValid(value));
  if (well_known_case() != kWellKnownRegex) {
    clear_well_known();
    set_has_well_known_regex();
  }
  _impl_.well_known_.well_known_regex_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.well_known_regex)
}
inline ::buf::validate::KnownRegex StringRules::_internal_well_known_regex() const {
  if (well_known_case() == kWellKnownRegex) {
    return static_cast<::buf::validate::KnownRegex>(_impl_.well_known_.well_known_regex_);
  }
  return static_cast<::buf::validate::KnownRegex>(0);
}

// optional bool strict = 25 [json_name = "strict"];
inline bool StringRules::has_strict() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void StringRules::clear_strict() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strict_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool StringRules::strict() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.strict)
  return _internal_strict();
}
inline void StringRules::set_strict(bool value) {
  _internal_set_strict(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.strict)
}
inline bool StringRules::_internal_strict() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.strict_;
}
inline void StringRules::_internal_set_strict(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.strict_ = value;
}

// repeated string example = 34 [json_name = "example", (.buf.validate.predefined) = {
inline int StringRules::_internal_example_size() const {
  return _internal_example().size();
}
inline int StringRules::example_size() const {
  return _internal_example_size();
}
inline void StringRules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline std::string* StringRules::add_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_example()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.StringRules.example)
  return _s;
}
inline const std::string& StringRules::example(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.example)
  return _internal_example().Get(index);
}
inline std::string* StringRules::mutable_example(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.example)
  return _internal_mutable_example()->Mutable(index);
}
inline void StringRules::set_example(int index, const std::string& value) {
  _internal_mutable_example()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.example)
}
inline void StringRules::set_example(int index, std::string&& value) {
  _internal_mutable_example()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.example)
}
inline void StringRules::set_example(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_example()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.StringRules.example)
}
inline void StringRules::set_example(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_example()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.StringRules.example)
}
inline void StringRules::set_example(int index, absl::string_view value) {
  _internal_mutable_example()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.StringRules.example)
}
inline void StringRules::add_example(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.StringRules.example)
}
inline void StringRules::add_example(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.StringRules.example)
}
inline void StringRules::add_example(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.StringRules.example)
}
inline void StringRules::add_example(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.StringRules.example)
}
inline void StringRules::add_example(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.StringRules.example)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringRules::example() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.StringRules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringRules::mutable_example() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.StringRules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringRules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringRules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool StringRules::has_well_known() const {
  return well_known_case() != WELL_KNOWN_NOT_SET;
}
inline void StringRules::clear_has_well_known() {
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}
inline StringRules::WellKnownCase StringRules::well_known_case() const {
  return StringRules::WellKnownCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BytesRules

// optional bytes const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool BytesRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BytesRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BytesRules::const_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.const)
  return _internal_const_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BytesRules::set_const_(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.const)
}
inline std::string* BytesRules::mutable_const_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.const)
  return _s;
}
inline const std::string& BytesRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__.Get();
}
inline void BytesRules::_internal_set_const_(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.Set(value, GetArena());
}
inline std::string* BytesRules::_internal_mutable_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.const__.Mutable( GetArena());
}
inline std::string* BytesRules::release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.BytesRules.const)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.const__.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.const__.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BytesRules::set_allocated_const_(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.const__.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.const__.IsDefault()) {
          _impl_.const__.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.BytesRules.const)
}

// optional uint64 len = 13 [json_name = "len", (.buf.validate.predefined) = {
inline bool BytesRules::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void BytesRules::clear_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t BytesRules::len() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.len)
  return _internal_len();
}
inline void BytesRules::set_len(::uint64_t value) {
  _internal_set_len(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.len)
}
inline ::uint64_t BytesRules::_internal_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.len_;
}
inline void BytesRules::_internal_set_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.len_ = value;
}

// optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = {
inline bool BytesRules::has_min_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BytesRules::clear_min_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t BytesRules::min_len() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.min_len)
  return _internal_min_len();
}
inline void BytesRules::set_min_len(::uint64_t value) {
  _internal_set_min_len(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.min_len)
}
inline ::uint64_t BytesRules::_internal_min_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_len_;
}
inline void BytesRules::_internal_set_min_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_len_ = value;
}

// optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = {
inline bool BytesRules::has_max_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BytesRules::clear_max_len() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t BytesRules::max_len() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.max_len)
  return _internal_max_len();
}
inline void BytesRules::set_max_len(::uint64_t value) {
  _internal_set_max_len(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.max_len)
}
inline ::uint64_t BytesRules::_internal_max_len() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_len_;
}
inline void BytesRules::_internal_set_max_len(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_len_ = value;
}

// optional string pattern = 4 [json_name = "pattern", (.buf.validate.predefined) = {
inline bool BytesRules::has_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BytesRules::clear_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BytesRules::pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.pattern)
  return _internal_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BytesRules::set_pattern(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.pattern)
}
inline std::string* BytesRules::mutable_pattern() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.pattern)
  return _s;
}
inline const std::string& BytesRules::_internal_pattern() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pattern_.Get();
}
inline void BytesRules::_internal_set_pattern(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(value, GetArena());
}
inline std::string* BytesRules::_internal_mutable_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pattern_.Mutable( GetArena());
}
inline std::string* BytesRules::release_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.BytesRules.pattern)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.pattern_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pattern_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BytesRules::set_allocated_pattern(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pattern_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pattern_.IsDefault()) {
          _impl_.pattern_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.BytesRules.pattern)
}

// optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.predefined) = {
inline bool BytesRules::has_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BytesRules::clear_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BytesRules::prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BytesRules::set_prefix(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.prefix)
}
inline std::string* BytesRules::mutable_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.prefix)
  return _s;
}
inline const std::string& BytesRules::_internal_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefix_.Get();
}
inline void BytesRules::_internal_set_prefix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.Set(value, GetArena());
}
inline std::string* BytesRules::_internal_mutable_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.prefix_.Mutable( GetArena());
}
inline std::string* BytesRules::release_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.BytesRules.prefix)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.prefix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.prefix_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BytesRules::set_allocated_prefix(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.prefix_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.prefix_.IsDefault()) {
          _impl_.prefix_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.BytesRules.prefix)
}

// optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.predefined) = {
inline bool BytesRules::has_suffix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BytesRules::clear_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suffix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BytesRules::suffix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.suffix)
  return _internal_suffix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BytesRules::set_suffix(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.suffix)
}
inline std::string* BytesRules::mutable_suffix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_suffix();
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.suffix)
  return _s;
}
inline const std::string& BytesRules::_internal_suffix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.suffix_.Get();
}
inline void BytesRules::_internal_set_suffix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.Set(value, GetArena());
}
inline std::string* BytesRules::_internal_mutable_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.suffix_.Mutable( GetArena());
}
inline std::string* BytesRules::release_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.BytesRules.suffix)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.suffix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.suffix_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BytesRules::set_allocated_suffix(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.suffix_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.suffix_.IsDefault()) {
          _impl_.suffix_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.BytesRules.suffix)
}

// optional bytes contains = 7 [json_name = "contains", (.buf.validate.predefined) = {
inline bool BytesRules::has_contains() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BytesRules::clear_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contains_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& BytesRules::contains() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.contains)
  return _internal_contains();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BytesRules::set_contains(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.contains)
}
inline std::string* BytesRules::mutable_contains() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contains();
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.contains)
  return _s;
}
inline const std::string& BytesRules::_internal_contains() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contains_.Get();
}
inline void BytesRules::_internal_set_contains(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.Set(value, GetArena());
}
inline std::string* BytesRules::_internal_mutable_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.contains_.Mutable( GetArena());
}
inline std::string* BytesRules::release_contains() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.BytesRules.contains)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.contains_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contains_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BytesRules::set_allocated_contains(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.contains_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contains_.IsDefault()) {
          _impl_.contains_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.BytesRules.contains)
}

// repeated bytes in = 8 [json_name = "in", (.buf.validate.predefined) = {
inline int BytesRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int BytesRules::in_size() const {
  return _internal_in_size();
}
inline void BytesRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline std::string* BytesRules::add_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.BytesRules.in)
  return _s;
}
inline const std::string& BytesRules::in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.in)
  return _internal_in().Get(index);
}
inline std::string* BytesRules::mutable_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.in)
  return _internal_mutable_in()->Mutable(index);
}
inline void BytesRules::set_in(int index, const std::string& value) {
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.in)
}
inline void BytesRules::set_in(int index, std::string&& value) {
  _internal_mutable_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.in)
}
inline void BytesRules::set_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.BytesRules.in)
}
inline void BytesRules::set_in(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.BytesRules.in)
}
inline void BytesRules::set_in(int index, absl::string_view value) {
  _internal_mutable_in()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.BytesRules.in)
}
inline void BytesRules::add_in(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.BytesRules.in)
}
inline void BytesRules::add_in(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.BytesRules.in)
}
inline void BytesRules::add_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.BytesRules.in)
}
inline void BytesRules::add_in(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.BytesRules.in)
}
inline void BytesRules::add_in(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.BytesRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesRules::in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.BytesRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesRules::mutable_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.BytesRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.predefined) = {
inline int BytesRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int BytesRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void BytesRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline std::string* BytesRules::add_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.BytesRules.not_in)
  return _s;
}
inline const std::string& BytesRules::not_in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.not_in)
  return _internal_not_in().Get(index);
}
inline std::string* BytesRules::mutable_not_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
inline void BytesRules::set_not_in(int index, const std::string& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.not_in)
}
inline void BytesRules::set_not_in(int index, std::string&& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.not_in)
}
inline void BytesRules::set_not_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.BytesRules.not_in)
}
inline void BytesRules::set_not_in(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_not_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.BytesRules.not_in)
}
inline void BytesRules::set_not_in(int index, absl::string_view value) {
  _internal_mutable_not_in()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.BytesRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesRules::not_in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.BytesRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesRules::mutable_not_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.BytesRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// bool ip = 10 [json_name = "ip", (.buf.validate.predefined) = {
inline bool BytesRules::has_ip() const {
  return well_known_case() == kIp;
}
inline void BytesRules::set_has_ip() {
  _impl_._oneof_case_[0] = kIp;
}
inline void BytesRules::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIp) {
    _impl_.well_known_.ip_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ip() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.ip)
  return _internal_ip();
}
inline void BytesRules::set_ip(bool value) {
  if (well_known_case() != kIp) {
    clear_well_known();
    set_has_ip();
  }
  _impl_.well_known_.ip_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.ip)
}
inline bool BytesRules::_internal_ip() const {
  if (well_known_case() == kIp) {
    return _impl_.well_known_.ip_;
  }
  return false;
}

// bool ipv4 = 11 [json_name = "ipv4", (.buf.validate.predefined) = {
inline bool BytesRules::has_ipv4() const {
  return well_known_case() == kIpv4;
}
inline void BytesRules::set_has_ipv4() {
  _impl_._oneof_case_[0] = kIpv4;
}
inline void BytesRules::clear_ipv4() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv4) {
    _impl_.well_known_.ipv4_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ipv4() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.ipv4)
  return _internal_ipv4();
}
inline void BytesRules::set_ipv4(bool value) {
  if (well_known_case() != kIpv4) {
    clear_well_known();
    set_has_ipv4();
  }
  _impl_.well_known_.ipv4_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.ipv4)
}
inline bool BytesRules::_internal_ipv4() const {
  if (well_known_case() == kIpv4) {
    return _impl_.well_known_.ipv4_;
  }
  return false;
}

// bool ipv6 = 12 [json_name = "ipv6", (.buf.validate.predefined) = {
inline bool BytesRules::has_ipv6() const {
  return well_known_case() == kIpv6;
}
inline void BytesRules::set_has_ipv6() {
  _impl_._oneof_case_[0] = kIpv6;
}
inline void BytesRules::clear_ipv6() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (well_known_case() == kIpv6) {
    _impl_.well_known_.ipv6_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ipv6() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.ipv6)
  return _internal_ipv6();
}
inline void BytesRules::set_ipv6(bool value) {
  if (well_known_case() != kIpv6) {
    clear_well_known();
    set_has_ipv6();
  }
  _impl_.well_known_.ipv6_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.ipv6)
}
inline bool BytesRules::_internal_ipv6() const {
  if (well_known_case() == kIpv6) {
    return _impl_.well_known_.ipv6_;
  }
  return false;
}

// repeated bytes example = 14 [json_name = "example", (.buf.validate.predefined) = {
inline int BytesRules::_internal_example_size() const {
  return _internal_example().size();
}
inline int BytesRules::example_size() const {
  return _internal_example_size();
}
inline void BytesRules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline std::string* BytesRules::add_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_example()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.BytesRules.example)
  return _s;
}
inline const std::string& BytesRules::example(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.example)
  return _internal_example().Get(index);
}
inline std::string* BytesRules::mutable_example(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.example)
  return _internal_mutable_example()->Mutable(index);
}
inline void BytesRules::set_example(int index, const std::string& value) {
  _internal_mutable_example()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.example)
}
inline void BytesRules::set_example(int index, std::string&& value) {
  _internal_mutable_example()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.example)
}
inline void BytesRules::set_example(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_example()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.BytesRules.example)
}
inline void BytesRules::set_example(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_example()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.BytesRules.example)
}
inline void BytesRules::set_example(int index, absl::string_view value) {
  _internal_mutable_example()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.BytesRules.example)
}
inline void BytesRules::add_example(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.BytesRules.example)
}
inline void BytesRules::add_example(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.BytesRules.example)
}
inline void BytesRules::add_example(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.BytesRules.example)
}
inline void BytesRules::add_example(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.BytesRules.example)
}
inline void BytesRules::add_example(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.BytesRules.example)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesRules::example() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.BytesRules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesRules::mutable_example() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.BytesRules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesRules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesRules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool BytesRules::has_well_known() const {
  return well_known_case() != WELL_KNOWN_NOT_SET;
}
inline void BytesRules::clear_has_well_known() {
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}
inline BytesRules::WellKnownCase BytesRules::well_known_case() const {
  return BytesRules::WellKnownCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EnumRules

// optional int32 const = 1 [json_name = "const", (.buf.validate.predefined) = {
inline bool EnumRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EnumRules::clear_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t EnumRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.EnumRules.const)
  return _internal_const_();
}
inline void EnumRules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:buf.validate.EnumRules.const)
}
inline ::int32_t EnumRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.const__;
}
inline void EnumRules::_internal_set_const_(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.const__ = value;
}

// optional bool defined_only = 2 [json_name = "definedOnly"];
inline bool EnumRules::has_defined_only() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EnumRules::clear_defined_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.defined_only_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool EnumRules::defined_only() const {
  // @@protoc_insertion_point(field_get:buf.validate.EnumRules.defined_only)
  return _internal_defined_only();
}
inline void EnumRules::set_defined_only(bool value) {
  _internal_set_defined_only(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:buf.validate.EnumRules.defined_only)
}
inline bool EnumRules::_internal_defined_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.defined_only_;
}
inline void EnumRules::_internal_set_defined_only(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.defined_only_ = value;
}

// repeated int32 in = 3 [json_name = "in", (.buf.validate.predefined) = {
inline int EnumRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int EnumRules::in_size() const {
  return _internal_in_size();
}
inline void EnumRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline ::int32_t EnumRules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.EnumRules.in)
  return _internal_in().Get(index);
}
inline void EnumRules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.EnumRules.in)
}
inline void EnumRules::add_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.EnumRules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& EnumRules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.EnumRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* EnumRules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.EnumRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
EnumRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* EnumRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.predefined) = {
inline int EnumRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int EnumRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void EnumRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline ::int32_t EnumRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.EnumRules.not_in)
  return _internal_not_in().Get(index);
}
inline void EnumRules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.EnumRules.not_in)
}
inline void EnumRules::add_not_in(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.EnumRules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& EnumRules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.EnumRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* EnumRules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.EnumRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
EnumRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* EnumRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated int32 example = 5 [json_name = "example", (.buf.validate.predefined) = {
inline int EnumRules::_internal_example_size() const {
  return _internal_example().size();
}
inline int EnumRules::example_size() const {
  return _internal_example_size();
}
inline void EnumRules::clear_example() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.example_.Clear();
}
inline ::int32_t EnumRules::example(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.EnumRules.example)
  return _internal_example().Get(index);
}
inline void EnumRules::set_example(int index, ::int32_t value) {
  _internal_mutable_example()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.EnumRules.example)
}
inline void EnumRules::add_example(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_example()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.EnumRules.example)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& EnumRules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.EnumRules.example)
  return _internal_example();
}
inline ::google::protobuf::RepeatedField<::int32_t>* EnumRules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.EnumRules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
EnumRules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* EnumRules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

// -------------------------------------------------------------------

// RepeatedRules

// optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.predefined) = {
inline bool RepeatedRules::has_min_items() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepeatedRules::clear_min_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_items_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t RepeatedRules::min_items() const {
  // @@protoc_insertion_point(field_get:buf.validate.RepeatedRules.min_items)
  return _internal_min_items();
}
inline void RepeatedRules::set_min_items(::uint64_t value) {
  _internal_set_min_items(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:buf.validate.RepeatedRules.min_items)
}
inline ::uint64_t RepeatedRules::_internal_min_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_items_;
}
inline void RepeatedRules::_internal_set_min_items(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_items_ = value;
}

// optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.predefined) = {
inline bool RepeatedRules::has_max_items() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RepeatedRules::clear_max_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_items_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t RepeatedRules::max_items() const {
  // @@protoc_insertion_point(field_get:buf.validate.RepeatedRules.max_items)
  return _internal_max_items();
}
inline void RepeatedRules::set_max_items(::uint64_t value) {
  _internal_set_max_items(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:buf.validate.RepeatedRules.max_items)
}
inline ::uint64_t RepeatedRules::_internal_max_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_items_;
}
inline void RepeatedRules::_internal_set_max_items(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_items_ = value;
}

// optional bool unique = 3 [json_name = "unique", (.buf.validate.predefined) = {
inline bool RepeatedRules::has_unique() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RepeatedRules::clear_unique() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unique_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RepeatedRules::unique() const {
  // @@protoc_insertion_point(field_get:buf.validate.RepeatedRules.unique)
  return _internal_unique();
}
inline void RepeatedRules::set_unique(bool value) {
  _internal_set_unique(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:buf.validate.RepeatedRules.unique)
}
inline bool RepeatedRules::_internal_unique() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unique_;
}
inline void RepeatedRules::_internal_set_unique(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unique_ = value;
}

// optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
inline bool RepeatedRules::has_items() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.items_ != nullptr);
  return value;
}
inline void RepeatedRules::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.items_ != nullptr) _impl_.items_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::buf::validate::FieldConstraints& RepeatedRules::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::buf::validate::FieldConstraints* p = _impl_.items_;
  return p != nullptr ? *p : reinterpret_cast<const ::buf::validate::FieldConstraints&>(::buf::validate::_FieldConstraints_default_instance_);
}
inline const ::buf::validate::FieldConstraints& RepeatedRules::items() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.RepeatedRules.items)
  return _internal_items();
}
inline void RepeatedRules::unsafe_arena_set_allocated_items(::buf::validate::FieldConstraints* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.items_);
  }
  _impl_.items_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.RepeatedRules.items)
}
inline ::buf::validate::FieldConstraints* RepeatedRules::release_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::buf::validate::FieldConstraints* released = _impl_.items_;
  _impl_.items_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::buf::validate::FieldConstraints* RepeatedRules::unsafe_arena_release_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.RepeatedRules.items)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::buf::validate::FieldConstraints* temp = _impl_.items_;
  _impl_.items_ = nullptr;
  return temp;
}
inline ::buf::validate::FieldConstraints* RepeatedRules::_internal_mutable_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.items_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::buf::validate::FieldConstraints>(GetArena());
    _impl_.items_ = reinterpret_cast<::buf::validate::FieldConstraints*>(p);
  }
  return _impl_.items_;
}
inline ::buf::validate::FieldConstraints* RepeatedRules::mutable_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::buf::validate::FieldConstraints* _msg = _internal_mutable_items();
  // @@protoc_insertion_point(field_mutable:buf.validate.RepeatedRules.items)
  return _msg;
}
inline void RepeatedRules::set_allocated_items(::buf::validate::FieldConstraints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.items_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.items_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.RepeatedRules.items)
}

// -------------------------------------------------------------------

// MapRules

// optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.predefined) = {
inline bool MapRules::has_min_pairs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MapRules::clear_min_pairs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_pairs_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t MapRules::min_pairs() const {
  // @@protoc_insertion_point(field_get:buf.validate.MapRules.min_pairs)
  return _internal_min_pairs();
}
inline void MapRules::set_min_pairs(::uint64_t value) {
  _internal_set_min_pairs(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:buf.validate.MapRules.min_pairs)
}
inline ::uint64_t MapRules::_internal_min_pairs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_pairs_;
}
inline void MapRules::_internal_set_min_pairs(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_pairs_ = value;
}

// optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.predefined) = {
inline bool MapRules::has_max_pairs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MapRules::clear_max_pairs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_pairs_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t MapRules::max_pairs() const {
  // @@protoc_insertion_point(field_get:buf.validate.MapRules.max_pairs)
  return _internal_max_pairs();
}
inline void MapRules::set_max_pairs(::uint64_t value) {
  _internal_set_max_pairs(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:buf.validate.MapRules.max_pairs)
}
inline ::uint64_t MapRules::_internal_max_pairs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_pairs_;
}
inline void MapRules::_internal_set_max_pairs(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_pairs_ = value;
}

// optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
inline bool MapRules::has_keys() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.keys_ != nullptr);
  return value;
}
inline void MapRules::clear_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.keys_ != nullptr) _impl_.keys_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::buf::validate::FieldConstraints& MapRules::_internal_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::buf::validate::FieldConstraints* p = _impl_.keys_;
  return p != nullptr ? *p : reinterpret_cast<const ::buf::validate::FieldConstraints&>(::buf::validate::_FieldConstraints_default_instance_);
}
inline const ::buf::validate::FieldConstraints& MapRules::keys() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.MapRules.keys)
  return _internal_keys();
}
inline void MapRules::unsafe_arena_set_allocated_keys(::buf::validate::FieldConstraints* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.keys_);
  }
  _impl_.keys_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.MapRules.keys)
}
inline ::buf::validate::FieldConstraints* MapRules::release_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::buf::validate::FieldConstraints* released = _impl_.keys_;
  _impl_.keys_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::buf::validate::FieldConstraints* MapRules::unsafe_arena_release_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.MapRules.keys)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::buf::validate::FieldConstraints* temp = _impl_.keys_;
  _impl_.keys_ = nullptr;
  return temp;
}
inline ::buf::validate::FieldConstraints* MapRules::_internal_mutable_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.keys_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::buf::validate::FieldConstraints>(GetArena());
    _impl_.keys_ = reinterpret_cast<::buf::validate::FieldConstraints*>(p);
  }
  return _impl_.keys_;
}
inline ::buf::validate::FieldConstraints* MapRules::mutable_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::buf::validate::FieldConstraints* _msg = _internal_mutable_keys();
  // @@protoc_insertion_point(field_mutable:buf.validate.MapRules.keys)
  return _msg;
}
inline void MapRules::set_allocated_keys(::buf::validate::FieldConstraints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.keys_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.keys_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.MapRules.keys)
}

// optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
inline bool MapRules::has_values() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.values_ != nullptr);
  return value;
}
inline void MapRules::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.values_ != nullptr) _impl_.values_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::buf::validate::FieldConstraints& MapRules::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::buf::validate::FieldConstraints* p = _impl_.values_;
  return p != nullptr ? *p : reinterpret_cast<const ::buf::validate::FieldConstraints&>(::buf::validate::_FieldConstraints_default_instance_);
}
inline const ::buf::validate::FieldConstraints& MapRules::values() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.MapRules.values)
  return _internal_values();
}
inline void MapRules::unsafe_arena_set_allocated_values(::buf::validate::FieldConstraints* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.values_);
  }
  _impl_.values_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.MapRules.values)
}
inline ::buf::validate::FieldConstraints* MapRules::release_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::buf::validate::FieldConstraints* released = _impl_.values_;
  _impl_.values_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::buf::validate::FieldConstraints* MapRules::unsafe_arena_release_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.MapRules.values)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::buf::validate::FieldConstraints* temp = _impl_.values_;
  _impl_.values_ = nullptr;
  return temp;
}
inline ::buf::validate::FieldConstraints* MapRules::_internal_mutable_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.values_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::buf::validate::FieldConstraints>(GetArena());
    _impl_.values_ = reinterpret_cast<::buf::validate::FieldConstraints*>(p);
  }
  return _impl_.values_;
}
inline ::buf::validate::FieldConstraints* MapRules::mutable_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::buf::validate::FieldConstraints* _msg = _internal_mutable_values();
  // @@protoc_insertion_point(field_mutable:buf.validate.MapRules.values)
  return _msg;
}
inline void MapRules::set_allocated_values(::buf::validate::FieldConstraints* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.values_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.values_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.MapRules.values)
}

// -------------------------------------------------------------------

// AnyRules

// repeated string in = 2 [json_name = "in"];
inline int AnyRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int AnyRules::in_size() const {
  return _internal_in_size();
}
inline void AnyRules::clear_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.in_.Clear();
}
inline std::string* AnyRules::add_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.AnyRules.in)
  return _s;
}
inline const std::string& AnyRules::in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.AnyRules.in)
  return _internal_in().Get(index);
}
inline std::string* AnyRules::mutable_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.AnyRules.in)
  return _internal_mutable_in()->Mutable(index);
}
inline void AnyRules::set_in(int index, const std::string& value) {
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.AnyRules.in)
}
inline void AnyRules::set_in(int index, std::string&& value) {
  _internal_mutable_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.AnyRules.in)
}
inline void AnyRules::set_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.AnyRules.in)
}
inline void AnyRules::set_in(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.AnyRules.in)
}
inline void AnyRules::set_in(int index, absl::string_view value) {
  _internal_mutable_in()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.AnyRules.in)
}
inline void AnyRules::add_in(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.AnyRules.in)
}
inline void AnyRules::add_in(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.AnyRules.in)
}
inline void AnyRules::add_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.AnyRules.in)
}
inline void AnyRules::add_in(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.AnyRules.in)
}
inline void AnyRules::add_in(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_in()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.AnyRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AnyRules::in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.AnyRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AnyRules::mutable_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.AnyRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AnyRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AnyRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated string not_in = 3 [json_name = "notIn"];
inline int AnyRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int AnyRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void AnyRules::clear_not_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_in_.Clear();
}
inline std::string* AnyRules::add_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.AnyRules.not_in)
  return _s;
}
inline const std::string& AnyRules::not_in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.AnyRules.not_in)
  return _internal_not_in().Get(index);
}
inline std::string* AnyRules::mutable_not_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.AnyRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
inline void AnyRules::set_not_in(int index, const std::string& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.AnyRules.not_in)
}
inline void AnyRules::set_not_in(int index, std::string&& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.AnyRules.not_in)
}
inline void AnyRules::set_not_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.AnyRules.not_in)
}
inline void AnyRules::set_not_in(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_not_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.AnyRules.not_in)
}
inline void AnyRules::set_not_in(int index, absl::string_view value) {
  _internal_mutable_not_in()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_not_in()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.AnyRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AnyRules::not_in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.AnyRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AnyRules::mutable_not_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.AnyRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AnyRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AnyRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// -------------------------------------------------------------------

// DurationRules

// optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.predefined) = {
inline bool DurationRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.const__ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& DurationRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Duration* p = _impl_.const__;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::const_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.const)
  return _internal_const_();
}
inline void DurationRules::unsafe_arena_set_allocated_const_(::google::protobuf::Duration* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }
  _impl_.const__ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.DurationRules.const)
}
inline ::google::protobuf::Duration* DurationRules::release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.const__;
  _impl_.const__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* DurationRules::unsafe_arena_release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.DurationRules.const)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.const__;
  _impl_.const__ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* DurationRules::_internal_mutable_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.const__ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.const__ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.const__;
}
inline ::google::protobuf::Duration* DurationRules::mutable_const_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Duration* _msg = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.const)
  return _msg;
}
inline void DurationRules::set_allocated_const_(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.const__ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.const)
}

// .google.protobuf.Duration lt = 3 [json_name = "lt", (.buf.validate.predefined) = {
inline bool DurationRules::has_lt() const {
  return less_than_case() == kLt;
}
inline bool DurationRules::_internal_has_lt() const {
  return less_than_case() == kLt;
}
inline void DurationRules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline ::google::protobuf::Duration* DurationRules::release_lt() {
  // @@protoc_insertion_point(field_release:buf.validate.DurationRules.lt)
  if (less_than_case() == kLt) {
    clear_has_less_than();
    auto* temp = _impl_.less_than_.lt_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.less_than_.lt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Duration& DurationRules::_internal_lt() const {
  return less_than_case() == kLt ? *_impl_.less_than_.lt_ : reinterpret_cast<::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::lt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.lt)
  return _internal_lt();
}
inline ::google::protobuf::Duration* DurationRules::unsafe_arena_release_lt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.DurationRules.lt)
  if (less_than_case() == kLt) {
    clear_has_less_than();
    auto* temp = _impl_.less_than_.lt_;
    _impl_.less_than_.lt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DurationRules::unsafe_arena_set_allocated_lt(::google::protobuf::Duration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_less_than();
  if (value) {
    set_has_lt();
    _impl_.less_than_.lt_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.DurationRules.lt)
}
inline ::google::protobuf::Duration* DurationRules::_internal_mutable_lt() {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
    _impl_.less_than_.lt_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
  }
  return _impl_.less_than_.lt_;
}
inline ::google::protobuf::Duration* DurationRules::mutable_lt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_lt();
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.lt)
  return _msg;
}

// .google.protobuf.Duration lte = 4 [json_name = "lte", (.buf.validate.predefined) = {
inline bool DurationRules::has_lte() const {
  return less_than_case() == kLte;
}
inline bool DurationRules::_internal_has_lte() const {
  return less_than_case() == kLte;
}
inline void DurationRules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline ::google::protobuf::Duration* DurationRules::release_lte() {
  // @@protoc_insertion_point(field_release:buf.validate.DurationRules.lte)
  if (less_than_case() == kLte) {
    clear_has_less_than();
    auto* temp = _impl_.less_than_.lte_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.less_than_.lte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Duration& DurationRules::_internal_lte() const {
  return less_than_case() == kLte ? *_impl_.less_than_.lte_ : reinterpret_cast<::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::lte() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.lte)
  return _internal_lte();
}
inline ::google::protobuf::Duration* DurationRules::unsafe_arena_release_lte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.DurationRules.lte)
  if (less_than_case() == kLte) {
    clear_has_less_than();
    auto* temp = _impl_.less_than_.lte_;
    _impl_.less_than_.lte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DurationRules::unsafe_arena_set_allocated_lte(::google::protobuf::Duration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_less_than();
  if (value) {
    set_has_lte();
    _impl_.less_than_.lte_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.DurationRules.lte)
}
inline ::google::protobuf::Duration* DurationRules::_internal_mutable_lte() {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
    _impl_.less_than_.lte_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
  }
  return _impl_.less_than_.lte_;
}
inline ::google::protobuf::Duration* DurationRules::mutable_lte() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_lte();
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.lte)
  return _msg;
}

// .google.protobuf.Duration gt = 5 [json_name = "gt", (.buf.validate.predefined) = {
inline bool DurationRules::has_gt() const {
  return greater_than_case() == kGt;
}
inline bool DurationRules::_internal_has_gt() const {
  return greater_than_case() == kGt;
}
inline void DurationRules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline ::google::protobuf::Duration* DurationRules::release_gt() {
  // @@protoc_insertion_point(field_release:buf.validate.DurationRules.gt)
  if (greater_than_case() == kGt) {
    clear_has_greater_than();
    auto* temp = _impl_.greater_than_.gt_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.greater_than_.gt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Duration& DurationRules::_internal_gt() const {
  return greater_than_case() == kGt ? *_impl_.greater_than_.gt_ : reinterpret_cast<::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::gt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.gt)
  return _internal_gt();
}
inline ::google::protobuf::Duration* DurationRules::unsafe_arena_release_gt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.DurationRules.gt)
  if (greater_than_case() == kGt) {
    clear_has_greater_than();
    auto* temp = _impl_.greater_than_.gt_;
    _impl_.greater_than_.gt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DurationRules::unsafe_arena_set_allocated_gt(::google::protobuf::Duration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_greater_than();
  if (value) {
    set_has_gt();
    _impl_.greater_than_.gt_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.DurationRules.gt)
}
inline ::google::protobuf::Duration* DurationRules::_internal_mutable_gt() {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
    _impl_.greater_than_.gt_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
  }
  return _impl_.greater_than_.gt_;
}
inline ::google::protobuf::Duration* DurationRules::mutable_gt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_gt();
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.gt)
  return _msg;
}

// .google.protobuf.Duration gte = 6 [json_name = "gte", (.buf.validate.predefined) = {
inline bool DurationRules::has_gte() const {
  return greater_than_case() == kGte;
}
inline bool DurationRules::_internal_has_gte() const {
  return greater_than_case() == kGte;
}
inline void DurationRules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline ::google::protobuf::Duration* DurationRules::release_gte() {
  // @@protoc_insertion_point(field_release:buf.validate.DurationRules.gte)
  if (greater_than_case() == kGte) {
    clear_has_greater_than();
    auto* temp = _impl_.greater_than_.gte_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.greater_than_.gte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Duration& DurationRules::_internal_gte() const {
  return greater_than_case() == kGte ? *_impl_.greater_than_.gte_ : reinterpret_cast<::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::gte() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.gte)
  return _internal_gte();
}
inline ::google::protobuf::Duration* DurationRules::unsafe_arena_release_gte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.DurationRules.gte)
  if (greater_than_case() == kGte) {
    clear_has_greater_than();
    auto* temp = _impl_.greater_than_.gte_;
    _impl_.greater_than_.gte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DurationRules::unsafe_arena_set_allocated_gte(::google::protobuf::Duration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_greater_than();
  if (value) {
    set_has_gte();
    _impl_.greater_than_.gte_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.DurationRules.gte)
}
inline ::google::protobuf::Duration* DurationRules::_internal_mutable_gte() {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
    _impl_.greater_than_.gte_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
  }
  return _impl_.greater_than_.gte_;
}
inline ::google::protobuf::Duration* DurationRules::mutable_gte() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Duration* _msg = _internal_mutable_gte();
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.gte)
  return _msg;
}

// repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.predefined) = {
inline int DurationRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int DurationRules::in_size() const {
  return _internal_in_size();
}
inline ::google::protobuf::Duration* DurationRules::mutable_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.in)
  return _internal_mutable_in()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* DurationRules::mutable_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.DurationRules.in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_in();
}
inline const ::google::protobuf::Duration& DurationRules::in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.in)
  return _internal_in().Get(index);
}
inline ::google::protobuf::Duration* DurationRules::add_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Duration* _add = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.DurationRules.in)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& DurationRules::in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.DurationRules.in)
  return _internal_in();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>&
DurationRules::_internal_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>*
DurationRules::_internal_mutable_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.in_;
}

// repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.predefined) = {
inline int DurationRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int DurationRules::not_in_size() const {
  return _internal_not_in_size();
}
inline ::google::protobuf::Duration* DurationRules::mutable_not_in(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* DurationRules::mutable_not_in()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.DurationRules.not_in)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::Duration& DurationRules::not_in(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.not_in)
  return _internal_not_in().Get(index);
}
inline ::google::protobuf::Duration* DurationRules::add_not_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Duration* _add = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.DurationRules.not_in)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& DurationRules::not_in() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.DurationRules.not_in)
  return _internal_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>&
DurationRules::_internal_not_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>*
DurationRules::_internal_mutable_not_in() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.not_in_;
}

// repeated .google.protobuf.Duration example = 9 [json_name = "example", (.buf.validate.predefined) = {
inline int DurationRules::_internal_example_size() const {
  return _internal_example().size();
}
inline int DurationRules::example_size() const {
  return _internal_example_size();
}
inline ::google::protobuf::Duration* DurationRules::mutable_example(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.example)
  return _internal_mutable_example()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* DurationRules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.DurationRules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::Duration& DurationRules::example(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.example)
  return _internal_example().Get(index);
}
inline ::google::protobuf::Duration* DurationRules::add_example() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Duration* _add = _internal_mutable_example()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.DurationRules.example)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& DurationRules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.DurationRules.example)
  return _internal_example();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>&
DurationRules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>*
DurationRules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool DurationRules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void DurationRules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool DurationRules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void DurationRules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline DurationRules::LessThanCase DurationRules::less_than_case() const {
  return DurationRules::LessThanCase(_impl_._oneof_case_[0]);
}
inline DurationRules::GreaterThanCase DurationRules::greater_than_case() const {
  return DurationRules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// TimestampRules

// optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.predefined) = {
inline bool TimestampRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.const__ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_const_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.const__;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::const_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.const)
  return _internal_const_();
}
inline void TimestampRules::unsafe_arena_set_allocated_const_(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }
  _impl_.const__ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.const)
}
inline ::google::protobuf::Timestamp* TimestampRules::release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.const__;
  _impl_.const__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* TimestampRules::unsafe_arena_release_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.const)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.const__;
  _impl_.const__ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TimestampRules::_internal_mutable_const_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.const__ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.const__ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.const__;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_const_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.const)
  return _msg;
}
inline void TimestampRules::set_allocated_const_(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.const__ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.const)
}

// .google.protobuf.Timestamp lt = 3 [json_name = "lt", (.buf.validate.predefined) = {
inline bool TimestampRules::has_lt() const {
  return less_than_case() == kLt;
}
inline bool TimestampRules::_internal_has_lt() const {
  return less_than_case() == kLt;
}
inline void TimestampRules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_lt() {
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.lt)
  if (less_than_case() == kLt) {
    clear_has_less_than();
    auto* temp = _impl_.less_than_.lt_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.less_than_.lt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_lt() const {
  return less_than_case() == kLt ? *_impl_.less_than_.lt_ : reinterpret_cast<::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::lt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.lt)
  return _internal_lt();
}
inline ::google::protobuf::Timestamp* TimestampRules::unsafe_arena_release_lt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.TimestampRules.lt)
  if (less_than_case() == kLt) {
    clear_has_less_than();
    auto* temp = _impl_.less_than_.lt_;
    _impl_.less_than_.lt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TimestampRules::unsafe_arena_set_allocated_lt(::google::protobuf::Timestamp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_less_than();
  if (value) {
    set_has_lt();
    _impl_.less_than_.lt_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.lt)
}
inline ::google::protobuf::Timestamp* TimestampRules::_internal_mutable_lt() {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
    _impl_.less_than_.lt_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
  }
  return _impl_.less_than_.lt_;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_lt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_lt();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.lt)
  return _msg;
}

// .google.protobuf.Timestamp lte = 4 [json_name = "lte", (.buf.validate.predefined) = {
inline bool TimestampRules::has_lte() const {
  return less_than_case() == kLte;
}
inline bool TimestampRules::_internal_has_lte() const {
  return less_than_case() == kLte;
}
inline void TimestampRules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_lte() {
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.lte)
  if (less_than_case() == kLte) {
    clear_has_less_than();
    auto* temp = _impl_.less_than_.lte_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.less_than_.lte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_lte() const {
  return less_than_case() == kLte ? *_impl_.less_than_.lte_ : reinterpret_cast<::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::lte() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.lte)
  return _internal_lte();
}
inline ::google::protobuf::Timestamp* TimestampRules::unsafe_arena_release_lte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.TimestampRules.lte)
  if (less_than_case() == kLte) {
    clear_has_less_than();
    auto* temp = _impl_.less_than_.lte_;
    _impl_.less_than_.lte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TimestampRules::unsafe_arena_set_allocated_lte(::google::protobuf::Timestamp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_less_than();
  if (value) {
    set_has_lte();
    _impl_.less_than_.lte_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.lte)
}
inline ::google::protobuf::Timestamp* TimestampRules::_internal_mutable_lte() {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
    _impl_.less_than_.lte_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
  }
  return _impl_.less_than_.lte_;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_lte() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_lte();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.lte)
  return _msg;
}

// bool lt_now = 7 [json_name = "ltNow", (.buf.validate.predefined) = {
inline bool TimestampRules::has_lt_now() const {
  return less_than_case() == kLtNow;
}
inline void TimestampRules::set_has_lt_now() {
  _impl_._oneof_case_[0] = kLtNow;
}
inline void TimestampRules::clear_lt_now() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (less_than_case() == kLtNow) {
    _impl_.less_than_.lt_now_ = false;
    clear_has_less_than();
  }
}
inline bool TimestampRules::lt_now() const {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.lt_now)
  return _internal_lt_now();
}
inline void TimestampRules::set_lt_now(bool value) {
  if (less_than_case() != kLtNow) {
    clear_less_than();
    set_has_lt_now();
  }
  _impl_.less_than_.lt_now_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.TimestampRules.lt_now)
}
inline bool TimestampRules::_internal_lt_now() const {
  if (less_than_case() == kLtNow) {
    return _impl_.less_than_.lt_now_;
  }
  return false;
}

// .google.protobuf.Timestamp gt = 5 [json_name = "gt", (.buf.validate.predefined) = {
inline bool TimestampRules::has_gt() const {
  return greater_than_case() == kGt;
}
inline bool TimestampRules::_internal_has_gt() const {
  return greater_than_case() == kGt;
}
inline void TimestampRules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_gt() {
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.gt)
  if (greater_than_case() == kGt) {
    clear_has_greater_than();
    auto* temp = _impl_.greater_than_.gt_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.greater_than_.gt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_gt() const {
  return greater_than_case() == kGt ? *_impl_.greater_than_.gt_ : reinterpret_cast<::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::gt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.gt)
  return _internal_gt();
}
inline ::google::protobuf::Timestamp* TimestampRules::unsafe_arena_release_gt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.TimestampRules.gt)
  if (greater_than_case() == kGt) {
    clear_has_greater_than();
    auto* temp = _impl_.greater_than_.gt_;
    _impl_.greater_than_.gt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TimestampRules::unsafe_arena_set_allocated_gt(::google::protobuf::Timestamp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_greater_than();
  if (value) {
    set_has_gt();
    _impl_.greater_than_.gt_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.gt)
}
inline ::google::protobuf::Timestamp* TimestampRules::_internal_mutable_gt() {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
    _impl_.greater_than_.gt_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
  }
  return _impl_.greater_than_.gt_;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_gt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_gt();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.gt)
  return _msg;
}

// .google.protobuf.Timestamp gte = 6 [json_name = "gte", (.buf.validate.predefined) = {
inline bool TimestampRules::has_gte() const {
  return greater_than_case() == kGte;
}
inline bool TimestampRules::_internal_has_gte() const {
  return greater_than_case() == kGte;
}
inline void TimestampRules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_gte() {
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.gte)
  if (greater_than_case() == kGte) {
    clear_has_greater_than();
    auto* temp = _impl_.greater_than_.gte_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.greater_than_.gte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_gte() const {
  return greater_than_case() == kGte ? *_impl_.greater_than_.gte_ : reinterpret_cast<::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::gte() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.gte)
  return _internal_gte();
}
inline ::google::protobuf::Timestamp* TimestampRules::unsafe_arena_release_gte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.TimestampRules.gte)
  if (greater_than_case() == kGte) {
    clear_has_greater_than();
    auto* temp = _impl_.greater_than_.gte_;
    _impl_.greater_than_.gte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TimestampRules::unsafe_arena_set_allocated_gte(::google::protobuf::Timestamp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_greater_than();
  if (value) {
    set_has_gte();
    _impl_.greater_than_.gte_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.gte)
}
inline ::google::protobuf::Timestamp* TimestampRules::_internal_mutable_gte() {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
    _impl_.greater_than_.gte_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
  }
  return _impl_.greater_than_.gte_;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_gte() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_gte();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.gte)
  return _msg;
}

// bool gt_now = 8 [json_name = "gtNow", (.buf.validate.predefined) = {
inline bool TimestampRules::has_gt_now() const {
  return greater_than_case() == kGtNow;
}
inline void TimestampRules::set_has_gt_now() {
  _impl_._oneof_case_[1] = kGtNow;
}
inline void TimestampRules::clear_gt_now() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (greater_than_case() == kGtNow) {
    _impl_.greater_than_.gt_now_ = false;
    clear_has_greater_than();
  }
}
inline bool TimestampRules::gt_now() const {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.gt_now)
  return _internal_gt_now();
}
inline void TimestampRules::set_gt_now(bool value) {
  if (greater_than_case() != kGtNow) {
    clear_greater_than();
    set_has_gt_now();
  }
  _impl_.greater_than_.gt_now_ = value;
  // @@protoc_insertion_point(field_set:buf.validate.TimestampRules.gt_now)
}
inline bool TimestampRules::_internal_gt_now() const {
  if (greater_than_case() == kGtNow) {
    return _impl_.greater_than_.gt_now_;
  }
  return false;
}

// optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.predefined) = {
inline bool TimestampRules::has_within() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.within_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& TimestampRules::_internal_within() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Duration* p = _impl_.within_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& TimestampRules::within() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.within)
  return _internal_within();
}
inline void TimestampRules::unsafe_arena_set_allocated_within(::google::protobuf::Duration* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.within_);
  }
  _impl_.within_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.within)
}
inline ::google::protobuf::Duration* TimestampRules::release_within() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* released = _impl_.within_;
  _impl_.within_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* TimestampRules::unsafe_arena_release_within() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.within)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* temp = _impl_.within_;
  _impl_.within_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* TimestampRules::_internal_mutable_within() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.within_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.within_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.within_;
}
inline ::google::protobuf::Duration* TimestampRules::mutable_within() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Duration* _msg = _internal_mutable_within();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.within)
  return _msg;
}
inline void TimestampRules::set_allocated_within(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.within_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.within_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.within)
}

// repeated .google.protobuf.Timestamp example = 10 [json_name = "example", (.buf.validate.predefined) = {
inline int TimestampRules::_internal_example_size() const {
  return _internal_example().size();
}
inline int TimestampRules::example_size() const {
  return _internal_example_size();
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_example(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.example)
  return _internal_mutable_example()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Timestamp>* TimestampRules::mutable_example()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.TimestampRules.example)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_example();
}
inline const ::google::protobuf::Timestamp& TimestampRules::example(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.example)
  return _internal_example().Get(index);
}
inline ::google::protobuf::Timestamp* TimestampRules::add_example() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::Timestamp* _add = _internal_mutable_example()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.TimestampRules.example)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Timestamp>& TimestampRules::example() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.TimestampRules.example)
  return _internal_example();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Timestamp>&
TimestampRules::_internal_example() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.example_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Timestamp>*
TimestampRules::_internal_mutable_example() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.example_;
}

inline bool TimestampRules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void TimestampRules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool TimestampRules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void TimestampRules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline TimestampRules::LessThanCase TimestampRules::less_than_case() const {
  return TimestampRules::LessThanCase(_impl_._oneof_case_[0]);
}
inline TimestampRules::GreaterThanCase TimestampRules::greater_than_case() const {
  return TimestampRules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Violations

// repeated .buf.validate.Violation violations = 1 [json_name = "violations"];
inline int Violations::_internal_violations_size() const {
  return _internal_violations().size();
}
inline int Violations::violations_size() const {
  return _internal_violations_size();
}
inline void Violations::clear_violations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.violations_.Clear();
}
inline ::buf::validate::Violation* Violations::mutable_violations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:buf.validate.Violations.violations)
  return _internal_mutable_violations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::buf::validate::Violation>* Violations::mutable_violations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Violations.violations)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_violations();
}
inline const ::buf::validate::Violation& Violations::violations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.Violations.violations)
  return _internal_violations().Get(index);
}
inline ::buf::validate::Violation* Violations::add_violations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::buf::validate::Violation* _add = _internal_mutable_violations()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.Violations.violations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::buf::validate::Violation>& Violations::violations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:buf.validate.Violations.violations)
  return _internal_violations();
}
inline const ::google::protobuf::RepeatedPtrField<::buf::validate::Violation>&
Violations::_internal_violations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.violations_;
}
inline ::google::protobuf::RepeatedPtrField<::buf::validate::Violation>*
Violations::_internal_mutable_violations() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.violations_;
}

// -------------------------------------------------------------------

// Violation

// optional string field_path = 1 [json_name = "fieldPath"];
inline bool Violation::has_field_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Violation::clear_field_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Violation::field_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.Violation.field_path)
  return _internal_field_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Violation::set_field_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.field_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.Violation.field_path)
}
inline std::string* Violation::mutable_field_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_field_path();
  // @@protoc_insertion_point(field_mutable:buf.validate.Violation.field_path)
  return _s;
}
inline const std::string& Violation::_internal_field_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_path_.Get();
}
inline void Violation::_internal_set_field_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.field_path_.Set(value, GetArena());
}
inline std::string* Violation::_internal_mutable_field_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.field_path_.Mutable( GetArena());
}
inline std::string* Violation::release_field_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.Violation.field_path)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.field_path_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.field_path_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Violation::set_allocated_field_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.field_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.field_path_.IsDefault()) {
          _impl_.field_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.Violation.field_path)
}

// optional string constraint_id = 2 [json_name = "constraintId"];
inline bool Violation::has_constraint_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Violation::clear_constraint_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constraint_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Violation::constraint_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.Violation.constraint_id)
  return _internal_constraint_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Violation::set_constraint_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.constraint_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.Violation.constraint_id)
}
inline std::string* Violation::mutable_constraint_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_constraint_id();
  // @@protoc_insertion_point(field_mutable:buf.validate.Violation.constraint_id)
  return _s;
}
inline const std::string& Violation::_internal_constraint_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.constraint_id_.Get();
}
inline void Violation::_internal_set_constraint_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.constraint_id_.Set(value, GetArena());
}
inline std::string* Violation::_internal_mutable_constraint_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.constraint_id_.Mutable( GetArena());
}
inline std::string* Violation::release_constraint_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.Violation.constraint_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.constraint_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.constraint_id_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Violation::set_allocated_constraint_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.constraint_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.constraint_id_.IsDefault()) {
          _impl_.constraint_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.Violation.constraint_id)
}

// optional string message = 3 [json_name = "message"];
inline bool Violation::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Violation::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Violation::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:buf.validate.Violation.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Violation::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:buf.validate.Violation.message)
}
inline std::string* Violation::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:buf.validate.Violation.message)
  return _s;
}
inline const std::string& Violation::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void Violation::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* Violation::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* Violation::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:buf.validate.Violation.message)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Violation::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.Violation.message)
}

// optional bool for_key = 4 [json_name = "forKey"];
inline bool Violation::has_for_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Violation::clear_for_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.for_key_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Violation::for_key() const {
  // @@protoc_insertion_point(field_get:buf.validate.Violation.for_key)
  return _internal_for_key();
}
inline void Violation::set_for_key(bool value) {
  _internal_set_for_key(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:buf.validate.Violation.for_key)
}
inline bool Violation::_internal_for_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.for_key_;
}
inline void Violation::_internal_set_for_key(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.for_key_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace validate
}  // namespace buf


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::buf::validate::Ignore> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::buf::validate::Ignore>() {
  return ::buf::validate::Ignore_descriptor();
}
template <>
struct is_proto_enum<::buf::validate::KnownRegex> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::buf::validate::KnownRegex>() {
  return ::buf::validate::KnownRegex_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_buf_2fvalidate_2fvalidate_2eproto_2epb_2eh
